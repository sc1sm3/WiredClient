<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Wired Foundation: RegexKitLite.m Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Wired Foundation
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">A foundation framework for the Wired implementation on Mac OS X</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00085.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">RegexKitLite.m</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//</span>
<a name="l00002"></a>00002 <span class="comment">//  RegexKitLite.m</span>
<a name="l00003"></a>00003 <span class="comment">//  http://regexkit.sourceforge.net/</span>
<a name="l00004"></a>00004 <span class="comment">//  Licensed under the terms of the BSD License, as specified below.</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/*</span>
<a name="l00008"></a>00008 <span class="comment"> Copyright (c) 2008-2010, John Engelhart</span>
<a name="l00009"></a>00009 <span class="comment"> </span>
<a name="l00010"></a>00010 <span class="comment"> All rights reserved.</span>
<a name="l00011"></a>00011 <span class="comment"> </span>
<a name="l00012"></a>00012 <span class="comment"> Redistribution and use in source and binary forms, with or without</span>
<a name="l00013"></a>00013 <span class="comment"> modification, are permitted provided that the following conditions are met:</span>
<a name="l00014"></a>00014 <span class="comment"> </span>
<a name="l00015"></a>00015 <span class="comment"> * Redistributions of source code must retain the above copyright</span>
<a name="l00016"></a>00016 <span class="comment"> notice, this list of conditions and the following disclaimer.</span>
<a name="l00017"></a>00017 <span class="comment"> </span>
<a name="l00018"></a>00018 <span class="comment"> * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00019"></a>00019 <span class="comment"> notice, this list of conditions and the following disclaimer in the</span>
<a name="l00020"></a>00020 <span class="comment"> documentation and/or other materials provided with the distribution.</span>
<a name="l00021"></a>00021 <span class="comment"> </span>
<a name="l00022"></a>00022 <span class="comment"> * Neither the name of the Zang Industries nor the names of its</span>
<a name="l00023"></a>00023 <span class="comment"> contributors may be used to endorse or promote products derived from</span>
<a name="l00024"></a>00024 <span class="comment"> this software without specific prior written permission.</span>
<a name="l00025"></a>00025 <span class="comment"> </span>
<a name="l00026"></a>00026 <span class="comment"> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00027"></a>00027 <span class="comment"> &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00028"></a>00028 <span class="comment"> LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00029"></a>00029 <span class="comment"> A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00030"></a>00030 <span class="comment"> OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00031"></a>00031 <span class="comment"> SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED</span>
<a name="l00032"></a>00032 <span class="comment"> TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00033"></a>00033 <span class="comment"> PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<a name="l00034"></a>00034 <span class="comment"> LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<a name="l00035"></a>00035 <span class="comment"> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00036"></a>00036 <span class="comment"> SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00037"></a>00037 <span class="comment">*/</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;CoreFoundation/CFBase.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;CoreFoundation/CFArray.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;CoreFoundation/CFString.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#import &lt;Foundation/NSArray.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#import &lt;Foundation/NSDictionary.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#import &lt;Foundation/NSError.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#import &lt;Foundation/NSException.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#import &lt;Foundation/NSNotification.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#import &lt;Foundation/NSRunLoop.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#ifdef    __OBJC_GC__</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#import &lt;Foundation/NSGarbageCollector.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#define RKL_STRONG_REF __strong</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define RKL_GC_VOLATILE volatile</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#else  // __OBJC_GC__</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#define RKL_STRONG_REF</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#define RKL_GC_VOLATILE</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#endif // __OBJC_GC__</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="preprocessor">#if (defined(TARGET_OS_EMBEDDED) &amp;&amp; (TARGET_OS_EMBEDDED != 0)) || (defined(TARGET_OS_IPHONE) &amp;&amp; (TARGET_OS_IPHONE != 0)) || (defined(MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; (MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 1050))</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#include &lt;objc/runtime.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#else</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#include &lt;objc/objc-runtime.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;libkern/OSAtomic.h&gt;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;mach-o/loader.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;AvailabilityMacros.h&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;dlfcn.h&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="preprocessor">#import &quot;RegexKitLite.h&quot;</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">// If the gcc flag -mmacosx-version-min is used with, for example, &#39;=10.2&#39;, give a warning that the libicucore.dylib is only available on &gt;= 10.3.</span>
<a name="l00075"></a>00075 <span class="comment">// If you are reading this comment because of this warning, this is to let you know that linking to /usr/lib/libicucore.dylib will cause your executable to fail on &lt; 10.3.</span>
<a name="l00076"></a>00076 <span class="comment">// You will need to build your own version of the ICU library and link to that in order for RegexKitLite to work successfully on &lt; 10.3.  This is not simple.</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="preprocessor">#if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1030</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#warning The ICU dynamic shared library, /usr/lib/libicucore.dylib, is only available on Mac OS X 10.3 and later.</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#warning You will need to supply a version of the ICU library to use RegexKitLite on Mac OS X 10.2 and earlier.</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00084"></a>00084 <span class="preprocessor">#pragma mark Compile time tunables</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 <span class="preprocessor">#ifndef RKL_CACHE_SIZE</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#define RKL_CACHE_SIZE (13UL)</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>
<a name="l00090"></a>00090 <span class="preprocessor">#if       RKL_CACHE_SIZE &lt; 1</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#error RKL_CACHE_SIZE must be a non-negative number greater than 0.</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#endif // RKL_CACHE_SIZE &lt; 1</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span>
<a name="l00094"></a>00094 <span class="preprocessor">#ifndef RKL_FIXED_LENGTH</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#define RKL_FIXED_LENGTH (2048UL)</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span>
<a name="l00098"></a>00098 <span class="preprocessor">#if       RKL_FIXED_LENGTH &lt; 1</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#error RKL_FIXED_LENGTH must be a non-negative number greater than 0.</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#endif // RKL_FIXED_LENGTH &lt; 1</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="preprocessor">#ifndef RKL_STACK_LIMIT</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#define RKL_STACK_LIMIT (128UL * 1024UL)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span>
<a name="l00106"></a>00106 <span class="preprocessor">#if       RKL_STACK_LIMIT &lt; 0</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#error RKL_STACK_LIMIT must be a non-negative number.</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#endif // RKL_STACK_LIMIT &lt; 0</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 <span class="preprocessor">#ifdef    RKL_APPEND_TO_ICU_FUNCTIONS</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ICU_FUNCTION_APPEND(x) _RKL_CONCAT(x, RKL_APPEND_TO_ICU_FUNCTIONS)</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#else  // RKL_APPEND_TO_ICU_FUNCTIONS</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ICU_FUNCTION_APPEND(x) x</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#endif // RKL_APPEND_TO_ICU_FUNCTIONS</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="preprocessor">#if       defined(RKL_DTRACE) &amp;&amp; (RKL_DTRACE != 0)</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_DTRACE_ENABLED 1</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#endif // defined(RKL_DTRACE) &amp;&amp; (RKL_DTRACE != 0)</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a>00120 <span class="comment">// These are internal, non-public tunables.</span>
<a name="l00121"></a>00121 <span class="preprocessor">#define _RKL_FIXED_LENGTH                ((NSUInteger)RKL_FIXED_LENGTH)</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_STACK_LIMIT                 ((NSUInteger)RKL_STACK_LIMIT)</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_SCRATCH_BUFFERS             (5UL)</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#if       _RKL_SCRATCH_BUFFERS != 5</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#error _RKL_SCRATCH_BUFFERS is not tunable, it must be set to 5.</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#endif // _RKL_SCRATCH_BUFFERS != 5</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_PREFETCH_SIZE               (64UL)</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_DTRACE_REGEXUTF8_SIZE       (64UL)</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>
<a name="l00130"></a>00130 <span class="comment">// A LRU Cache Set holds 4 lines, and the LRU algorithm uses 4 bits per line.</span>
<a name="l00131"></a>00131 <span class="comment">// A LRU Cache Set has a type of RKLLRUCacheSet_t and is 16 bits wide (4 lines * 4 bits per line).</span>
<a name="l00132"></a>00132 <span class="comment">// RKLLRUCacheSet_t must be initialized to a value of 0x0137 in order to work correctly.</span>
<a name="l00133"></a>00133 <span class="keyword">typedef</span> uint16_t RKLLRUCacheSet_t;
<a name="l00134"></a>00134 <span class="preprocessor">#define _RKL_LRU_CACHE_SET_INIT          ((RKLLRUCacheSet_t)0x0137U)</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_LRU_CACHE_SET_WAYS          (4UL)</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">#if       _RKL_LRU_CACHE_SET_WAYS != 4</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#error _RKL_LRU_CACHE_SET_WAYS is not tunable, it must be set to 4.</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">#endif // _RKL_LRU_CACHE_SET_WAYS != 4</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>
<a name="l00140"></a>00140 <span class="preprocessor">#define _RKL_REGEX_LRU_CACHE_SETS        ((NSUInteger)(RKL_CACHE_SIZE))</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_REGEX_CACHE_LINES           ((NSUInteger)((NSUInteger)(_RKL_REGEX_LRU_CACHE_SETS) * (NSUInteger)(_RKL_LRU_CACHE_SET_WAYS)))</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span>
<a name="l00143"></a>00143 <span class="comment">// Regex String Lookaside Cache parameters.</span>
<a name="l00144"></a>00144 <span class="preprocessor">#define _RKL_REGEX_LOOKASIDE_CACHE_BITS   (6UL)</span>
<a name="l00145"></a>00145 <span class="preprocessor"></span><span class="preprocessor">#if       _RKL_REGEX_LOOKASIDE_CACHE_BITS &lt; 0</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="preprocessor">#error _RKL_REGEX_LOOKASIDE_CACHE_BITS must be a non-negative number and is not intended to be user tunable.</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor">#endif // _RKL_REGEX_LOOKASIDE_CACHE_BITS &lt; 0</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_REGEX_LOOKASIDE_CACHE_SIZE   (1LU &lt;&lt; _RKL_REGEX_LOOKASIDE_CACHE_BITS)</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span><span class="preprocessor">#define _RKL_REGEX_LOOKASIDE_CACHE_MASK  ((1LU &lt;&lt; _RKL_REGEX_LOOKASIDE_CACHE_BITS) - 1LU)</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="comment">// RKLLookasideCache_t should be large enough to to hold the maximum number of cached regexes, or (RKL_CACHE_SIZE * _RKL_LRU_CACHE_SET_WAYS).</span>
<a name="l00151"></a>00151 <span class="preprocessor">#if       (RKL_CACHE_SIZE * _RKL_LRU_CACHE_SET_WAYS) &lt;= (1 &lt;&lt; 8)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="keyword">typedef</span> uint8_t RKLLookasideCache_t;
<a name="l00153"></a>00153 <span class="preprocessor">#elif     (RKL_CACHE_SIZE * _RKL_LRU_CACHE_SET_WAYS) &lt;= (1 &lt;&lt; 16)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="keyword">typedef</span> uint16_t RKLLookasideCache_t;
<a name="l00155"></a>00155 <span class="preprocessor">#else  // (RKL_CACHE_SIZE * _RKL_LRU_CACHE_SET_WAYS)  &gt; (1 &lt;&lt; 16)</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="keyword">typedef</span> uint32_t RKLLookasideCache_t;
<a name="l00157"></a>00157 <span class="preprocessor">#endif // (RKL_CACHE_SIZE * _RKL_LRU_CACHE_SET_WAYS)</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="preprocessor">#pragma mark -</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">#pragma mark GCC / Compiler macros</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>
<a name="l00163"></a>00163 <span class="preprocessor">#if       defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ATTRIBUTES(attr, ...)        __attribute__((attr, ##__VA_ARGS__))</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">#define RKL_EXPECTED(cond, expect)       __builtin_expect((long)(cond), (expect))</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">#define RKL_PREFETCH(ptr)                __builtin_prefetch(ptr)</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#define RKL_PREFETCH_UNICHAR(ptr, off)   { const char *p = ((const char *)(ptr)) + ((off) * sizeof(UniChar)) + _RKL_PREFETCH_SIZE; RKL_PREFETCH(p); RKL_PREFETCH(p + _RKL_PREFETCH_SIZE); }</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#define RKL_HAVE_CLEANUP</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="preprocessor">#define RKL_CLEANUP(func)                RKL_ATTRIBUTES(cleanup(func))</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor">#else  // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) </span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ATTRIBUTES(attr, ...)</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">#define RKL_EXPECTED(cond, expect)       (cond)</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span><span class="preprocessor">#define RKL_PREFETCH(ptr)</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">#define RKL_PREFETCH_UNICHAR(ptr, off)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#define RKL_CLEANUP(func)</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#endif // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) </span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>
<a name="l00178"></a>00178 <span class="preprocessor">#define RKL_STATIC_INLINE                         static __inline__ RKL_ATTRIBUTES(always_inline)</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ALIGNED(arg)                                            RKL_ATTRIBUTES(aligned(arg))</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#define RKL_UNUSED_ARG                                              RKL_ATTRIBUTES(unused)</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED                                             RKL_ATTRIBUTES(warn_unused_result)</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED_CONST                                       RKL_ATTRIBUTES(warn_unused_result, const)</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED_PURE                                        RKL_ATTRIBUTES(warn_unused_result, pure)</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED_SENTINEL                                    RKL_ATTRIBUTES(warn_unused_result, sentinel)</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor">#define RKL_NONNULL_ARGS(arg, ...)                                  RKL_ATTRIBUTES(nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED_NONNULL_ARGS(arg, ...)                      RKL_ATTRIBUTES(warn_unused_result, nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED_CONST_NONNULL_ARGS(arg, ...)                RKL_ATTRIBUTES(warn_unused_result, const, nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span><span class="preprocessor">#define RKL_WARN_UNUSED_PURE_NONNULL_ARGS(arg, ...)                 RKL_ATTRIBUTES(warn_unused_result, pure, nonnull(arg, ##__VA_ARGS__))</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span>
<a name="l00190"></a>00190 <span class="preprocessor">#if       defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) RKL_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__), alloc_size(as))</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span><span class="preprocessor">#else  // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#define RKL_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) RKL_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__))</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#endif // defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>
<a name="l00196"></a>00196 <span class="preprocessor">#ifdef    _RKL_DTRACE_ENABLED</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span><span class="preprocessor">#define RKL_UNUSED_DTRACE_ARG</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span><span class="preprocessor">#else  // _RKL_DTRACE_ENABLED</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#define RKL_UNUSED_DTRACE_ARG RKL_ATTRIBUTES(unused)</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="preprocessor">#endif // _RKL_DTRACE_ENABLED</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>
<a name="l00203"></a>00203 <span class="preprocessor">#pragma mark -</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Assertion macros</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>
<a name="l00206"></a>00206 <span class="comment">// These macros are nearly identical to their NSCParameterAssert siblings.</span>
<a name="l00207"></a>00207 <span class="comment">// This is required because nearly everything is done while rkl_cacheSpinLock is locked.</span>
<a name="l00208"></a>00208 <span class="comment">// We need to safely unlock before throwing any of these exceptions.</span>
<a name="l00209"></a>00209 <span class="comment">// @try {} @finally {} significantly slows things down so it&#39;s not used.</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="preprocessor">#define RKLCHardAbortAssert(c) do { int _c=(c); if(RKL_EXPECTED(!_c, 0L)) { NSLog(@&quot;%@:%ld: Invalid parameter not satisfying: %s\n&quot;, [NSString stringWithUTF8String:__FILE__], (long)__LINE__, #c); abort(); } } while(0)</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span><span class="preprocessor">#define RKLCAssertDictionary(d, ...) rkl_makeAssertDictionary(__PRETTY_FUNCTION__, __FILE__, __LINE__, (d), ##__VA_ARGS__)</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span><span class="preprocessor">#define RKLCDelayedHardAssert(c, e, g) do { id *_e=(e); int _c=(c); if(RKL_EXPECTED(_e == NULL, 0L) || RKL_EXPECTED(*_e != NULL, 0L)) { goto g; } if(RKL_EXPECTED(!_c, 0L)) { *_e = RKLCAssertDictionary(@&quot;Invalid parameter not satisfying: %s&quot;, #c); goto g; } } while(0)</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>
<a name="l00215"></a>00215 <span class="preprocessor">#ifdef    NS_BLOCK_ASSERTIONS</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span><span class="preprocessor">#define RKLCAbortAssert(c)</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span><span class="preprocessor">#define RKLCDelayedAssert(c, e, g)</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span><span class="preprocessor">#define RKL_UNUSED_ASSERTION_ARG RKL_ATTRIBUTES(unused)</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span><span class="preprocessor">#else  // NS_BLOCK_ASSERTIONS</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#define RKLCAbortAssert(c) RKLCHardAbortAssert(c)</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span><span class="preprocessor">#define RKLCDelayedAssert(c, e, g) RKLCDelayedHardAssert(c, e, g)</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span><span class="preprocessor">#define RKL_UNUSED_ASSERTION_ARG</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span><span class="preprocessor">#endif // NS_BLOCK_ASSERTIONS</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>
<a name="l00225"></a>00225 <span class="preprocessor">#define RKL_EXCEPTION(e, f, ...)       [NSException exceptionWithName:(e) reason:rkl_stringFromClassAndMethod((self), (_cmd), (f), ##__VA_ARGS__) userInfo:NULL]</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span><span class="preprocessor">#define RKL_RAISE_EXCEPTION(e, f, ...) [RKL_EXCEPTION(e, f, ##__VA_ARGS__) raise]</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>
<a name="l00229"></a>00229 <span class="preprocessor">#pragma mark -</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Utility functions and macros</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span>
<a name="l00232"></a>00232 RKL_STATIC_INLINE BOOL NSRangeInsideRange(NSRange cin, NSRange win) RKL_WARN_UNUSED;
<a name="l00233"></a>00233 RKL_STATIC_INLINE BOOL NSRangeInsideRange(NSRange cin, NSRange win) { <span class="keywordflow">return</span>((((cin.location - win.location) &lt;= win.length) &amp;&amp; ((NSMaxRange(cin) - win.location) &lt;= win.length)) ? YES : NO); }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="preprocessor">#define NSMakeRange(loc, len) ((NSRange){.location=(NSUInteger)(loc),      .length=(NSUInteger)(len)})</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span><span class="preprocessor">#define CFMakeRange(loc, len) ((CFRange){.location=   (CFIndex)(loc),      .length=   (CFIndex)(len)})</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span><span class="preprocessor">#define NSNotFoundRange       ((NSRange){.location=(NSUInteger)NSNotFound, .length=              0UL})</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span><span class="preprocessor">#define NSMaxiumRange         ((NSRange){.location=                   0UL, .length=    NSUIntegerMax})</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="comment">// These values are used to help tickle improper usage.</span>
<a name="l00240"></a>00240 <span class="preprocessor">#define RKLIllegalRange       ((NSRange){.location=          NSIntegerMax, .length=     NSIntegerMax})</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span><span class="preprocessor">#define RKLIllegalPointer     ((void * RKL_GC_VOLATILE)0xBAD0C0DE)</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00244"></a>00244 <span class="preprocessor">#pragma mark -</span>
<a name="l00245"></a>00245 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Exported NSString symbols for exception names, error domains, error keys, etc</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>
<a name="l00247"></a>00247 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexException                  = <span class="stringliteral">@&quot;RKLICURegexException&quot;</span>;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexErrorDomain                = <span class="stringliteral">@&quot;RKLICURegexErrorDomain&quot;</span>;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexEnumerationOptionsErrorKey = <span class="stringliteral">@&quot;RKLICURegexEnumerationOptions&quot;</span>;
<a name="l00252"></a>00252 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexErrorCodeErrorKey          = <span class="stringliteral">@&quot;RKLICURegexErrorCode&quot;</span>;
<a name="l00253"></a>00253 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexErrorNameErrorKey          = <span class="stringliteral">@&quot;RKLICURegexErrorName&quot;</span>;
<a name="l00254"></a>00254 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexLineErrorKey               = <span class="stringliteral">@&quot;RKLICURegexLine&quot;</span>;
<a name="l00255"></a>00255 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexOffsetErrorKey             = <span class="stringliteral">@&quot;RKLICURegexOffset&quot;</span>;
<a name="l00256"></a>00256 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexPreContextErrorKey         = <span class="stringliteral">@&quot;RKLICURegexPreContext&quot;</span>;
<a name="l00257"></a>00257 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexPostContextErrorKey        = <span class="stringliteral">@&quot;RKLICURegexPostContext&quot;</span>;
<a name="l00258"></a>00258 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexRegexErrorKey              = <span class="stringliteral">@&quot;RKLICURegexRegex&quot;</span>;
<a name="l00259"></a>00259 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexRegexOptionsErrorKey       = <span class="stringliteral">@&quot;RKLICURegexRegexOptions&quot;</span>;
<a name="l00260"></a>00260 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexReplacedCountErrorKey      = <span class="stringliteral">@&quot;RKLICURegexReplacedCount&quot;</span>;
<a name="l00261"></a>00261 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexReplacedStringErrorKey     = <span class="stringliteral">@&quot;RKLICURegexReplacedString&quot;</span>;
<a name="l00262"></a>00262 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexReplacementStringErrorKey  = <span class="stringliteral">@&quot;RKLICURegexReplacementString&quot;</span>;
<a name="l00263"></a>00263 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexSubjectRangeErrorKey       = <span class="stringliteral">@&quot;RKLICURegexSubjectRange&quot;</span>;
<a name="l00264"></a>00264 <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> RKLICURegexSubjectStringErrorKey      = <span class="stringliteral">@&quot;RKLICURegexSubjectString&quot;</span>;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="comment">// Used internally by rkl_userInfoDictionary to specify which arguments should be set in the NSError userInfo dictionary.</span>
<a name="l00267"></a>00267 <span class="keyword">enum</span> {
<a name="l00268"></a>00268   RKLUserInfoNone                    = 0UL,
<a name="l00269"></a>00269   RKLUserInfoSubjectRange            = 1UL &lt;&lt; 0,
<a name="l00270"></a>00270   RKLUserInfoReplacedCount           = 1UL &lt;&lt; 1,
<a name="l00271"></a>00271   RKLUserInfoRegexEnumerationOptions = 1UL &lt;&lt; 2,
<a name="l00272"></a>00272 };
<a name="l00273"></a>00273 <span class="keyword">typedef</span> NSUInteger RKLUserInfoOptions;
<a name="l00274"></a>00274 
<a name="l00276"></a>00276 <span class="preprocessor">#pragma mark -</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Type / struct definitions</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>
<a name="l00279"></a>00279 <span class="comment">// In general, the ICU bits and pieces here must exactly match the definition in the ICU sources.</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="preprocessor">#define U_STRING_NOT_TERMINATED_WARNING -124</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span><span class="preprocessor">#define U_ZERO_ERROR                       0</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span><span class="preprocessor">#define U_INDEX_OUTOFBOUNDS_ERROR          8</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span><span class="preprocessor">#define U_BUFFER_OVERFLOW_ERROR           15</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor">#define U_PARSE_CONTEXT_LEN               16</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00287"></a>00287 <span class="keyword">typedef</span> <span class="keyword">struct </span>uregex uregex; <span class="comment">// Opaque ICU regex type.</span>
<a name="l00288"></a>00288 
<a name="l00289"></a><a class="code" href="a00030.html">00289</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="a00030.html">UParseError</a> { <span class="comment">// This must be exactly the same as the &#39;real&#39; ICU declaration.</span>
<a name="l00290"></a>00290   int32_t line;
<a name="l00291"></a>00291   int32_t offset;
<a name="l00292"></a>00292   UniChar preContext[U_PARSE_CONTEXT_LEN];
<a name="l00293"></a>00293   UniChar postContext[U_PARSE_CONTEXT_LEN];
<a name="l00294"></a>00294 } <a class="code" href="a00030.html">UParseError</a>;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="comment">// For use with GCC&#39;s cleanup() __attribute__.</span>
<a name="l00297"></a>00297 <span class="keyword">enum</span> {
<a name="l00298"></a>00298   RKLLockedCacheSpinLock   = 1UL &lt;&lt; 0,
<a name="l00299"></a>00299   RKLUnlockedCacheSpinLock = 1UL &lt;&lt; 1,
<a name="l00300"></a>00300 };
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="keyword">enum</span> {
<a name="l00303"></a>00303   RKLSplitOp                         = 1UL,
<a name="l00304"></a>00304   RKLReplaceOp                       = 2UL,
<a name="l00305"></a>00305   RKLRangeOp                         = 3UL,
<a name="l00306"></a>00306   RKLArrayOfStringsOp                = 4UL,
<a name="l00307"></a>00307   RKLArrayOfCapturesOp               = 5UL,
<a name="l00308"></a>00308   RKLCapturesArrayOp                 = 6UL,
<a name="l00309"></a>00309   RKLDictionaryOfCapturesOp          = 7UL,
<a name="l00310"></a>00310   RKLArrayOfDictionariesOfCapturesOp = 8UL,
<a name="l00311"></a>00311   RKLMaskOp                          = 0xFUL,
<a name="l00312"></a>00312   RKLReplaceMutable                  = 1UL &lt;&lt; 4,
<a name="l00313"></a>00313   RKLSubcapturesArray                = 1UL &lt;&lt; 5,
<a name="l00314"></a>00314 };
<a name="l00315"></a>00315 <span class="keyword">typedef</span> NSUInteger RKLRegexOp;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="keyword">enum</span> {
<a name="l00318"></a>00318   RKLBlockEnumerationMatchOp   = 1UL,
<a name="l00319"></a>00319   RKLBlockEnumerationReplaceOp = 2UL,
<a name="l00320"></a>00320 };
<a name="l00321"></a>00321 <span class="keyword">typedef</span> NSUInteger RKLBlockEnumerationOp;
<a name="l00322"></a>00322 
<a name="l00323"></a><a class="code" href="a00029.html">00323</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00324"></a>00324   RKL_STRONG_REF NSRange    * RKL_GC_VOLATILE ranges;
<a name="l00325"></a>00325                  NSRange                      findInRange, remainingRange;
<a name="l00326"></a>00326                  NSInteger                    capacity, found, findUpTo, capture, addedSplitRanges;
<a name="l00327"></a>00327                  <span class="keywordtype">size_t</span>                       size, stackUsed;
<a name="l00328"></a>00328   RKL_STRONG_REF <span class="keywordtype">void</span>      ** RKL_GC_VOLATILE rangesScratchBuffer;
<a name="l00329"></a>00329   RKL_STRONG_REF <span class="keywordtype">void</span>      ** RKL_GC_VOLATILE stringsScratchBuffer;
<a name="l00330"></a>00330   RKL_STRONG_REF <span class="keywordtype">void</span>      ** RKL_GC_VOLATILE arraysScratchBuffer;
<a name="l00331"></a>00331   RKL_STRONG_REF <span class="keywordtype">void</span>      ** RKL_GC_VOLATILE dictionariesScratchBuffer;
<a name="l00332"></a>00332   RKL_STRONG_REF <span class="keywordtype">void</span>      ** RKL_GC_VOLATILE keysScratchBuffer;
<a name="l00333"></a>00333 } <a class="code" href="a00029.html">RKLFindAll</a>;
<a name="l00334"></a>00334 
<a name="l00335"></a><a class="code" href="a00027.html">00335</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00336"></a>00336                  CFStringRef               string;
<a name="l00337"></a>00337                  CFHashCode                hash;
<a name="l00338"></a>00338                  CFIndex                   length;
<a name="l00339"></a>00339   RKL_STRONG_REF UniChar * RKL_GC_VOLATILE uniChar;
<a name="l00340"></a>00340 } <a class="code" href="a00027.html">RKLBuffer</a>;
<a name="l00341"></a>00341 
<a name="l00342"></a><a class="code" href="a00028.html">00342</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00343"></a>00343                  CFStringRef                     regexString;
<a name="l00344"></a>00344                  CFHashCode                      regexHash;
<a name="l00345"></a>00345                  RKLRegexOptions                 options;
<a name="l00346"></a>00346                  uregex                         *icu_regex;
<a name="l00347"></a>00347                  NSInteger                       captureCount;
<a name="l00348"></a>00348   
<a name="l00349"></a>00349                  CFStringRef                     setToString;
<a name="l00350"></a>00350                  CFHashCode                      setToHash;
<a name="l00351"></a>00351                  CFIndex                         setToLength;
<a name="l00352"></a>00352                  NSUInteger                      setToIsImmutable:1;
<a name="l00353"></a>00353                  NSUInteger                      setToNeedsConversion:1;
<a name="l00354"></a>00354   RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE setToUniChar;
<a name="l00355"></a>00355                  NSRange                         setToRange, lastFindRange, lastMatchRange;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357                  <a class="code" href="a00027.html">RKLBuffer</a>                      *buffer;
<a name="l00358"></a>00358 } <a class="code" href="a00028.html">RKLCachedRegex</a>;
<a name="l00359"></a>00359 
<a name="l00361"></a>00361 <span class="preprocessor">#pragma mark -</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Translation unit scope global variables</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>
<a name="l00364"></a>00364 <span class="keyword">static</span> RKLLRUCacheSet_t     rkl_lruFixedBufferCacheSet = _RKL_LRU_CACHE_SET_INIT, rkl_lruDynamicBufferCacheSet = _RKL_LRU_CACHE_SET_INIT;
<a name="l00365"></a>00365 <span class="keyword">static</span> <a class="code" href="a00027.html">RKLBuffer</a>            rkl_lruDynamicBuffer[_RKL_LRU_CACHE_SET_WAYS];
<a name="l00366"></a>00366 <span class="keyword">static</span> UniChar              rkl_lruFixedUniChar[_RKL_LRU_CACHE_SET_WAYS][_RKL_FIXED_LENGTH]; <span class="comment">// This is the fixed sized UTF-16 conversion buffer.</span>
<a name="l00367"></a>00367 <span class="keyword">static</span> <a class="code" href="a00027.html">RKLBuffer</a>            rkl_lruFixedBuffer[_RKL_LRU_CACHE_SET_WAYS] = {{NULL, 0UL, 0L, &amp;rkl_lruFixedUniChar[0][0]}, {NULL, 0UL, 0L, &amp;rkl_lruFixedUniChar[1][0]}, {NULL, 0UL, 0L, &amp;rkl_lruFixedUniChar[2][0]}, {NULL, 0UL, 0L, &amp;rkl_lruFixedUniChar[3][0]}};
<a name="l00368"></a>00368 <span class="keyword">static</span> <a class="code" href="a00028.html">RKLCachedRegex</a>       rkl_cachedRegexes[_RKL_REGEX_CACHE_LINES];
<a name="l00369"></a>00369 <span class="preprocessor">#if       defined(__GNUC__) &amp;&amp; (__GNUC__ == 4) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; (__GNUC_MINOR__ == 2)</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="a00028.html">RKLCachedRegex</a> * <span class="keyword">volatile</span> rkl_lastCachedRegex; <span class="comment">// XXX This is a work around for what appears to be a optimizer code generation bug in GCC 4.2.</span>
<a name="l00371"></a>00371 <span class="preprocessor">#else</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_lastCachedRegex;
<a name="l00373"></a>00373 <span class="preprocessor">#endif // defined(__GNUC__) &amp;&amp; (__GNUC__ == 4) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; (__GNUC_MINOR__ == 2)</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span><span class="keyword">static</span> RKLLRUCacheSet_t     rkl_cachedRegexCacheSets[_RKL_REGEX_LRU_CACHE_SETS] = { [0 ... (_RKL_REGEX_LRU_CACHE_SETS - 1UL)] = _RKL_LRU_CACHE_SET_INIT };
<a name="l00375"></a>00375 <span class="keyword">static</span> RKLLookasideCache_t  rkl_regexLookasideCache[_RKL_REGEX_LOOKASIDE_CACHE_SIZE] RKL_ALIGNED(64);
<a name="l00376"></a>00376 <span class="keyword">static</span> OSSpinLock           rkl_cacheSpinLock = OS_SPINLOCK_INIT;
<a name="l00377"></a>00377 <span class="keyword">static</span> <span class="keyword">const</span> UniChar        rkl_emptyUniCharString[1];                                <span class="comment">// For safety, icu_regexes are &#39;set&#39; to this when the string they were searched is cleared.</span>
<a name="l00378"></a>00378 <span class="keyword">static</span> RKL_STRONG_REF <span class="keywordtype">void</span> * RKL_GC_VOLATILE rkl_scratchBuffer[_RKL_SCRATCH_BUFFERS]; <span class="comment">// Used to hold temporary allocations that are allocated via reallocf().</span>
<a name="l00379"></a>00379 
<a name="l00381"></a>00381 <span class="preprocessor">#pragma mark -</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span><span class="preprocessor">#pragma mark CFArray and CFDictionary call backs</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>
<a name="l00384"></a>00384 <span class="comment">// These are used when running under manual memory management for the array that rkl_splitArray creates.</span>
<a name="l00385"></a>00385 <span class="comment">// The split strings are created, but not autoreleased.  The (immutable) array is created using these callbacks, which skips the CFRetain() call, effectively transferring ownership to the CFArray object.</span>
<a name="l00386"></a>00386 <span class="comment">// For each split string this saves the overhead of an autorelease, then an array retain, then an NSAutoreleasePool release. This is good for a ~30% speed increase.</span>
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="keyword">static</span> <span class="keywordtype">void</span>  rkl_CFCallbackRelease(CFAllocatorRef allocator RKL_UNUSED_ARG, <span class="keyword">const</span> <span class="keywordtype">void</span> *ptr) { CFRelease((CFTypeRef)ptr);                                                   }
<a name="l00389"></a>00389 <span class="keyword">static</span> <span class="keyword">const</span> CFArrayCallBacks           rkl_transferOwnershipArrayCallBacks           =      { (CFIndex)0L, NULL, rkl_CFCallbackRelease, CFCopyDescription, CFEqual         };
<a name="l00390"></a>00390 <span class="keyword">static</span> <span class="keyword">const</span> CFDictionaryKeyCallBacks   rkl_transferOwnershipDictionaryKeyCallBacks   =      { (CFIndex)0L, NULL, rkl_CFCallbackRelease, CFCopyDescription, CFEqual, CFHash };
<a name="l00391"></a>00391 <span class="keyword">static</span> <span class="keyword">const</span> CFDictionaryValueCallBacks rkl_transferOwnershipDictionaryValueCallBacks =      { (CFIndex)0L, NULL, rkl_CFCallbackRelease, CFCopyDescription, CFEqual         };
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="preprocessor">#ifdef    __OBJC_GC__</span>
<a name="l00394"></a>00394 <span class="preprocessor"></span>
<a name="l00395"></a>00395 <span class="preprocessor">#pragma mark -</span>
<a name="l00396"></a>00396 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Low-level Garbage Collection aware memory/resource allocation utilities</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span><span class="comment">// If compiled with Garbage Collection, we need to be able to do a few things slightly differently.</span>
<a name="l00398"></a>00398 <span class="comment">// The basic premiss is that under GC we use a trampoline function pointer which is set to a _start function to catch the first invocation.</span>
<a name="l00399"></a>00399 <span class="comment">// The _start function checks if GC is running and then overwrites the function pointer with the appropriate routine.  Think of it as &#39;lazy linking&#39;.</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="keyword">enum</span> { RKLScannedOption = NSScannedOption };
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="comment">// rkl_collectingEnabled uses objc_getClass() to get the NSGarbageCollector class, which doesn&#39;t exist on earlier systems.</span>
<a name="l00404"></a>00404 <span class="comment">// This allows for graceful failure should we find ourselves running on an earlier version of the OS without NSGarbageCollector.</span>
<a name="l00405"></a>00405 <span class="keyword">static</span> BOOL  rkl_collectingEnabled_first (<span class="keywordtype">void</span>);
<a name="l00406"></a>00406 <span class="keyword">static</span> BOOL  rkl_collectingEnabled_yes   (<span class="keywordtype">void</span>) { <span class="keywordflow">return</span>(YES); }
<a name="l00407"></a>00407 <span class="keyword">static</span> BOOL  rkl_collectingEnabled_no    (<span class="keywordtype">void</span>) { <span class="keywordflow">return</span>(NO);  }
<a name="l00408"></a>00408 <span class="keyword">static</span> BOOL(*rkl_collectingEnabled)      (void) = rkl_collectingEnabled_first;
<a name="l00409"></a>00409 <span class="keyword">static</span> BOOL  rkl_collectingEnabled_first (<span class="keywordtype">void</span>) {
<a name="l00410"></a>00410   BOOL gcEnabled = ([objc_getClass(&quot;NSGarbageCollector&quot;) defaultCollector] != NULL) ? YES : NO;
<a name="l00411"></a>00411   <span class="keywordflow">if</span>(gcEnabled == YES) {
<a name="l00412"></a>00412     <span class="comment">// This section of code is required due to what I consider to be a fundamental design flaw in Cocoas GC system.</span>
<a name="l00413"></a>00413     <span class="comment">// Earlier versions of &quot;Garbage Collection Programming Guide&quot; stated that (paraphrased) &quot;all globals are automatically roots&quot;.</span>
<a name="l00414"></a>00414     <span class="comment">// Current versions of the guide now include the following warning:</span>
<a name="l00415"></a>00415     <span class="comment">//    &quot;You may pass addresses of strong globals or statics into routines expecting pointers to object pointers (such as id* or NSError**)</span>
<a name="l00416"></a>00416     <span class="comment">//     only if they have first been assigned to directly, rather than through a pointer dereference.&quot;</span>
<a name="l00417"></a>00417     <span class="comment">// This is a surprisingly non-trivial condition to actually meet in practice and is a recipe for impossible to debug race condition bugs.</span>
<a name="l00418"></a>00418     <span class="comment">// We just happen to be very, very, very lucky in the fact that we can initialize our root set before the first use.</span>
<a name="l00419"></a>00419     NSUInteger x = 0UL;
<a name="l00420"></a>00420     <span class="keywordflow">for</span>(x = 0UL; x &lt; _RKL_SCRATCH_BUFFERS; x++)    { rkl_scratchBuffer[x]            = NSAllocateCollectable(16UL, 0UL); rkl_scratchBuffer[x]            = NULL; }
<a name="l00421"></a>00421     <span class="keywordflow">for</span>(x = 0UL; x &lt; _RKL_LRU_CACHE_SET_WAYS; x++) { rkl_lruDynamicBuffer[x].uniChar = NSAllocateCollectable(16UL, 0UL); rkl_lruDynamicBuffer[x].uniChar = NULL; }
<a name="l00422"></a>00422   }
<a name="l00423"></a>00423   <span class="keywordflow">return</span>((rkl_collectingEnabled = (gcEnabled == YES) ? rkl_collectingEnabled_yes : rkl_collectingEnabled_no)());
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">// rkl_realloc()</span>
<a name="l00427"></a>00427 <span class="keyword">static</span> <span class="keywordtype">void</span>   *rkl_realloc_first (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags);
<a name="l00428"></a>00428 <span class="keyword">static</span> <span class="keywordtype">void</span>   *rkl_realloc_std   (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags RKL_UNUSED_ARG) { <span class="keywordflow">return</span>((*ptr = reallocf(*ptr, size))); }
<a name="l00429"></a>00429 <span class="keyword">static</span> <span class="keywordtype">void</span>   *rkl_realloc_gc    (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags)                { <span class="keywordflow">return</span>((*ptr = NSReallocateCollectable(*ptr, (NSUInteger)size, flags))); }
<a name="l00430"></a>00430 <span class="keyword">static</span> <span class="keywordtype">void</span> *(*rkl_realloc)      (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags) RKL_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(2,1) = rkl_realloc_first;
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keywordtype">void</span>   *rkl_realloc_first (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags)                { <span class="keywordflow">if</span>(rkl_collectingEnabled()==YES) { rkl_realloc = rkl_realloc_gc; } <span class="keywordflow">else</span> { rkl_realloc = rkl_realloc_std; } <span class="keywordflow">return</span>(rkl_realloc(ptr, size, flags)); }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="comment">// rkl_free()</span>
<a name="l00434"></a>00434 <span class="keyword">static</span> <span class="keywordtype">void</span> *  rkl_free_first (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr);
<a name="l00435"></a>00435 <span class="keyword">static</span> <span class="keywordtype">void</span> *  rkl_free_std   (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr) { <span class="keywordflow">if</span>(*ptr != NULL) { free(*ptr); *ptr = NULL; } <span class="keywordflow">return</span>(NULL); }
<a name="l00436"></a>00436 <span class="keyword">static</span> <span class="keywordtype">void</span> *  rkl_free_gc    (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr) { <span class="keywordflow">if</span>(*ptr != NULL) {             *ptr = NULL; } <span class="keywordflow">return</span>(NULL); }
<a name="l00437"></a>00437 <span class="keyword">static</span> <span class="keywordtype">void</span> *(*rkl_free)      (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr) RKL_NONNULL_ARGS(1) = rkl_free_first;
<a name="l00438"></a>00438 <span class="keyword">static</span> <span class="keywordtype">void</span>   *rkl_free_first (RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ptr) { <span class="keywordflow">if</span>(rkl_collectingEnabled()==YES) { rkl_free = rkl_free_gc; } <span class="keywordflow">else</span> { rkl_free = rkl_free_std; } <span class="keywordflow">return</span>(rkl_free(ptr)); }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="comment">// rkl_CFAutorelease()</span>
<a name="l00441"></a>00441 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CFAutorelease_first (CFTypeRef obj);
<a name="l00442"></a>00442 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CFAutorelease_std   (CFTypeRef obj) { <span class="keywordflow">return</span>([(<span class="keywordtype">id</span>)obj autorelease]);  }
<a name="l00443"></a>00443 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CFAutorelease_gc    (CFTypeRef obj) { <span class="keywordflow">return</span>(NSMakeCollectable(obj)); }
<a name="l00444"></a>00444 <span class="keyword">static</span> id(*rkl_CFAutorelease)      (CFTypeRef obj) = rkl_CFAutorelease_first;
<a name="l00445"></a>00445 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CFAutorelease_first (CFTypeRef obj) { <span class="keywordflow">return</span>((rkl_CFAutorelease = (rkl_collectingEnabled()==YES) ? rkl_CFAutorelease_gc : rkl_CFAutorelease_std)(obj)); }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="comment">// rkl_CreateStringWithSubstring()</span>
<a name="l00448"></a>00448 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateStringWithSubstring_first (<span class="keywordtype">id</span> <span class="keywordtype">string</span>, NSRange range);
<a name="l00449"></a>00449 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateStringWithSubstring_std   (<span class="keywordtype">id</span> <span class="keywordtype">string</span>, NSRange range) { <span class="keywordflow">return</span>((<span class="keywordtype">id</span>)CFStringCreateWithSubstring(NULL, (CFStringRef)<span class="keywordtype">string</span>, CFMakeRange((CFIndex)range.location, (CFIndex)range.length))); }
<a name="l00450"></a>00450 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateStringWithSubstring_gc    (<span class="keywordtype">id</span> <span class="keywordtype">string</span>, NSRange range) { <span class="keywordflow">return</span>([<span class="keywordtype">string</span> substringWithRange:range]); }
<a name="l00451"></a>00451 <span class="keyword">static</span> id(*rkl_CreateStringWithSubstring)      (<span class="keywordtype">id</span> string, NSRange range) RKL_WARN_UNUSED_NONNULL_ARGS(1) = rkl_CreateStringWithSubstring_first;
<a name="l00452"></a>00452 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateStringWithSubstring_first (<span class="keywordtype">id</span> <span class="keywordtype">string</span>, NSRange range) { <span class="keywordflow">return</span>((rkl_CreateStringWithSubstring = (rkl_collectingEnabled()==YES) ? rkl_CreateStringWithSubstring_gc : rkl_CreateStringWithSubstring_std)(<span class="keywordtype">string</span>, range)); }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">// rkl_ReleaseObject()</span>
<a name="l00455"></a>00455 <span class="keyword">static</span> <span class="keywordtype">id</span>   rkl_ReleaseObject_first (<span class="keywordtype">id</span> obj);
<a name="l00456"></a>00456 <span class="keyword">static</span> <span class="keywordtype">id</span>   rkl_ReleaseObject_std   (<span class="keywordtype">id</span> obj)                { CFRelease((CFTypeRef)obj); <span class="keywordflow">return</span>(NULL); }
<a name="l00457"></a>00457 <span class="keyword">static</span> <span class="keywordtype">id</span>   rkl_ReleaseObject_gc    (<span class="keywordtype">id</span> obj RKL_UNUSED_ARG) {                            <span class="keywordflow">return</span>(NULL); }
<a name="l00458"></a>00458 <span class="keyword">static</span> id (*rkl_ReleaseObject)      (<span class="keywordtype">id</span> obj) RKL_NONNULL_ARGS(1) = rkl_ReleaseObject_first;
<a name="l00459"></a>00459 <span class="keyword">static</span> <span class="keywordtype">id</span>   rkl_ReleaseObject_first (<span class="keywordtype">id</span> obj)                { <span class="keywordflow">return</span>((rkl_ReleaseObject = (rkl_collectingEnabled()==YES) ? rkl_ReleaseObject_gc : rkl_ReleaseObject_std)(obj)); }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 <span class="comment">// rkl_CreateArrayWithObjects()</span>
<a name="l00462"></a>00462 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateArrayWithObjects_first (<span class="keywordtype">void</span> **objects, NSUInteger count);
<a name="l00463"></a>00463 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateArrayWithObjects_std   (<span class="keywordtype">void</span> **objects, NSUInteger count) { <span class="keywordflow">return</span>((<span class="keywordtype">id</span>)CFArrayCreate(NULL, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)objects, (CFIndex)count, &amp;rkl_transferOwnershipArrayCallBacks)); }
<a name="l00464"></a>00464 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateArrayWithObjects_gc    (<span class="keywordtype">void</span> **objects, NSUInteger count) { <span class="keywordflow">return</span>([NSArray arrayWithObjects:(<span class="keyword">const</span> <span class="keywordtype">id</span> *)objects count:count]); }
<a name="l00465"></a>00465 <span class="keyword">static</span> id(*rkl_CreateArrayWithObjects)      (<span class="keywordtype">void</span> **objects, NSUInteger count) RKL_WARN_UNUSED_NONNULL_ARGS(1) = rkl_CreateArrayWithObjects_first;
<a name="l00466"></a>00466 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateArrayWithObjects_first (<span class="keywordtype">void</span> **objects, NSUInteger count) { <span class="keywordflow">return</span>((rkl_CreateArrayWithObjects = (rkl_collectingEnabled()==YES) ? rkl_CreateArrayWithObjects_gc : rkl_CreateArrayWithObjects_std)(objects, count)); }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="comment">// rkl_CreateAutoreleasedArray()</span>
<a name="l00469"></a>00469 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateAutoreleasedArray_first (<span class="keywordtype">void</span> **objects, NSUInteger count);
<a name="l00470"></a>00470 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateAutoreleasedArray_std   (<span class="keywordtype">void</span> **objects, NSUInteger count) { <span class="keywordflow">return</span>((<span class="keywordtype">id</span>)rkl_CFAutorelease(rkl_CreateArrayWithObjects(objects, count))); }
<a name="l00471"></a>00471 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateAutoreleasedArray_gc    (<span class="keywordtype">void</span> **objects, NSUInteger count) { <span class="keywordflow">return</span>(                      rkl_CreateArrayWithObjects(objects, count) ); }
<a name="l00472"></a>00472 <span class="keyword">static</span> id(*rkl_CreateAutoreleasedArray)      (<span class="keywordtype">void</span> **objects, NSUInteger count) RKL_WARN_UNUSED_NONNULL_ARGS(1) = rkl_CreateAutoreleasedArray_first;
<a name="l00473"></a>00473 <span class="keyword">static</span> <span class="keywordtype">id</span>  rkl_CreateAutoreleasedArray_first (<span class="keywordtype">void</span> **objects, NSUInteger count) { <span class="keywordflow">return</span>((rkl_CreateAutoreleasedArray = (rkl_collectingEnabled()==YES) ? rkl_CreateAutoreleasedArray_gc : rkl_CreateAutoreleasedArray_std)(objects, count)); }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="preprocessor">#else  // __OBJC_GC__ not defined</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span>
<a name="l00477"></a>00477 <span class="preprocessor">#pragma mark -</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Low-level explicit memory/resource allocation utilities</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>
<a name="l00480"></a>00480 <span class="keyword">enum</span> { RKLScannedOption = 0 };
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="preprocessor">#define rkl_collectingEnabled() (NO)</span>
<a name="l00483"></a>00483 <span class="preprocessor"></span>
<a name="l00484"></a>00484 RKL_STATIC_INLINE <span class="keywordtype">void</span> *rkl_realloc                   (<span class="keywordtype">void</span> **ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags) RKL_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(2,1);
<a name="l00485"></a>00485 RKL_STATIC_INLINE <span class="keywordtype">void</span> *rkl_free                      (<span class="keywordtype">void</span> **ptr)                                RKL_NONNULL_ARGS(1);
<a name="l00486"></a>00486 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CFAutorelease             (CFTypeRef obj)                             RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00487"></a>00487 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CreateAutoreleasedArray   (<span class="keywordtype">void</span> **objects, NSUInteger count)          RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00488"></a>00488 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CreateArrayWithObjects    (<span class="keywordtype">void</span> **objects, NSUInteger count)          RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00489"></a>00489 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CreateStringWithSubstring (<span class="keywordtype">id</span> <span class="keywordtype">string</span>, NSRange range)                  RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00490"></a>00490 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_ReleaseObject             (<span class="keywordtype">id</span> obj)                                    RKL_NONNULL_ARGS(1);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 RKL_STATIC_INLINE <span class="keywordtype">void</span> *rkl_realloc                   (<span class="keywordtype">void</span> **ptr, <span class="keywordtype">size_t</span> size, NSUInteger flags RKL_UNUSED_ARG) { <span class="keywordflow">return</span>((*ptr = reallocf(*ptr, size))); }
<a name="l00493"></a>00493 RKL_STATIC_INLINE <span class="keywordtype">void</span> *rkl_free                      (<span class="keywordtype">void</span> **ptr)                                               { <span class="keywordflow">if</span>(*ptr != NULL) { free(*ptr); *ptr = NULL; } <span class="keywordflow">return</span>(NULL); }
<a name="l00494"></a>00494 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CFAutorelease             (CFTypeRef obj)                                            { <span class="keywordflow">return</span>([(<span class="keywordtype">id</span>)obj autorelease]); }
<a name="l00495"></a>00495 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CreateArrayWithObjects    (<span class="keywordtype">void</span> **objects, NSUInteger count)                         { <span class="keywordflow">return</span>((<span class="keywordtype">id</span>)CFArrayCreate(NULL, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)objects, (CFIndex)count, &amp;rkl_transferOwnershipArrayCallBacks)); }
<a name="l00496"></a>00496 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CreateAutoreleasedArray   (<span class="keywordtype">void</span> **objects, NSUInteger count)                         { <span class="keywordflow">return</span>(rkl_CFAutorelease(rkl_CreateArrayWithObjects(objects, count))); }
<a name="l00497"></a>00497 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_CreateStringWithSubstring (<span class="keywordtype">id</span> <span class="keywordtype">string</span>, NSRange range)                                 { <span class="keywordflow">return</span>((<span class="keywordtype">id</span>)CFStringCreateWithSubstring(NULL, (CFStringRef)<span class="keywordtype">string</span>, CFMakeRange((CFIndex)range.location, (CFIndex)range.length))); }
<a name="l00498"></a>00498 RKL_STATIC_INLINE <span class="keywordtype">id</span>    rkl_ReleaseObject             (<span class="keywordtype">id</span> obj)                                                   { CFRelease((CFTypeRef)obj); <span class="keywordflow">return</span>(NULL); }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="preprocessor">#endif // __OBJC_GC__</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span>
<a name="l00503"></a>00503 <span class="preprocessor">#pragma mark -</span>
<a name="l00504"></a>00504 <span class="preprocessor"></span><span class="preprocessor">#pragma mark ICU function prototypes</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span>
<a name="l00506"></a>00506 <span class="comment">// ICU functions.  See http://www.icu-project.org/apiref/icu4c/uregex_8h.html Tweaked slightly from the originals, but functionally identical.</span>
<a name="l00507"></a>00507 <span class="keyword">const</span> <span class="keywordtype">char</span> *RKL_ICU_FUNCTION_APPEND(u_errorName)              (                                                                                                                             int32_t  status) RKL_WARN_UNUSED_PURE;
<a name="l00508"></a>00508 int32_t     RKL_ICU_FUNCTION_APPEND(u_strlen)                 (<span class="keyword">const</span> UniChar *s)                                                                                                                             RKL_WARN_UNUSED_PURE_NONNULL_ARGS(1);
<a name="l00509"></a>00509 int32_t     RKL_ICU_FUNCTION_APPEND(uregex_appendReplacement) (      uregex  *regexp,  <span class="keyword">const</span> UniChar *replacementText, int32_t replacementLength, UniChar **destBuf, int32_t *destCapacity, int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2,4,5,6);
<a name="l00510"></a>00510 int32_t     RKL_ICU_FUNCTION_APPEND(uregex_appendTail)        (      uregex  *regexp,                                                             UniChar **destBuf, int32_t *destCapacity, int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2,3,4);
<a name="l00511"></a>00511 <span class="keywordtype">void</span>        RKL_ICU_FUNCTION_APPEND(uregex_close)             (      uregex  *regexp)                                                                                                                        RKL_NONNULL_ARGS(1);
<a name="l00512"></a>00512 int32_t     RKL_ICU_FUNCTION_APPEND(uregex_end)               (      uregex  *regexp,  int32_t groupNum,                                                                                    int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,3);
<a name="l00513"></a>00513 BOOL        RKL_ICU_FUNCTION_APPEND(uregex_find)              (      uregex  *regexp,  int32_t location,                                                                                    int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,3);
<a name="l00514"></a>00514 BOOL        RKL_ICU_FUNCTION_APPEND(uregex_findNext)          (      uregex  *regexp,                                                                                                       int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2);
<a name="l00515"></a>00515 int32_t     RKL_ICU_FUNCTION_APPEND(uregex_groupCount)        (      uregex  *regexp,                                                                                                       int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2);
<a name="l00516"></a>00516 uregex     *RKL_ICU_FUNCTION_APPEND(uregex_open)              (<span class="keyword">const</span> UniChar *pattern, int32_t patternLength, RKLRegexOptions flags, <a class="code" href="a00030.html">UParseError</a> *parseError,                               int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,4,5);
<a name="l00517"></a>00517 <span class="keywordtype">void</span>        RKL_ICU_FUNCTION_APPEND(uregex_reset)             (      uregex  *regexp,  int32_t newIndex,                                                                                    int32_t *status) RKL_NONNULL_ARGS(1,3);
<a name="l00518"></a>00518 <span class="keywordtype">void</span>        RKL_ICU_FUNCTION_APPEND(uregex_setText)           (      uregex  *regexp,  <span class="keyword">const</span> UniChar *text, int32_t textLength,                                                             int32_t *status) RKL_NONNULL_ARGS(1,2,4);
<a name="l00519"></a>00519 int32_t     RKL_ICU_FUNCTION_APPEND(uregex_start)             (      uregex  *regexp,  int32_t groupNum,                                                                                    int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,3);
<a name="l00520"></a>00520 uregex     *RKL_ICU_FUNCTION_APPEND(uregex_clone)             (<span class="keyword">const</span> uregex  *regexp,                                                                                                       int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2);
<a name="l00521"></a>00521 
<a name="l00523"></a>00523 <span class="preprocessor">#pragma mark -</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span><span class="preprocessor">#pragma mark RegexKitLite internal, private function prototypes</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span>
<a name="l00526"></a>00526 <span class="comment">// Functions used for managing the 4-way set associative LRU cache and regex string hash lookaside cache.</span>
<a name="l00527"></a>00527 RKL_STATIC_INLINE NSUInteger      rkl_leastRecentlyUsedWayInSet                          (      NSUInteger      cacheSetsCount, <span class="keyword">const</span> RKLLRUCacheSet_t cacheSetsArray[cacheSetsCount], NSUInteger <span class="keyword">set</span>)                  RKL_WARN_UNUSED_NONNULL_ARGS(2);
<a name="l00528"></a>00528 RKL_STATIC_INLINE <span class="keywordtype">void</span>            rkl_accessCacheSetWay                                  (      NSUInteger      cacheSetsCount,       RKLLRUCacheSet_t cacheSetsArray[cacheSetsCount], NSUInteger set, NSUInteger way)  RKL_NONNULL_ARGS(2);
<a name="l00529"></a>00529 RKL_STATIC_INLINE NSUInteger      rkl_regexLookasideCacheIndexForPointerAndOptions       (const <span class="keywordtype">void</span>           *ptr,         RKLRegexOptions options)                                                                   RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00530"></a>00530 RKL_STATIC_INLINE <span class="keywordtype">void</span>            rkl_setRegexLookasideCacheToCachedRegexForPointer      (const <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, const <span class="keywordtype">void</span> *ptr)                                                                           RKL_NONNULL_ARGS(1,2);
<a name="l00531"></a>00531 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_cachedRegexFromRegexLookasideCacheForString        (const <span class="keywordtype">void</span>           *ptr,         RKLRegexOptions options)                                                                   RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00532"></a>00532 RKL_STATIC_INLINE NSUInteger      rkl_makeCacheSetHash                                   (      CFHashCode      regexHash,   RKLRegexOptions options)                                                                   RKL_WARN_UNUSED;
<a name="l00533"></a>00533 RKL_STATIC_INLINE NSUInteger      rkl_cacheSetForRegexHashAndOptions                     (      CFHashCode      regexHash,   RKLRegexOptions options)                                                                   RKL_WARN_UNUSED;
<a name="l00534"></a>00534 RKL_STATIC_INLINE NSUInteger      rkl_cacheWayForCachedRegex                             (const <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex)                                                                                            RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00535"></a>00535 RKL_STATIC_INLINE NSUInteger      rkl_cacheSetForCachedRegex                             (const <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex)                                                                                            RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00536"></a>00536 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_cachedRegexForCacheSetAndWay                       (      NSUInteger      cacheSet,    NSUInteger      cacheWay)                                                                  RKL_WARN_UNUSED;
<a name="l00537"></a>00537 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_cachedRegexForRegexHashAndOptionsAndWay            (      CFHashCode      regexHash,   RKLRegexOptions options, NSUInteger cacheWay)                                              RKL_WARN_UNUSED;
<a name="l00538"></a>00538 RKL_STATIC_INLINE <span class="keywordtype">void</span>            rkl_updateCachesWithCachedRegex                        (      <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, const <span class="keywordtype">void</span> *ptr, <span class="keywordtype">int</span> hitOrMiss RKL_UNUSED_DTRACE_ARG, <span class="keywordtype">int</span> status RKL_UNUSED_DTRACE_ARG)    RKL_NONNULL_ARGS(1,2);
<a name="l00539"></a>00539 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_leastRecentlyUsedCachedRegexForRegexHashAndOptions (      CFHashCode      regexHash,   RKLRegexOptions options)                                                                   RKL_WARN_UNUSED;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 static <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_getCachedRegex            (<a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, NSError **error, <span class="keywordtype">id</span> *exception)                                                                                                                            RKL_WARN_UNUSED_NONNULL_ARGS(1,4);
<a name="l00542"></a>00542 static NSUInteger      rkl_setCachedRegexToString    (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, const NSRange *range, int32_t *status, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG)                                                                                                    RKL_WARN_UNUSED_NONNULL_ARGS(1,2,3,4);
<a name="l00543"></a>00543 static <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_getCachedRegexSetToString (<a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, <a class="code" href="a00025.html">NSString</a> *matchString, NSUInteger *matchLengthPtr, NSRange *matchRange, NSError **error, <span class="keywordtype">id</span> *exception, int32_t *status)                                   RKL_WARN_UNUSED_NONNULL_ARGS(1,3,4,5,7,8);
<a name="l00544"></a>00544 static <span class="keywordtype">id</span>              rkl_performDictionaryVarArgsOp(<span class="keywordtype">id</span> self, <span class="keywordtype">SEL</span> _cmd, RKLRegexOp regexOp, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, NSInteger capture, <span class="keywordtype">id</span> matchString, NSRange *matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, NSError **error, <span class="keywordtype">void</span> *result, <span class="keywordtype">id</span> firstKey, va_list varArgsList) RKL_NONNULL_ARGS(1,2);
<a name="l00545"></a>00545 static <span class="keywordtype">id</span>              rkl_performRegexOp            (<span class="keywordtype">id</span> self, <span class="keywordtype">SEL</span> _cmd, RKLRegexOp regexOp, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, NSInteger capture, <span class="keywordtype">id</span> matchString, NSRange *matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, NSError **error, <span class="keywordtype">void</span> *result, NSUInteger captureKeysCount, <span class="keywordtype">id</span> captureKeys[captureKeysCount], const <span class="keywordtype">int</span> captureKeyIndexes[captureKeysCount]) RKL_NONNULL_ARGS(1,2);
<a name="l00546"></a>00546 static <span class="keywordtype">void</span>            rkl_handleDelayedAssert       (<span class="keywordtype">id</span> self, <span class="keywordtype">SEL</span> _cmd, <span class="keywordtype">id</span> exception)                                                                                                                                                                           RKL_NONNULL_ARGS(3);
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 static NSUInteger      rkl_search                    (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, NSRange *searchRange, NSUInteger updateSearchRange, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG, int32_t *status)                        RKL_WARN_UNUSED_NONNULL_ARGS(1,2,4,5);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 static BOOL            rkl_findRanges                (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKLRegexOp regexOp,      <a class="code" href="a00029.html">RKLFindAll</a> *findAll, <span class="keywordtype">id</span> *exception, int32_t *status)                                                       RKL_WARN_UNUSED_NONNULL_ARGS(1,3,4,5);
<a name="l00551"></a>00551 static NSUInteger      rkl_growFindRanges            (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, NSUInteger lastLocation, <a class="code" href="a00029.html">RKLFindAll</a> *findAll, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG)                                               RKL_WARN_UNUSED_NONNULL_ARGS(1,3,4);
<a name="l00552"></a>00552 static NSArray        *rkl_makeArray                 (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKLRegexOp regexOp,      <a class="code" href="a00029.html">RKLFindAll</a> *findAll, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG)                                               RKL_WARN_UNUSED_NONNULL_ARGS(1,3,4);
<a name="l00553"></a>00553 static <span class="keywordtype">id</span>              rkl_makeDictionary            (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKLRegexOp regexOp,      <a class="code" href="a00029.html">RKLFindAll</a> *findAll, NSUInteger captureKeysCount, <span class="keywordtype">id</span> captureKeys[captureKeysCount], const <span class="keywordtype">int</span> captureKeyIndexes[captureKeysCount], <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG) RKL_WARN_UNUSED_NONNULL_ARGS(1,3,5,6);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 static <a class="code" href="a00025.html">NSString</a>       *rkl_replaceString             (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, <span class="keywordtype">id</span> searchString, NSUInteger searchU16Length, <a class="code" href="a00025.html">NSString</a> *replacementString, NSUInteger replacementU16Length, NSInteger *replacedCount, NSUInteger replaceMutable, <span class="keywordtype">id</span> *exception, int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2,4,8,9);
<a name="l00556"></a>00556 static int32_t         rkl_replaceAll                (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKL_STRONG_REF const UniChar * RKL_GC_VOLATILE replacementUniChar, int32_t replacementU16Length, UniChar *replacedUniChar, int32_t replacedU16Capacity, NSInteger *replacedCount, int32_t *needU16Capacity, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG, int32_t *status) RKL_WARN_UNUSED_NONNULL_ARGS(1,2,4,6,7,8,9);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558 static NSUInteger      rkl_isRegexValid              (<span class="keywordtype">id</span> self, <span class="keywordtype">SEL</span> _cmd, <a class="code" href="a00025.html">NSString</a> *regex, RKLRegexOptions options, NSInteger *captureCountPtr, NSError **error) RKL_NONNULL_ARGS(1,2);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 static <span class="keywordtype">void</span>            rkl_clearStringCache          (<span class="keywordtype">void</span>);
<a name="l00561"></a>00561 static <span class="keywordtype">void</span>            rkl_clearBuffer               (<a class="code" href="a00027.html">RKLBuffer</a> *buffer, NSUInteger freeDynamicBuffer) RKL_NONNULL_ARGS(1);
<a name="l00562"></a>00562 static <span class="keywordtype">void</span>            rkl_clearCachedRegex          (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex)                     RKL_NONNULL_ARGS(1);
<a name="l00563"></a>00563 static <span class="keywordtype">void</span>            rkl_clearCachedRegexSetTo     (<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex)                     RKL_NONNULL_ARGS(1);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 static NSDictionary   *rkl_userInfoDictionary        (RKLUserInfoOptions userInfoOptions, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, const <a class="code" href="a00030.html">UParseError</a> *parseError, int32_t status, <a class="code" href="a00025.html">NSString</a> *matchString, NSRange matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, <a class="code" href="a00025.html">NSString</a> *replacedString, NSInteger replacedCount, RKLRegexEnumerationOptions enumerationOptions, ...)                        RKL_WARN_UNUSED_SENTINEL;
<a name="l00566"></a>00566 static NSError        *rkl_makeNSError               (RKLUserInfoOptions userInfoOptions, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, const <a class="code" href="a00030.html">UParseError</a> *parseError, int32_t status, <a class="code" href="a00025.html">NSString</a> *matchString, NSRange matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, <a class="code" href="a00025.html">NSString</a> *replacedString, NSInteger replacedCount, RKLRegexEnumerationOptions enumerationOptions, <a class="code" href="a00025.html">NSString</a> *errorDescription) RKL_WARN_UNUSED;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 static NSException    *rkl_NSExceptionForRegex       (<a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, const <a class="code" href="a00030.html">UParseError</a> *parseError, int32_t status) RKL_WARN_UNUSED_NONNULL_ARGS(1);
<a name="l00569"></a>00569 static NSDictionary   *rkl_makeAssertDictionary      (const <span class="keywordtype">char</span> *function, const <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <a class="code" href="a00025.html">NSString</a> *format, ...)                       RKL_WARN_UNUSED_NONNULL_ARGS(1,2,4);
<a name="l00570"></a>00570 static <a class="code" href="a00025.html">NSString</a>       *rkl_stringFromClassAndMethod  (<span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keywordtype">SEL</span> selector, <a class="code" href="a00025.html">NSString</a> *format, ...)                                                RKL_WARN_UNUSED_NONNULL_ARGS(3);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 RKL_STATIC_INLINE int32_t rkl_getRangeForCapture(<a class="code" href="a00028.html">RKLCachedRegex</a> *cr, int32_t *s, int32_t c, NSRange *r) RKL_WARN_UNUSED_NONNULL_ARGS(1,2,4);
<a name="l00573"></a>00573 RKL_STATIC_INLINE int32_t rkl_getRangeForCapture(<a class="code" href="a00028.html">RKLCachedRegex</a> *cr, int32_t *s, int32_t c, NSRange *r) { uregex *re = cr-&gt;icu_regex; int32_t start = RKL_ICU_FUNCTION_APPEND(uregex_start)(re, c, s); <span class="keywordflow">if</span>(RKL_EXPECTED((*s &gt; U_ZERO_ERROR), 0L) || (start == -1)) { *r = NSNotFoundRange; } <span class="keywordflow">else</span> { r-&gt;location = (NSUInteger)start; r-&gt;length = (NSUInteger)RKL_ICU_FUNCTION_APPEND(uregex_end)(re, c, s) - r-&gt;location; r-&gt;location += cr-&gt;setToRange.location; } <span class="keywordflow">return</span>(*s); }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 RKL_STATIC_INLINE <a class="code" href="a00029.html">RKLFindAll</a> rkl_makeFindAll(RKL_STRONG_REF NSRange * RKL_GC_VOLATILE r, NSRange fir, NSInteger c, <span class="keywordtype">size_t</span> s, <span class="keywordtype">size_t</span> su, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE rsb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ssb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE asb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE dsb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ksb, NSInteger f, NSInteger cap, NSInteger fut) RKL_WARN_UNUSED_CONST;
<a name="l00576"></a>00576 RKL_STATIC_INLINE <a class="code" href="a00029.html">RKLFindAll</a> rkl_makeFindAll(RKL_STRONG_REF NSRange * RKL_GC_VOLATILE r, NSRange fir, NSInteger c, <span class="keywordtype">size_t</span> s, <span class="keywordtype">size_t</span> su, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE rsb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ssb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE asb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE dsb, RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE ksb, NSInteger f, NSInteger cap, NSInteger fut) { <span class="keywordflow">return</span>(((<a class="code" href="a00029.html">RKLFindAll</a>){ .ranges=r, .findInRange=fir, .remainingRange=fir, .capacity=c, .found=f, .findUpTo=fut, .capture=cap, .addedSplitRanges=0L, .size=s, .stackUsed=su, .rangesScratchBuffer=rsb, .stringsScratchBuffer=ssb, .arraysScratchBuffer=asb, .dictionariesScratchBuffer=dsb, .keysScratchBuffer=ksb})); }
<a name="l00577"></a>00577 
<a name="l00579"></a>00579 <span class="preprocessor">#pragma mark -</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span><span class="preprocessor">#pragma mark RKL_FAST_MUTABLE_CHECK implementation</span>
<a name="l00581"></a>00581 <span class="preprocessor"></span>
<a name="l00582"></a>00582 <span class="preprocessor">#ifdef RKL_FAST_MUTABLE_CHECK</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span><span class="comment">// We use a trampoline function pointer to check at run time if the function __CFStringIsMutable is available.</span>
<a name="l00584"></a>00584 <span class="comment">// If it is, the trampoline function pointer is replaced with the address of that function.</span>
<a name="l00585"></a>00585 <span class="comment">// Otherwise, we assume the worst case that every string is mutable.</span>
<a name="l00586"></a>00586 <span class="comment">// This hopefully helps to protect us since we&#39;re using an undocumented, non-public API call.</span>
<a name="l00587"></a>00587 <span class="comment">// We will keep on working if it ever does go away, just with a bit less performance due to the overhead of mutable checks.</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keyword">static</span> BOOL  rkl_CFStringIsMutable_first (CFStringRef str);
<a name="l00590"></a>00590 <span class="keyword">static</span> BOOL  rkl_CFStringIsMutable_yes   (CFStringRef str RKL_UNUSED_ARG) { <span class="keywordflow">return</span>(YES); }
<a name="l00591"></a>00591 <span class="keyword">static</span> BOOL(*rkl_CFStringIsMutable)      (CFStringRef str) = rkl_CFStringIsMutable_first;
<a name="l00592"></a>00592 <span class="keyword">static</span> BOOL  rkl_CFStringIsMutable_first (CFStringRef str)                { <span class="keywordflow">if</span>((rkl_CFStringIsMutable = (BOOL(*)(CFStringRef))dlsym(RTLD_DEFAULT, <span class="stringliteral">&quot;__CFStringIsMutable&quot;</span>)) == NULL) { rkl_CFStringIsMutable = rkl_CFStringIsMutable_yes; } <span class="keywordflow">return</span>(rkl_CFStringIsMutable(str)); }
<a name="l00593"></a>00593 <span class="preprocessor">#else  // RKL_FAST_MUTABLE_CHECK is not defined.  Assume that all strings are potentially mutable.</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span><span class="preprocessor">#define rkl_CFStringIsMutable(s) (YES)</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span><span class="preprocessor">#endif // RKL_FAST_MUTABLE_CHECK</span>
<a name="l00596"></a>00596 <span class="preprocessor"></span>
<a name="l00598"></a>00598 <span class="preprocessor">#pragma mark -</span>
<a name="l00599"></a>00599 <span class="preprocessor"></span><span class="preprocessor">#pragma mark iPhone / iPod touch low memory notification handler</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>
<a name="l00601"></a>00601 <span class="preprocessor">#if       defined(RKL_REGISTER_FOR_IPHONE_LOWMEM_NOTIFICATIONS) &amp;&amp; (RKL_REGISTER_FOR_IPHONE_LOWMEM_NOTIFICATIONS == 1)</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span>
<a name="l00603"></a>00603 <span class="comment">// The next few lines are specifically for the iPhone to catch low memory conditions.</span>
<a name="l00604"></a>00604 <span class="comment">// The basic idea is that rkl_RegisterForLowMemoryNotifications() is set to be run once by the linker at load time via __attribute((constructor)).</span>
<a name="l00605"></a>00605 <span class="comment">// rkl_RegisterForLowMemoryNotifications() tries to find the iPhone low memory notification symbol.  If it can find it,</span>
<a name="l00606"></a>00606 <span class="comment">// it registers with the default NSNotificationCenter to call the RKLLowMemoryWarningObserver class method +lowMemoryWarning:.</span>
<a name="l00607"></a>00607 <span class="comment">// rkl_RegisterForLowMemoryNotifications() uses an atomic compare and swap to guarantee that it initializes exactly once.</span>
<a name="l00608"></a>00608 <span class="comment">// +lowMemoryWarning tries to acquire the cache lock.  If it gets the lock, it clears the cache.  If it can&#39;t, it calls performSelector:</span>
<a name="l00609"></a>00609 <span class="comment">// with a delay of half a second to try again.  This will hopefully prevent any deadlocks, such as a RegexKitLite request for</span>
<a name="l00610"></a>00610 <span class="comment">// memory triggering a notification while the lock is held.</span>
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_RegisterForLowMemoryNotifications(<span class="keywordtype">void</span>) RKL_ATTRIBUTES(used);
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 @interface      RKLLowMemoryWarningObserver : NSObject +(<span class="keywordtype">void</span>)lowMemoryWarning:(<span class="keywordtype">id</span>)notification; @end
<a name="l00615"></a>00615 @implementation RKLLowMemoryWarningObserver
<a name="l00616"></a>00616 +(<span class="keywordtype">void</span>)lowMemoryWarning:(<span class="keywordtype">id</span>)notification {
<a name="l00617"></a>00617   <span class="keywordflow">if</span>(OSSpinLockTry(&amp;rkl_cacheSpinLock)) { rkl_clearStringCache(); OSSpinLockUnlock(&amp;rkl_cacheSpinLock); }
<a name="l00618"></a>00618   <span class="keywordflow">else</span> { [[RKLLowMemoryWarningObserver class] performSelector:@selector(lowMemoryWarning:) withObject:notification afterDelay:(NSTimeInterval)0.1]; }
<a name="l00619"></a>00619 }
<a name="l00620"></a>00620 <span class="keyword">@end</span>
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">int</span> rkl_HaveRegisteredForLowMemoryNotifications = 0;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 __attribute__((constructor)) static <span class="keywordtype">void</span> rkl_RegisterForLowMemoryNotifications(<span class="keywordtype">void</span>) {
<a name="l00625"></a>00625   _Bool   didSwap                   = <span class="keyword">false</span>;
<a name="l00626"></a>00626   <span class="keywordtype">void</span>  **memoryWarningNotification = NULL;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628   <span class="keywordflow">while</span>((rkl_HaveRegisteredForLowMemoryNotifications == 0) &amp;&amp; ((didSwap = OSAtomicCompareAndSwapIntBarrier(0, 1, &amp;rkl_HaveRegisteredForLowMemoryNotifications)) == <span class="keyword">false</span>)) { <span class="comment">/* Allows for spurious CAS failures. */</span> }
<a name="l00629"></a>00629   <span class="keywordflow">if</span>(didSwap == <span class="keyword">true</span>) {
<a name="l00630"></a>00630     <span class="keywordflow">if</span>((memoryWarningNotification = (<span class="keywordtype">void</span> **)dlsym(RTLD_DEFAULT, <span class="stringliteral">&quot;UIApplicationDidReceiveMemoryWarningNotification&quot;</span>)) != NULL) {
<a name="l00631"></a>00631       [[NSNotificationCenter defaultCenter] addObserver:[RKLLowMemoryWarningObserver class] selector:@selector(lowMemoryWarning:) name:(NSString *)*memoryWarningNotification object:NULL];
<a name="l00632"></a>00632     }
<a name="l00633"></a>00633   }
<a name="l00634"></a>00634 }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 <span class="preprocessor">#endif // defined(RKL_REGISTER_FOR_IPHONE_LOWMEM_NOTIFICATIONS) &amp;&amp; (RKL_REGISTER_FOR_IPHONE_LOWMEM_NOTIFICATIONS == 1)</span>
<a name="l00637"></a>00637 <span class="preprocessor"></span>
<a name="l00639"></a>00639 <span class="preprocessor">#pragma mark -</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span><span class="preprocessor">#pragma mark DTrace functionality</span>
<a name="l00641"></a>00641 <span class="preprocessor"></span>
<a name="l00642"></a>00642 <span class="preprocessor">#ifdef    _RKL_DTRACE_ENABLED</span>
<a name="l00643"></a>00643 <span class="preprocessor"></span>
<a name="l00644"></a>00644 <span class="comment">// compiledRegexCache(unsigned long eventID, const char *regexUTF8, int options, int captures, int hitMiss, int icuStatusCode, const char *icuErrorMessage, double *hitRate);</span>
<a name="l00645"></a>00645 <span class="comment">// utf16ConversionCache(unsigned long eventID, unsigned int lookupResultFlags, double *hitRate, const void *string, unsigned long NSRange.location, unsigned long NSRange.length, long length);</span>
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 <span class="comment">/*</span>
<a name="l00648"></a>00648 <span class="comment">provider RegexKitLite {</span>
<a name="l00649"></a>00649 <span class="comment"> probe compiledRegexCache(unsigned long, const char *, unsigned int, int, int, int, const char *, double *);</span>
<a name="l00650"></a>00650 <span class="comment"> probe utf16ConversionCache(unsigned long, unsigned int, double *, const void *, unsigned long, unsigned long, long);</span>
<a name="l00651"></a>00651 <span class="comment">};</span>
<a name="l00652"></a>00652 <span class="comment"> </span>
<a name="l00653"></a>00653 <span class="comment">#pragma D attributes Unstable/Unstable/Common provider RegexKitLite provider</span>
<a name="l00654"></a>00654 <span class="comment">#pragma D attributes Private/Private/Common   provider RegexKitLite module</span>
<a name="l00655"></a>00655 <span class="comment">#pragma D attributes Private/Private/Common   provider RegexKitLite function</span>
<a name="l00656"></a>00656 <span class="comment">#pragma D attributes Unstable/Unstable/Common provider RegexKitLite name</span>
<a name="l00657"></a>00657 <span class="comment">#pragma D attributes Unstable/Unstable/Common provider RegexKitLite args</span>
<a name="l00658"></a>00658 <span class="comment">*/</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="preprocessor">#define REGEXKITLITE_STABILITY &quot;___dtrace_stability$RegexKitLite$v1$4_4_5_1_1_5_1_1_5_4_4_5_4_4_5&quot;</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span><span class="preprocessor">#define REGEXKITLITE_TYPEDEFS  &quot;___dtrace_typedefs$RegexKitLite$v1&quot;</span>
<a name="l00662"></a>00662 <span class="preprocessor"></span><span class="preprocessor">#define REGEXKITLITE_COMPILEDREGEXCACHE(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { __asm__ volatile(&quot;.reference &quot; REGEXKITLITE_TYPEDEFS); __dtrace_probe$RegexKitLite$compiledRegexCache$v1$756e7369676e6564206c6f6e67$63686172202a$756e7369676e656420696e74$696e74$696e74$696e74$63686172202a$646f75626c65202a(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); __asm__ volatile(&quot;.reference &quot; REGEXKITLITE_STABILITY); }</span>
<a name="l00663"></a>00663 <span class="preprocessor"></span><span class="preprocessor">#define REGEXKITLITE_COMPILEDREGEXCACHE_ENABLED() __dtrace_isenabled$RegexKitLite$compiledRegexCache$v1()</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span><span class="preprocessor">#define REGEXKITLITE_CONVERTEDSTRINGU16CACHE(arg0, arg1, arg2, arg3, arg4, arg5, arg6) { __asm__ volatile(&quot;.reference &quot; REGEXKITLITE_TYPEDEFS); __dtrace_probe$RegexKitLite$utf16ConversionCache$v1$756e7369676e6564206c6f6e67$756e7369676e656420696e74$646f75626c65202a$766f6964202a$756e7369676e6564206c6f6e67$756e7369676e6564206c6f6e67$6c6f6e67(arg0, arg1, arg2, arg3, arg4, arg5, arg6); __asm__ volatile(&quot;.reference &quot; REGEXKITLITE_STABILITY); }</span>
<a name="l00665"></a>00665 <span class="preprocessor"></span><span class="preprocessor">#define REGEXKITLITE_CONVERTEDSTRINGU16CACHE_ENABLED() __dtrace_isenabled$RegexKitLite$utf16ConversionCache$v1()</span>
<a name="l00666"></a>00666 <span class="preprocessor"></span>
<a name="l00667"></a>00667 <span class="keyword">extern</span> <span class="keywordtype">void</span> __dtrace_probe$RegexKitLite$compiledRegexCache$v1$756e7369676e6564206c6f6e67$63686172202a$756e7369676e656420696e74$696e74$696e74$696e74$63686172202a$646f75626c65202a(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">double</span> *);
<a name="l00668"></a>00668 <span class="keyword">extern</span> <span class="keywordtype">int</span>  __dtrace_isenabled$RegexKitLite$compiledRegexCache$v1(<span class="keywordtype">void</span>);
<a name="l00669"></a>00669 <span class="keyword">extern</span> <span class="keywordtype">void</span> __dtrace_probe$RegexKitLite$utf16ConversionCache$v1$756e7369676e6564206c6f6e67$756e7369676e656420696e74$646f75626c65202a$766f6964202a$756e7369676e6564206c6f6e67$756e7369676e6564206c6f6e67$6c6f6e67(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keywordtype">double</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">long</span>);
<a name="l00670"></a>00670 <span class="keyword">extern</span> <span class="keywordtype">int</span>  __dtrace_isenabled$RegexKitLite$utf16ConversionCache$v1(<span class="keywordtype">void</span>);
<a name="l00671"></a>00671 
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="keyword">enum</span> {
<a name="l00675"></a>00675   RKLCacheHitLookupFlag           = 1 &lt;&lt; 0,
<a name="l00676"></a>00676   RKLConversionRequiredLookupFlag = 1 &lt;&lt; 1,
<a name="l00677"></a>00677   RKLSetTextLookupFlag            = 1 &lt;&lt; 2,
<a name="l00678"></a>00678   RKLDynamicBufferLookupFlag      = 1 &lt;&lt; 3,
<a name="l00679"></a>00679   RKLErrorLookupFlag              = 1 &lt;&lt; 4,
<a name="l00680"></a>00680   RKLEnumerationBufferLookupFlag  = 1 &lt;&lt; 5,
<a name="l00681"></a>00681 };
<a name="l00682"></a>00682 
<a name="l00683"></a>00683 <span class="preprocessor">#define rkl_dtrace_addLookupFlag(a,b) do { a |= (unsigned int)(b); } while(0)</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span>
<a name="l00685"></a>00685 <span class="keyword">static</span> <span class="keywordtype">char</span> rkl_dtrace_regexUTF8[_RKL_REGEX_CACHE_LINES + 1UL][_RKL_DTRACE_REGEXUTF8_SIZE];
<a name="l00686"></a>00686 <span class="keyword">static</span> NSUInteger rkl_dtrace_eventID, rkl_dtrace_compiledCacheLookups, rkl_dtrace_compiledCacheHits, rkl_dtrace_conversionBufferLookups, rkl_dtrace_conversionBufferHits;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 <span class="preprocessor">#define rkl_dtrace_incrementEventID() do { rkl_dtrace_eventID++; } while(0)</span>
<a name="l00689"></a>00689 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_incrementAndGetEventID(v) do { rkl_dtrace_eventID++; v = rkl_dtrace_eventID; } while(0)</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_compiledRegexCache(a0, a1, a2, a3, a4, a5) do { int _a3 = (a3); rkl_dtrace_compiledCacheLookups++; if(_a3 == 1) { rkl_dtrace_compiledCacheHits++; } if(RKL_EXPECTED(REGEXKITLITE_COMPILEDREGEXCACHE_ENABLED(), 0L)) { double hitRate = 0.0; if(rkl_dtrace_compiledCacheLookups &gt; 0UL) { hitRate = ((double)rkl_dtrace_compiledCacheHits / (double)rkl_dtrace_compiledCacheLookups) * 100.0; } REGEXKITLITE_COMPILEDREGEXCACHE(rkl_dtrace_eventID, a0, a1, a2, _a3, a4, a5, &amp;hitRate); } } while(0)</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_utf16ConversionCache(a0, a1, a2, a3, a4) do { unsigned int _a0 = (a0); if((_a0 &amp; RKLConversionRequiredLookupFlag) != 0U) { rkl_dtrace_conversionBufferLookups++; if((_a0 &amp; RKLCacheHitLookupFlag) != 0U) { rkl_dtrace_conversionBufferHits++; } } if(RKL_EXPECTED(REGEXKITLITE_CONVERTEDSTRINGU16CACHE_ENABLED(), 0L)) { double hitRate = 0.0; if(rkl_dtrace_conversionBufferLookups &gt; 0UL) { hitRate = ((double)rkl_dtrace_conversionBufferHits / (double)rkl_dtrace_conversionBufferLookups) * 100.0; } REGEXKITLITE_CONVERTEDSTRINGU16CACHE(rkl_dtrace_eventID, _a0, &amp;hitRate, a1, a2, a3, a4); } } while(0)</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_utf16ConversionCacheWithEventID(c0, a0, a1, a2, a3, a4) do { unsigned int _a0 = (a0); if((_a0 &amp; RKLConversionRequiredLookupFlag) != 0U) { rkl_dtrace_conversionBufferLookups++; if((_a0 &amp; RKLCacheHitLookupFlag) != 0U) { rkl_dtrace_conversionBufferHits++; } } if(RKL_EXPECTED(REGEXKITLITE_CONVERTEDSTRINGU16CACHE_ENABLED(), 0L)) { double hitRate = 0.0; if(rkl_dtrace_conversionBufferLookups &gt; 0UL) { hitRate = ((double)rkl_dtrace_conversionBufferHits / (double)rkl_dtrace_conversionBufferLookups) * 100.0; } REGEXKITLITE_CONVERTEDSTRINGU16CACHE(c0, _a0, &amp;hitRate, a1, a2, a3, a4); } } while(0)</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="comment">// \342\200\246 == UTF8 for HORIZONTAL ELLIPSIS, aka triple dots &#39;...&#39;</span>
<a name="l00696"></a>00696 <span class="preprocessor">#define RKL_UTF8_ELLIPSE &quot;\342\200\246&quot;</span>
<a name="l00697"></a>00697 <span class="preprocessor"></span>
<a name="l00698"></a>00698 <span class="comment">// rkl_dtrace_getRegexUTF8 will copy the str argument to utf8Buffer using UTF8 as the string encoding.</span>
<a name="l00699"></a>00699 <span class="comment">// If the utf8 encoding would take up more bytes than the utf8Buffers length, then the unicode character &#39;HORIZONTAL ELLIPSIS&#39; (&#39;...&#39;) is appended to indicate truncation occurred.</span>
<a name="l00700"></a>00700 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_dtrace_getRegexUTF8(CFStringRef str, <span class="keywordtype">char</span> *utf8Buffer) RKL_NONNULL_ARGS(2);
<a name="l00701"></a>00701 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_dtrace_getRegexUTF8(CFStringRef str, <span class="keywordtype">char</span> *utf8Buffer) {
<a name="l00702"></a>00702   <span class="keywordflow">if</span>((str == NULL) || (utf8Buffer == NULL)) { <span class="keywordflow">return</span>; }
<a name="l00703"></a>00703   CFIndex maxLength = ((CFIndex)_RKL_DTRACE_REGEXUTF8_SIZE - 2L), maxBytes = (maxLength - (CFIndex)sizeof(RKL_UTF8_ELLIPSE) - 1L), stringU16Length = CFStringGetLength(str), usedBytes = 0L;
<a name="l00704"></a>00704   CFStringGetBytes(str, CFMakeRange(0L, ((stringU16Length &lt; maxLength) ? stringU16Length : maxLength)), kCFStringEncodingUTF8, (UInt8)<span class="charliteral">&#39;?&#39;</span>, (Boolean)0, (UInt8 *)utf8Buffer, maxBytes, &amp;usedBytes);
<a name="l00705"></a>00705   <span class="keywordflow">if</span>(usedBytes == maxBytes) { strncpy(utf8Buffer + usedBytes, RKL_UTF8_ELLIPSE, ((<span class="keywordtype">size_t</span>)_RKL_DTRACE_REGEXUTF8_SIZE - (<span class="keywordtype">size_t</span>)usedBytes) - 2UL); } <span class="keywordflow">else</span> { utf8Buffer[usedBytes] = (char)0; }
<a name="l00706"></a>00706 }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708 <span class="preprocessor">#else  // _RKL_DTRACE_ENABLED</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span>
<a name="l00710"></a>00710 <span class="preprocessor">#define rkl_dtrace_incrementEventID()</span>
<a name="l00711"></a>00711 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_incrementAndGetEventID(v)</span>
<a name="l00712"></a>00712 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_compiledRegexCache(a0, a1, a2, a3, a4, a5)</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_utf16ConversionCache(a0, a1, a2, a3, a4)</span>
<a name="l00714"></a>00714 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_utf16ConversionCacheWithEventID(c0, a0, a1, a2, a3, a4)</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_getRegexUTF8(str, buf)</span>
<a name="l00716"></a>00716 <span class="preprocessor"></span><span class="preprocessor">#define rkl_dtrace_addLookupFlag(a,b)</span>
<a name="l00717"></a>00717 <span class="preprocessor"></span>
<a name="l00718"></a>00718 <span class="preprocessor">#endif // _RKL_DTRACE_ENABLED</span>
<a name="l00719"></a>00719 <span class="preprocessor"></span>
<a name="l00721"></a>00721 <span class="preprocessor">#pragma mark -</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span><span class="preprocessor">#pragma mark RegexKitLite low-level internal functions</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span><span class="preprocessor">#pragma mark -</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span>
<a name="l00725"></a>00725 <span class="comment">// The 4-way set associative LRU logic comes from Henry S. Warren Jr.&#39;s Hacker&#39;s Delight, &quot;revisions&quot;, 7-7 An LRU Algorithm:</span>
<a name="l00726"></a>00726 <span class="comment">// http://www.hackersdelight.org/revisions.pdf</span>
<a name="l00727"></a>00727 <span class="comment">// The functions rkl_leastRecentlyUsedWayInSet() and rkl_accessCacheSetWay() implement the cache functionality and are used</span>
<a name="l00728"></a>00728 <span class="comment">// from a number of different places that need to perform caching (i.e., cached regex, cached UTF16 conversions, etc)</span>
<a name="l00729"></a>00729 
<a name="l00730"></a>00730 <span class="preprocessor">#pragma mark 4-way set associative LRU functions</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>
<a name="l00732"></a>00732 RKL_STATIC_INLINE NSUInteger rkl_leastRecentlyUsedWayInSet(NSUInteger cacheSetsCount, <span class="keyword">const</span> RKLLRUCacheSet_t cacheSetsArray[cacheSetsCount], NSUInteger <span class="keyword">set</span>) {
<a name="l00733"></a>00733   RKLCAbortAssert((cacheSetsArray != NULL) &amp;&amp; ((NSInteger)cacheSetsCount &gt; 0L) &amp;&amp; (<span class="keyword">set</span> &lt; cacheSetsCount) &amp;&amp; ((cacheSetsArray == rkl_cachedRegexCacheSets) ? <span class="keyword">set</span> &lt; _RKL_REGEX_LRU_CACHE_SETS : 1) &amp;&amp; (((<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) - <span class="keyword">sizeof</span>(RKLLRUCacheSet_t)) * 8) &lt; (<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * 8)));
<a name="l00734"></a>00734   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cacheSet = (((<span class="keywordtype">unsigned</span> int)cacheSetsArray[<span class="keyword">set</span>]) &lt;&lt; ((<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int) - <span class="keyword">sizeof</span>(RKLLRUCacheSet_t)) * 8)); <span class="comment">// __builtin_clz takes an &#39;unsigned int&#39; argument.  The rest is to ensure bit alignment regardless of 32/64/whatever.</span>
<a name="l00735"></a>00735   NSUInteger leastRecentlyUsed = ((NSUInteger)(3LU - (NSUInteger)((__builtin_clz((~(((cacheSet &amp; 0x77777777U) + 0x77777777U) | cacheSet | 0x77777777U))) ) &gt;&gt; 2)));
<a name="l00736"></a>00736   RKLCAbortAssert(leastRecentlyUsed &lt; _RKL_LRU_CACHE_SET_WAYS);
<a name="l00737"></a>00737   <span class="keywordflow">return</span>(leastRecentlyUsed);
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 RKL_STATIC_INLINE <span class="keywordtype">void</span> rkl_accessCacheSetWay(NSUInteger cacheSetsCount, RKLLRUCacheSet_t cacheSetsArray[cacheSetsCount], NSUInteger cacheSet, NSUInteger cacheWay) {
<a name="l00741"></a>00741   RKLCAbortAssert((cacheSetsArray != NULL) &amp;&amp; ((NSInteger)cacheSetsCount &gt; 0L) &amp;&amp; (cacheSet &lt; cacheSetsCount) &amp;&amp; (cacheWay &lt; _RKL_LRU_CACHE_SET_WAYS) &amp;&amp; ((cacheSetsArray == rkl_cachedRegexCacheSets) ? cacheSet &lt; _RKL_REGEX_LRU_CACHE_SETS : 1));
<a name="l00742"></a>00742   cacheSetsArray[cacheSet] = (RKLLRUCacheSet_t)(((cacheSetsArray[cacheSet] &amp; (RKLLRUCacheSet_t)0xFFFFU) | (((RKLLRUCacheSet_t)0xFU) &lt;&lt; (cacheWay * 4U))) &amp; (~(((RKLLRUCacheSet_t)0x1111U) &lt;&lt; (3U - cacheWay))));
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="preprocessor">#pragma mark Common, macro&#39;ish compiled regular expression cache logic</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>
<a name="l00747"></a>00747 <span class="comment">// These functions consolidate bits and pieces of code used to maintain, update, and access the 4-way set associative LRU cache and Regex Lookaside Cache.</span>
<a name="l00748"></a>00748 RKL_STATIC_INLINE NSUInteger      rkl_regexLookasideCacheIndexForPointerAndOptions  (<span class="keyword">const</span> <span class="keywordtype">void</span>           *ptr,       RKLRegexOptions options)                       { <span class="keywordflow">return</span>(((((NSUInteger)(ptr)) &gt;&gt; 4) + options + (options &gt;&gt; 4)) &amp; _RKL_REGEX_LOOKASIDE_CACHE_MASK); }
<a name="l00749"></a>00749 RKL_STATIC_INLINE <span class="keywordtype">void</span>            rkl_setRegexLookasideCacheToCachedRegexForPointer (<span class="keyword">const</span> <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, <span class="keyword">const</span> <span class="keywordtype">void</span> *ptr)                             { rkl_regexLookasideCache[rkl_regexLookasideCacheIndexForPointerAndOptions(ptr, cachedRegex-&gt;options)] = (cachedRegex - rkl_cachedRegexes); }
<a name="l00750"></a>00750 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_cachedRegexFromRegexLookasideCacheForString   (<span class="keyword">const</span> <span class="keywordtype">void</span>           *ptr,       RKLRegexOptions options)                       { <span class="keywordflow">return</span>(&amp;rkl_cachedRegexes[rkl_regexLookasideCache[rkl_regexLookasideCacheIndexForPointerAndOptions(ptr, options)]]); }
<a name="l00751"></a>00751 RKL_STATIC_INLINE NSUInteger      rkl_makeCacheSetHash                              (      CFHashCode      regexHash, RKLRegexOptions options)                       { <span class="keywordflow">return</span>((NSUInteger)regexHash ^ (NSUInteger)options); }
<a name="l00752"></a>00752 RKL_STATIC_INLINE NSUInteger      rkl_cacheSetForRegexHashAndOptions                (      CFHashCode      regexHash, RKLRegexOptions options)                       { <span class="keywordflow">return</span>((rkl_makeCacheSetHash(regexHash, options) % _RKL_REGEX_LRU_CACHE_SETS)); }
<a name="l00753"></a>00753 RKL_STATIC_INLINE NSUInteger      rkl_cacheWayForCachedRegex                        (<span class="keyword">const</span> <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex)                                              { <span class="keywordflow">return</span>((cachedRegex - rkl_cachedRegexes) % _RKL_LRU_CACHE_SET_WAYS); }
<a name="l00754"></a>00754 RKL_STATIC_INLINE NSUInteger      rkl_cacheSetForCachedRegex                        (<span class="keyword">const</span> <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex)                                              { <span class="keywordflow">return</span>(rkl_cacheSetForRegexHashAndOptions(cachedRegex-&gt;regexHash, cachedRegex-&gt;options)); }
<a name="l00755"></a>00755 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_cachedRegexForCacheSetAndWay                  (      NSUInteger      cacheSet,  NSUInteger cacheWay)                           { <span class="keywordflow">return</span>(&amp;rkl_cachedRegexes[((cacheSet * _RKL_LRU_CACHE_SET_WAYS) + cacheWay)]); }
<a name="l00756"></a>00756 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_cachedRegexForRegexHashAndOptionsAndWay       (      CFHashCode      regexHash, RKLRegexOptions options, NSUInteger cacheWay)  { <span class="keywordflow">return</span>(rkl_cachedRegexForCacheSetAndWay(rkl_cacheSetForRegexHashAndOptions(regexHash, options), cacheWay)); }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 RKL_STATIC_INLINE <span class="keywordtype">void</span> rkl_updateCachesWithCachedRegex(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, <span class="keyword">const</span> <span class="keywordtype">void</span> *ptr, <span class="keywordtype">int</span> hitOrMiss RKL_UNUSED_DTRACE_ARG, <span class="keywordtype">int</span> status RKL_UNUSED_DTRACE_ARG) {
<a name="l00759"></a>00759   rkl_lastCachedRegex = cachedRegex;
<a name="l00760"></a>00760   rkl_setRegexLookasideCacheToCachedRegexForPointer(cachedRegex, ptr);
<a name="l00761"></a>00761   rkl_accessCacheSetWay(_RKL_REGEX_LRU_CACHE_SETS, rkl_cachedRegexCacheSets, rkl_cacheSetForCachedRegex(cachedRegex), rkl_cacheWayForCachedRegex(cachedRegex)); <span class="comment">// Set the matching line as the most recently used.</span>
<a name="l00762"></a>00762   rkl_dtrace_compiledRegexCache(&amp;rkl_dtrace_regexUTF8[(cachedRegex - rkl_cachedRegexes)][0], cachedRegex-&gt;options, (<span class="keywordtype">int</span>)cachedRegex-&gt;captureCount, hitOrMiss, status, NULL);
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 RKL_STATIC_INLINE <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_leastRecentlyUsedCachedRegexForRegexHashAndOptions(CFHashCode regexHash, RKLRegexOptions options) {
<a name="l00766"></a>00766   NSUInteger cacheSet = rkl_cacheSetForRegexHashAndOptions(regexHash, options);
<a name="l00767"></a>00767   <span class="keywordflow">return</span>(rkl_cachedRegexForCacheSetAndWay(cacheSet, rkl_leastRecentlyUsedWayInSet(_RKL_REGEX_LRU_CACHE_SETS, rkl_cachedRegexCacheSets, cacheSet)));
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="preprocessor">#pragma mark Regular expression lookup function</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>
<a name="l00772"></a>00772 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l00773"></a>00773 <span class="comment">//  IMPORTANT!   Should only be called with rkl_cacheSpinLock already locked!</span>
<a name="l00774"></a>00774 <span class="comment">//  ----------</span>
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 <span class="keyword">static</span> <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_getCachedRegex(<a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, NSError **error, <span class="keywordtype">id</span> *exception) {
<a name="l00777"></a>00777   <span class="comment">//  ----------   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00778"></a>00778   <span class="comment">//  IMPORTANT!   This section of code is called almost every single time that any RegexKitLite functionality is used! It /MUST/ be very fast!</span>
<a name="l00779"></a>00779   <span class="comment">//  ----------   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00780"></a>00780   
<a name="l00781"></a>00781   <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex = NULL;
<a name="l00782"></a>00782   CFHashCode      regexHash   = 0UL;
<a name="l00783"></a>00783   int32_t         status      = 0;
<a name="l00784"></a>00784 
<a name="l00785"></a>00785   RKLCDelayedAssert((rkl_cacheSpinLock != (OSSpinLock)0) &amp;&amp; (regexString != NULL), exception, exitNow);
<a name="l00786"></a>00786   
<a name="l00787"></a>00787   <span class="comment">// Fast path the common case where this regex is exactly the same one used last time.</span>
<a name="l00788"></a>00788   <span class="comment">// The pointer equality test is valid under these circumstances since the cachedRegex-&gt;regexString is an immutable copy.</span>
<a name="l00789"></a>00789   <span class="comment">// If the regexString argument is mutable, this test will fail, and we&#39;ll use the the slow path cache check below.</span>
<a name="l00790"></a>00790   <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_lastCachedRegex != NULL, 1L) &amp;&amp; RKL_EXPECTED(rkl_lastCachedRegex-&gt;regexString == (CFStringRef)regexString, 1L) &amp;&amp; RKL_EXPECTED(rkl_lastCachedRegex-&gt;options == options, 1L) &amp;&amp; RKL_EXPECTED(rkl_lastCachedRegex-&gt;icu_regex != NULL, 1L)) {
<a name="l00791"></a>00791     rkl_dtrace_compiledRegexCache(&amp;rkl_dtrace_regexUTF8[(rkl_lastCachedRegex - rkl_cachedRegexes)][0], rkl_lastCachedRegex-&gt;options, (<span class="keywordtype">int</span>)rkl_lastCachedRegex-&gt;captureCount, 1, 0, NULL);
<a name="l00792"></a>00792     <span class="keywordflow">return</span>(rkl_lastCachedRegex);
<a name="l00793"></a>00793   }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   rkl_lastCachedRegex = NULL; <span class="comment">// Make sure that rkl_lastCachedRegex is NULL in case there is some kind of error.</span>
<a name="l00796"></a>00796   cachedRegex         = rkl_cachedRegexFromRegexLookasideCacheForString(regexString, options); <span class="comment">// Check the Regex Lookaside Cache to see if we can quickly find the correct Cached Regex for this regexString pointer + options.</span>
<a name="l00797"></a>00797   <span class="keywordflow">if</span>((RKL_EXPECTED(cachedRegex-&gt;regexString == (CFStringRef)regexString, 1L) || (RKL_EXPECTED(cachedRegex-&gt;regexString != NULL, 1L) &amp;&amp; RKL_EXPECTED(CFEqual((CFTypeRef)regexString, (CFTypeRef)cachedRegex-&gt;regexString) == YES, 1L))) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;options == options, 1L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;icu_regex != NULL, 1L)) { <span class="keywordflow">goto</span> foundMatch; } <span class="comment">// There was a Regex Lookaside Cache hit, jump to foundMatch: to quickly return the result. A Regex Lookaside Cache hit allows us to bypass calling CFHash(), which is a decent performance win.</span>
<a name="l00798"></a>00798   <span class="keywordflow">else</span> { cachedRegex = NULL; regexHash = CFHash((CFTypeRef)regexString); } <span class="comment">// Regex Lookaside Cache miss.  We need to call CFHash() to determine the cache set for this regex.</span>
<a name="l00799"></a>00799 
<a name="l00800"></a>00800   NSInteger cacheWay = 0L;                                                               <span class="comment">// Check each way of the set that this regex belongs to.</span>
<a name="l00801"></a>00801   <span class="keywordflow">for</span>(cacheWay = ((NSInteger)_RKL_LRU_CACHE_SET_WAYS - 1L); cacheWay &gt; 0L; cacheWay--) { <span class="comment">// Checking the ways in reverse (3, 2, 1, 0) finds a match &quot;sooner&quot; on average.</span>
<a name="l00802"></a>00802     cachedRegex = rkl_cachedRegexForRegexHashAndOptionsAndWay(regexHash, options, (NSUInteger)cacheWay);
<a name="l00803"></a>00803     <span class="comment">// Return the cached entry if it&#39;s a match. If regexString is mutable, the pointer equality test will fail, and CFEqual() is used to determine true equality with the immutable cachedRegex copy.  CFEqual() performs a slow character by character check.</span>
<a name="l00804"></a>00804     <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;regexHash == regexHash, 0UL) &amp;&amp; ((cachedRegex-&gt;regexString == (CFStringRef)regexString) || (RKL_EXPECTED(cachedRegex-&gt;regexString != NULL, 1L) &amp;&amp; RKL_EXPECTED(CFEqual((CFTypeRef)regexString, (CFTypeRef)cachedRegex-&gt;regexString) == YES, 1L))) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;options == options, 1L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;icu_regex != NULL, 1L)) {
<a name="l00805"></a>00805     foundMatch: <span class="comment">// Control can transfer here (from above) via a Regex Lookaside Cache hit.</span>
<a name="l00806"></a>00806       rkl_updateCachesWithCachedRegex(cachedRegex, regexString, 1, 0);
<a name="l00807"></a>00807       <span class="keywordflow">return</span>(cachedRegex);
<a name="l00808"></a>00808     }
<a name="l00809"></a>00809   }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811   <span class="comment">//  ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l00812"></a>00812   <span class="comment">//  IMPORTANT!   This section of code is called almost every single time that any RegexKitLite functionality is used! It /MUST/ be very fast!</span>
<a name="l00813"></a>00813   <span class="comment">//  ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="comment">// Code below this point is not as sensitive to speed since compiling a regular expression is an extremely expensive operation.</span>
<a name="l00816"></a>00816   <span class="comment">// The regex was not found in the cache.  Get the cached regex for the least recently used line in the set, then clear the cached regex and create a new ICU regex in its place.</span>
<a name="l00817"></a>00817   cachedRegex = rkl_leastRecentlyUsedCachedRegexForRegexHashAndOptions(regexHash, options);
<a name="l00818"></a>00818   rkl_clearCachedRegex(cachedRegex);
<a name="l00819"></a>00819   
<a name="l00820"></a>00820   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex-&gt;regexString = CFStringCreateCopy(NULL, (CFStringRef)regexString)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } ; <span class="comment">// Get a cheap immutable copy.</span>
<a name="l00821"></a>00821   rkl_dtrace_getRegexUTF8(cachedRegex-&gt;regexString, &amp;rkl_dtrace_regexUTF8[(cachedRegex - rkl_cachedRegexes)][0]);
<a name="l00822"></a>00822   cachedRegex-&gt;regexHash = regexHash;
<a name="l00823"></a>00823   cachedRegex-&gt;options   = options;
<a name="l00824"></a>00824   
<a name="l00825"></a>00825   CFIndex                                        regexStringU16Length = CFStringGetLength(cachedRegex-&gt;regexString); <span class="comment">// In UTF16 code units.</span>
<a name="l00826"></a>00826   <a class="code" href="a00030.html">UParseError</a>                                    parseError           = (<a class="code" href="a00030.html">UParseError</a>){-1, -1, {0}, {0}};
<a name="l00827"></a>00827   RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE regexUniChar         = NULL;
<a name="l00828"></a>00828   
<a name="l00829"></a>00829   <span class="keywordflow">if</span>(RKL_EXPECTED(regexStringU16Length &gt;= (CFIndex)INT_MAX, 0L)) { *exception = [NSException exceptionWithName:NSRangeException reason:@&quot;Regex string length exceeds INT_MAX&quot; userInfo:NULL]; <span class="keywordflow">goto</span> exitNow; }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="comment">// Try to quickly obtain regexString in UTF16 format.</span>
<a name="l00832"></a>00832   <span class="keywordflow">if</span>((regexUniChar = CFStringGetCharactersPtr(cachedRegex-&gt;regexString)) == NULL) { <span class="comment">// We didn&#39;t get the UTF16 pointer quickly and need to perform a full conversion in a temp buffer.</span>
<a name="l00833"></a>00833     RKL_STRONG_REF UniChar * RKL_GC_VOLATILE uniCharBuffer = NULL;
<a name="l00834"></a>00834     <span class="keywordflow">if</span>(((<span class="keywordtype">size_t</span>)regexStringU16Length * <span class="keyword">sizeof</span>(UniChar)) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((uniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)alloca(                            (<span class="keywordtype">size_t</span>)regexStringU16Length * <span class="keyword">sizeof</span>(UniChar)     )) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } } <span class="comment">// Try to use the stack.</span>
<a name="l00835"></a>00835     <span class="keywordflow">else</span> {                                                                            <span class="keywordflow">if</span>(RKL_EXPECTED((uniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_realloc(&amp;rkl_scratchBuffer[0], (<span class="keywordtype">size_t</span>)regexStringU16Length * <span class="keyword">sizeof</span>(UniChar), 0UL)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } } <span class="comment">// Otherwise use the heap.</span>
<a name="l00836"></a>00836     CFStringGetCharacters(cachedRegex-&gt;regexString, CFMakeRange(0L, regexStringU16Length), uniCharBuffer); <span class="comment">// Convert regexString to UTF16.</span>
<a name="l00837"></a>00837     regexUniChar = uniCharBuffer;
<a name="l00838"></a>00838   }
<a name="l00839"></a>00839   
<a name="l00840"></a>00840   <span class="comment">// Create the ICU regex.</span>
<a name="l00841"></a>00841   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex-&gt;icu_regex = RKL_ICU_FUNCTION_APPEND(uregex_open)(regexUniChar, (int32_t)regexStringU16Length, options, &amp;parseError, &amp;status)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l00842"></a>00842   <span class="keywordflow">if</span>(RKL_EXPECTED(status &lt;= U_ZERO_ERROR, 1L)) { cachedRegex-&gt;captureCount = (NSInteger)RKL_ICU_FUNCTION_APPEND(uregex_groupCount)(cachedRegex-&gt;icu_regex, &amp;status); }
<a name="l00843"></a>00843   <span class="keywordflow">if</span>(RKL_EXPECTED(status &lt;= U_ZERO_ERROR, 1L)) { rkl_updateCachesWithCachedRegex(cachedRegex, regexString, 0, status); }
<a name="l00844"></a>00844   
<a name="l00845"></a>00845 exitNow:
<a name="l00846"></a>00846   <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_scratchBuffer[0] != NULL,         0L)) { rkl_scratchBuffer[0] = rkl_free(&amp;rkl_scratchBuffer[0]); }
<a name="l00847"></a>00847   <span class="keywordflow">if</span>(RKL_EXPECTED(status                &gt; U_ZERO_ERROR, 0L)) { rkl_clearCachedRegex(cachedRegex); cachedRegex = rkl_lastCachedRegex = NULL; <span class="keywordflow">if</span>(error != NULL) { *error = rkl_makeNSError((RKLUserInfoOptions)RKLUserInfoNone, regexString, options, &amp;parseError, status, NULL, NSNotFoundRange, NULL, NULL, 0L, (RKLRegexEnumerationOptions)RKLRegexEnumerationNoOptions, <span class="stringliteral">@&quot;There was an error compiling the regular expression.&quot;</span>); } }
<a name="l00848"></a>00848   
<a name="l00849"></a>00849 <span class="preprocessor">#ifdef    _RKL_DTRACE_ENABLED</span>
<a name="l00850"></a>00850 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex == NULL, 1L)) { <span class="keywordtype">char</span> regexUTF8[_RKL_DTRACE_REGEXUTF8_SIZE]; <span class="keyword">const</span> <span class="keywordtype">char</span> *err = NULL; <span class="keywordflow">if</span>(status != U_ZERO_ERROR) { err = RKL_ICU_FUNCTION_APPEND(u_errorName)(status); } rkl_dtrace_getRegexUTF8((CFStringRef)regexString, regexUTF8); rkl_dtrace_compiledRegexCache(regexUTF8, options, -1, -1, status, err); }
<a name="l00851"></a>00851 <span class="preprocessor">#endif // _RKL_DTRACE_ENABLED</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span>  
<a name="l00853"></a>00853   <span class="keywordflow">return</span>(cachedRegex);
<a name="l00854"></a>00854 }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l00857"></a>00857 <span class="comment">//  IMPORTANT!   Should only be called with rkl_cacheSpinLock already locked!</span>
<a name="l00858"></a>00858 <span class="comment">//  ----------</span>
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="preprocessor">#pragma mark Set a cached regular expression to a NSStrings UTF-16 text</span>
<a name="l00861"></a>00861 <span class="preprocessor"></span>
<a name="l00862"></a>00862 <span class="keyword">static</span> NSUInteger rkl_setCachedRegexToString(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, <span class="keyword">const</span> NSRange *range, int32_t *status, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG) {
<a name="l00863"></a>00863   <span class="comment">//  ----------   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00864"></a>00864   <span class="comment">//  IMPORTANT!   This section of code is called almost every single time that any RegexKitLite functionality is used! It /MUST/ be very fast!</span>
<a name="l00865"></a>00865   <span class="comment">//  ----------   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00866"></a>00866   
<a name="l00867"></a>00867   RKLCDelayedAssert((cachedRegex != NULL) &amp;&amp; (cachedRegex-&gt;setToString != NULL) &amp;&amp; ((range != NULL) &amp;&amp; (NSEqualRanges(*range, NSNotFoundRange) == NO)) &amp;&amp; (status != NULL), exception, exitNow);
<a name="l00868"></a>00868   RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE stringUniChar = NULL;
<a name="l00869"></a>00869 <span class="preprocessor">#ifdef _RKL_DTRACE_ENABLED</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lookupResultFlags = 0U;
<a name="l00871"></a>00871 <span class="preprocessor">#endif</span>
<a name="l00872"></a>00872 <span class="preprocessor"></span>  
<a name="l00873"></a>00873   NSUInteger  useFixedBuffer = (cachedRegex-&gt;setToLength &lt; (CFIndex)_RKL_FIXED_LENGTH) ? 1UL : 0UL;
<a name="l00874"></a>00874   <a class="code" href="a00027.html">RKLBuffer</a>  *buffer         = NULL;
<a name="l00875"></a>00875   
<a name="l00876"></a>00876   <span class="keywordflow">if</span>(cachedRegex-&gt;setToNeedsConversion == 0U) {
<a name="l00877"></a>00877     RKLCDelayedAssert((cachedRegex-&gt;setToUniChar != NULL) &amp;&amp; (cachedRegex-&gt;buffer == NULL), exception, exitNow);
<a name="l00878"></a>00878     <span class="keywordflow">if</span>(RKL_EXPECTED((stringUniChar = (RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE)CFStringGetCharactersPtr(cachedRegex-&gt;setToString)) == NULL, 0L)) { cachedRegex-&gt;setToUniChar = NULL; cachedRegex-&gt;setToRange = NSNotFoundRange; cachedRegex-&gt;setToNeedsConversion = 1U; }
<a name="l00879"></a>00879     <span class="keywordflow">else</span> { <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;setToUniChar != stringUniChar, 0L)) { cachedRegex-&gt;setToRange = NSNotFoundRange; cachedRegex-&gt;setToUniChar = stringUniChar; } <span class="keywordflow">goto</span> setRegexText; }
<a name="l00880"></a>00880   }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   buffer = cachedRegex-&gt;buffer;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   RKLCDelayedAssert((buffer == NULL) ? 1 : (((buffer == &amp;rkl_lruFixedBuffer[0])   || (buffer == &amp;rkl_lruFixedBuffer[1])   || (buffer == &amp;rkl_lruFixedBuffer[2])   || (buffer == &amp;rkl_lruFixedBuffer[3])) ||
<a name="l00885"></a>00885                                             ((buffer == &amp;rkl_lruDynamicBuffer[0]) || (buffer == &amp;rkl_lruDynamicBuffer[1]) || (buffer == &amp;rkl_lruDynamicBuffer[2]) || (buffer == &amp;rkl_lruDynamicBuffer[3]))), exception, exitNow);
<a name="l00886"></a>00886   
<a name="l00887"></a>00887   <span class="keywordflow">if</span>((buffer != NULL) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;setToString == buffer-&gt;string, 1L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;setToHash == buffer-&gt;hash, 1L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;setToLength == buffer-&gt;length, 1L)) {
<a name="l00888"></a>00888     RKLCDelayedAssert((buffer-&gt;uniChar != NULL), exception, exitNow);
<a name="l00889"></a>00889     rkl_dtrace_addLookupFlag(lookupResultFlags, RKLCacheHitLookupFlag | RKLConversionRequiredLookupFlag | (useFixedBuffer ? 0U : RKLDynamicBufferLookupFlag));
<a name="l00890"></a>00890     <span class="keywordflow">if</span>(cachedRegex-&gt;setToUniChar != buffer-&gt;uniChar) { cachedRegex-&gt;setToRange = NSNotFoundRange; cachedRegex-&gt;setToUniChar = buffer-&gt;uniChar; }
<a name="l00891"></a>00891     <span class="keywordflow">goto</span> setRegexText;
<a name="l00892"></a>00892   }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   buffer              = NULL;
<a name="l00895"></a>00895   cachedRegex-&gt;buffer = NULL;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   NSInteger cacheWay = 0L;
<a name="l00898"></a>00898   <span class="keywordflow">for</span>(cacheWay = ((NSInteger)_RKL_LRU_CACHE_SET_WAYS - 1L); cacheWay &gt; 0L; cacheWay--) {
<a name="l00899"></a>00899     <span class="keywordflow">if</span>(useFixedBuffer) { buffer = &amp;rkl_lruFixedBuffer[cacheWay]; } <span class="keywordflow">else</span> { buffer = &amp;rkl_lruDynamicBuffer[cacheWay]; }
<a name="l00900"></a>00900     <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;setToString == buffer-&gt;string, 1L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;setToHash == buffer-&gt;hash, 1L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;setToLength == buffer-&gt;length, 1L)) {
<a name="l00901"></a>00901       RKLCDelayedAssert((buffer-&gt;uniChar != NULL), exception, exitNow);
<a name="l00902"></a>00902       rkl_dtrace_addLookupFlag(lookupResultFlags, RKLCacheHitLookupFlag | RKLConversionRequiredLookupFlag | (useFixedBuffer ? 0U : RKLDynamicBufferLookupFlag));
<a name="l00903"></a>00903       <span class="keywordflow">if</span>(cachedRegex-&gt;setToUniChar != buffer-&gt;uniChar) { cachedRegex-&gt;setToRange = NSNotFoundRange; cachedRegex-&gt;setToUniChar = buffer-&gt;uniChar; }
<a name="l00904"></a>00904       cachedRegex-&gt;buffer = buffer;
<a name="l00905"></a>00905       <span class="keywordflow">goto</span> setRegexText;
<a name="l00906"></a>00906     }
<a name="l00907"></a>00907   }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   buffer                    = NULL;
<a name="l00910"></a>00910   cachedRegex-&gt;setToUniChar = NULL;
<a name="l00911"></a>00911   cachedRegex-&gt;setToRange   = NSNotFoundRange;
<a name="l00912"></a>00912   cachedRegex-&gt;buffer       = NULL;
<a name="l00913"></a>00913   
<a name="l00914"></a>00914   RKLCDelayedAssert((cachedRegex-&gt;setToNeedsConversion == 1U) &amp;&amp; (cachedRegex-&gt;buffer == NULL), exception, exitNow);
<a name="l00915"></a>00915   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;setToNeedsConversion == 1U, 1L) &amp;&amp; RKL_EXPECTED((cachedRegex-&gt;setToUniChar = (RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE)CFStringGetCharactersPtr(cachedRegex-&gt;setToString)) != NULL, 0L)) { cachedRegex-&gt;setToNeedsConversion = 0U; cachedRegex-&gt;setToRange = NSNotFoundRange; <span class="keywordflow">goto</span> setRegexText; }
<a name="l00916"></a>00916   
<a name="l00917"></a>00917   rkl_dtrace_addLookupFlag(lookupResultFlags, RKLConversionRequiredLookupFlag | (useFixedBuffer ? 0U : RKLDynamicBufferLookupFlag));
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="keywordflow">if</span>(useFixedBuffer) { buffer = &amp;rkl_lruFixedBuffer  [rkl_leastRecentlyUsedWayInSet(1UL, &amp;rkl_lruFixedBufferCacheSet,   0UL)]; }
<a name="l00920"></a>00920   <span class="keywordflow">else</span>               { buffer = &amp;rkl_lruDynamicBuffer[rkl_leastRecentlyUsedWayInSet(1UL, &amp;rkl_lruDynamicBufferCacheSet, 0UL)]; }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922   RKLCDelayedAssert((useFixedBuffer) ? ((buffer == &amp;rkl_lruFixedBuffer[0])   || (buffer == &amp;rkl_lruFixedBuffer[1])   || (buffer == &amp;rkl_lruFixedBuffer[2])   || (buffer == &amp;rkl_lruFixedBuffer[3])) :
<a name="l00923"></a>00923                                        ((buffer == &amp;rkl_lruDynamicBuffer[0]) || (buffer == &amp;rkl_lruDynamicBuffer[1]) || (buffer == &amp;rkl_lruDynamicBuffer[2]) || (buffer == &amp;rkl_lruDynamicBuffer[3])), exception, exitNow);
<a name="l00924"></a>00924   
<a name="l00925"></a>00925   rkl_clearBuffer(buffer, 0UL);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   RKLCDelayedAssert((buffer-&gt;string == NULL) &amp;&amp; (cachedRegex-&gt;setToString != NULL), exception, exitNow);
<a name="l00928"></a>00928   <span class="keywordflow">if</span>(RKL_EXPECTED((buffer-&gt;string = (CFStringRef)CFRetain((CFTypeRef)cachedRegex-&gt;setToString)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l00929"></a>00929   buffer-&gt;hash   = cachedRegex-&gt;setToHash;
<a name="l00930"></a>00930   buffer-&gt;length = cachedRegex-&gt;setToLength;
<a name="l00931"></a>00931   
<a name="l00932"></a>00932   <span class="keywordflow">if</span>(useFixedBuffer == 0UL) {
<a name="l00933"></a>00933     RKL_STRONG_REF <span class="keywordtype">void</span> * RKL_GC_VOLATILE p = (RKL_STRONG_REF <span class="keywordtype">void</span> * RKL_GC_VOLATILE)buffer-&gt;uniChar;
<a name="l00934"></a>00934     <span class="keywordflow">if</span>(RKL_EXPECTED((buffer-&gt;uniChar = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_realloc(&amp;p, ((<span class="keywordtype">size_t</span>)buffer-&gt;length * <span class="keyword">sizeof</span>(UniChar)), 0UL)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Resize the buffer.</span>
<a name="l00935"></a>00935   }
<a name="l00936"></a>00936   
<a name="l00937"></a>00937   RKLCDelayedAssert((buffer-&gt;string != NULL) &amp;&amp; (buffer-&gt;uniChar != NULL), exception, exitNow);
<a name="l00938"></a>00938   CFStringGetCharacters(buffer-&gt;string, CFMakeRange(0L, buffer-&gt;length), (UniChar *)buffer-&gt;uniChar); <span class="comment">// Convert to a UTF16 string.</span>
<a name="l00939"></a>00939   
<a name="l00940"></a>00940   cachedRegex-&gt;setToUniChar = buffer-&gt;uniChar;
<a name="l00941"></a>00941   cachedRegex-&gt;setToRange   = NSNotFoundRange;
<a name="l00942"></a>00942   cachedRegex-&gt;buffer       = buffer;
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 setRegexText:
<a name="l00945"></a>00945   <span class="keywordflow">if</span>(buffer != NULL) { <span class="keywordflow">if</span>(useFixedBuffer == 1UL) { rkl_accessCacheSetWay(1UL, &amp;rkl_lruFixedBufferCacheSet, 0UL, (NSUInteger)(buffer - rkl_lruFixedBuffer)); } <span class="keywordflow">else</span> { rkl_accessCacheSetWay(1UL, &amp;rkl_lruDynamicBufferCacheSet, 0UL, (NSUInteger)(buffer - rkl_lruDynamicBuffer)); } }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947   <span class="keywordflow">if</span>(NSEqualRanges(cachedRegex-&gt;setToRange, *range) == NO) {
<a name="l00948"></a>00948     RKLCDelayedAssert((cachedRegex-&gt;icu_regex != NULL) &amp;&amp; (cachedRegex-&gt;setToUniChar != NULL) &amp;&amp; (NSMaxRange(*range) &lt;= (NSUInteger)cachedRegex-&gt;setToLength) &amp;&amp; (cachedRegex-&gt;setToRange.length &lt;= INT_MAX), exception, exitNow);
<a name="l00949"></a>00949     cachedRegex-&gt;lastFindRange =  cachedRegex-&gt;lastMatchRange = NSNotFoundRange;
<a name="l00950"></a>00950     cachedRegex-&gt;setToRange    = *range;
<a name="l00951"></a>00951     RKL_ICU_FUNCTION_APPEND(uregex_setText)(cachedRegex-&gt;icu_regex, cachedRegex-&gt;setToUniChar + cachedRegex-&gt;setToRange.location, (int32_t)cachedRegex-&gt;setToRange.length, status);
<a name="l00952"></a>00952     rkl_dtrace_addLookupFlag(lookupResultFlags, RKLSetTextLookupFlag);
<a name="l00953"></a>00953     <span class="keywordflow">if</span>(RKL_EXPECTED(*status &gt; U_ZERO_ERROR, 0L)) { rkl_dtrace_addLookupFlag(lookupResultFlags, RKLErrorLookupFlag); <span class="keywordflow">goto</span> exitNow; }
<a name="l00954"></a>00954   }
<a name="l00955"></a>00955   
<a name="l00956"></a>00956   rkl_dtrace_utf16ConversionCache(lookupResultFlags, cachedRegex-&gt;setToString, cachedRegex-&gt;setToRange.location, cachedRegex-&gt;setToRange.length, cachedRegex-&gt;setToLength);
<a name="l00957"></a>00957 
<a name="l00958"></a>00958   <span class="keywordflow">return</span>(1UL);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="comment">//  ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l00961"></a>00961   <span class="comment">//  IMPORTANT!   This section of code is called almost every single time that any RegexKitLite functionality is used! It /MUST/ be very fast!</span>
<a name="l00962"></a>00962   <span class="comment">//  ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l00963"></a>00963   
<a name="l00964"></a>00964 exitNow:
<a name="l00965"></a>00965 <span class="preprocessor">#ifdef    _RKL_DTRACE_ENABLED</span>
<a name="l00966"></a>00966 <span class="preprocessor"></span>  rkl_dtrace_addLookupFlag(lookupResultFlags, RKLErrorLookupFlag); 
<a name="l00967"></a>00967   <span class="keywordflow">if</span>(cachedRegex != NULL) { rkl_dtrace_utf16ConversionCache(lookupResultFlags, cachedRegex-&gt;setToString, cachedRegex-&gt;setToRange.location, cachedRegex-&gt;setToRange.length, cachedRegex-&gt;setToLength); }
<a name="l00968"></a>00968 <span class="preprocessor">#endif // _RKL_DTRACE_ENABLED</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(cachedRegex != NULL) { cachedRegex-&gt;buffer = NULL; cachedRegex-&gt;setToRange = NSNotFoundRange; cachedRegex-&gt;lastFindRange = NSNotFoundRange; cachedRegex-&gt;lastMatchRange = NSNotFoundRange; }
<a name="l00970"></a>00970   <span class="keywordflow">return</span>(0UL);
<a name="l00971"></a>00971 }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l00974"></a>00974 <span class="comment">//  IMPORTANT!   Should only be called with rkl_cacheSpinLock already locked!</span>
<a name="l00975"></a>00975 <span class="comment">//  ----------</span>
<a name="l00976"></a>00976 
<a name="l00977"></a>00977 <span class="preprocessor">#pragma mark Get a regular expression and set it to a NSStrings UTF-16 text</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span>
<a name="l00979"></a>00979 <span class="keyword">static</span> <a class="code" href="a00028.html">RKLCachedRegex</a> *rkl_getCachedRegexSetToString(<a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, <a class="code" href="a00025.html">NSString</a> *matchString, NSUInteger *matchLengthPtr, NSRange *matchRange, NSError **error, <span class="keywordtype">id</span> *exception, int32_t *status) {
<a name="l00980"></a>00980   <span class="comment">//  ----------   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00981"></a>00981   <span class="comment">//  IMPORTANT!   This section of code is called almost every single time that any RegexKitLite functionality is used! It /MUST/ be very fast!</span>
<a name="l00982"></a>00982   <span class="comment">//  ----------   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv</span>
<a name="l00983"></a>00983   
<a name="l00984"></a>00984   <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex = NULL;
<a name="l00985"></a>00985   RKLCDelayedAssert((regexString != NULL) &amp;&amp; (matchString != NULL) &amp;&amp; (exception != NULL) &amp;&amp; (status != NULL) &amp;&amp; (matchLengthPtr != NULL), exception, exitNow);
<a name="l00986"></a>00986 
<a name="l00987"></a>00987   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex = rkl_getCachedRegex(regexString, options, error, exception)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l00988"></a>00988   RKLCDelayedAssert(((cachedRegex &gt;= rkl_cachedRegexes) &amp;&amp; ((cachedRegex - rkl_cachedRegexes) &lt; (ssize_t)_RKL_REGEX_CACHE_LINES)) &amp;&amp; (cachedRegex != NULL) &amp;&amp; (cachedRegex-&gt;icu_regex != NULL) &amp;&amp; (cachedRegex-&gt;regexString != NULL) &amp;&amp; (cachedRegex-&gt;captureCount &gt;= 0L) &amp;&amp; (cachedRegex == rkl_lastCachedRegex), exception, exitNow);
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   <span class="comment">// Optimize the case where the string to search (matchString) is immutable and the setToString immutable copy is the same string with its reference count incremented.</span>
<a name="l00991"></a>00991   NSUInteger isSetTo     = ((cachedRegex-&gt;setToString      == (CFStringRef)matchString)) ? 1UL : 0UL;
<a name="l00992"></a>00992   CFIndex    matchLength = ((cachedRegex-&gt;setToIsImmutable == 1U) &amp;&amp; (isSetTo == 1UL))   ? cachedRegex-&gt;setToLength : CFStringGetLength((CFStringRef)matchString);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   *matchLengthPtr = (NSUInteger)matchLength;
<a name="l00995"></a>00995   <span class="keywordflow">if</span>(matchRange-&gt;length == NSUIntegerMax) { matchRange-&gt;length = (NSUInteger)matchLength; } <span class="comment">// For convenience, allow NSUIntegerMax == string length.</span>
<a name="l00996"></a>00996   
<a name="l00997"></a>00997   <span class="keywordflow">if</span>(RKL_EXPECTED((NSUInteger)matchLength &lt; NSMaxRange(*matchRange), 0L)) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// The match range is out of bounds for the string.  performRegexOp will catch and report the problem.</span>
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   RKLCDelayedAssert((isSetTo == 1UL) ? (cachedRegex-&gt;setToString != NULL) : 1, exception, exitNow);
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   <span class="keywordflow">if</span>(((cachedRegex-&gt;setToIsImmutable == 1U) ? isSetTo : (NSUInteger)((isSetTo == 1UL) &amp;&amp; (cachedRegex-&gt;setToLength == matchLength) &amp;&amp; (cachedRegex-&gt;setToHash == CFHash((CFTypeRef)matchString)))) == 0UL) {
<a name="l01002"></a>01002     <span class="keywordflow">if</span>(cachedRegex-&gt;setToString != NULL) { rkl_clearCachedRegexSetTo(cachedRegex); }
<a name="l01003"></a>01003     
<a name="l01004"></a>01004     cachedRegex-&gt;setToString          = (CFStringRef)CFRetain((CFTypeRef)matchString);
<a name="l01005"></a>01005     RKLCDelayedAssert(cachedRegex-&gt;setToString != NULL, exception, exitNow);
<a name="l01006"></a>01006     cachedRegex-&gt;setToUniChar         = CFStringGetCharactersPtr(cachedRegex-&gt;setToString);
<a name="l01007"></a>01007     cachedRegex-&gt;setToNeedsConversion = (cachedRegex-&gt;setToUniChar == NULL) ? 1U : 0U;
<a name="l01008"></a>01008     cachedRegex-&gt;setToIsImmutable     = (rkl_CFStringIsMutable(cachedRegex-&gt;setToString) == YES) ? 0U : 1U; <span class="comment">// If RKL_FAST_MUTABLE_CHECK is not defined then setToIsImmutable will always be set to &#39;0&#39;, or in other words mutable..</span>
<a name="l01009"></a>01009     cachedRegex-&gt;setToHash            = CFHash((CFTypeRef)cachedRegex-&gt;setToString);
<a name="l01010"></a>01010     cachedRegex-&gt;setToRange           = NSNotFoundRange;
<a name="l01011"></a>01011     cachedRegex-&gt;setToLength          = matchLength;
<a name="l01012"></a>01012     
<a name="l01013"></a>01013   }
<a name="l01014"></a>01014   
<a name="l01015"></a>01015   <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_setCachedRegexToString(cachedRegex, matchRange, status, exception) == 0UL, 0L)) { cachedRegex = NULL; <span class="keywordflow">if</span>(*exception == NULL) { *exception = (id)RKLCAssertDictionary(<span class="stringliteral">@&quot;Failed to set up UTF16 buffer.&quot;</span>); } <span class="keywordflow">goto</span> exitNow; }
<a name="l01016"></a>01016   
<a name="l01017"></a>01017 exitNow:
<a name="l01018"></a>01018   <span class="keywordflow">return</span>(cachedRegex);
<a name="l01019"></a>01019   <span class="comment">//  ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l01020"></a>01020   <span class="comment">//  IMPORTANT!   This section of code is called almost every single time that any RegexKitLite functionality is used! It /MUST/ be very fast!</span>
<a name="l01021"></a>01021   <span class="comment">//  ----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="preprocessor">#pragma mark GCC cleanup __attribute__ functions that ensure the global rkl_cacheSpinLock is properly unlocked</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span><span class="preprocessor">#ifdef    RKL_HAVE_CLEANUP</span>
<a name="l01026"></a>01026 <span class="preprocessor"></span>
<a name="l01027"></a>01027 <span class="comment">// rkl_cleanup_cacheSpinLockStatus takes advantage of GCC&#39;s &#39;cleanup&#39; variable attribute.  When an &#39;auto&#39; variable with the &#39;cleanup&#39; attribute goes out of scope,</span>
<a name="l01028"></a>01028 <span class="comment">// GCC arranges to have the designated function called.  In this case, we make sure that if rkl_cacheSpinLock was locked that it was also unlocked.</span>
<a name="l01029"></a>01029 <span class="comment">// If rkl_cacheSpinLock was locked, but the rkl_cacheSpinLockStatus unlocked flag was not set, we force rkl_cacheSpinLock unlocked with a call to OSSpinLockUnlock.</span>
<a name="l01030"></a>01030 <span class="comment">// This is not a panacea for preventing mutex usage errors.  Old style ObjC exceptions will bypass the cleanup call, but newer C++ style ObjC exceptions should cause the cleanup function to be called during the stack unwind.</span>
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="comment">// We do not depend on this cleanup function being called.  It is used only as an extra safety net.  It is probably a bug in RegexKitLite if it is ever invoked and forced to take some kind of protective action.</span>
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 <span class="keyword">volatile</span> NSUInteger rkl_debugCacheSpinLockCount = 0UL;
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 <span class="keywordtype">void</span>        rkl_debugCacheSpinLock          (<span class="keywordtype">void</span>)                                            RKL_ATTRIBUTES(used, noinline, visibility(&quot;default&quot;));
<a name="l01037"></a>01037 static <span class="keywordtype">void</span> rkl_cleanup_cacheSpinLockStatus (volatile NSUInteger *rkl_cacheSpinLockStatusPtr) RKL_ATTRIBUTES(used);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="keywordtype">void</span> rkl_debugCacheSpinLock(<span class="keywordtype">void</span>) {
<a name="l01040"></a>01040   rkl_debugCacheSpinLockCount++; <span class="comment">// This is here primarily to prevent the optimizer from optimizing away the function.</span>
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_cleanup_cacheSpinLockStatus(<span class="keyword">volatile</span> NSUInteger *rkl_cacheSpinLockStatusPtr) {
<a name="l01044"></a>01044   <span class="keyword">static</span> NSUInteger didPrintForcedUnlockWarning = 0UL, didPrintNotLockedWarning = 0UL;
<a name="l01045"></a>01045   NSUInteger        rkl_cacheSpinLockStatus     = *rkl_cacheSpinLockStatusPtr;
<a name="l01046"></a>01046   
<a name="l01047"></a>01047   <span class="keywordflow">if</span>(RKL_EXPECTED((rkl_cacheSpinLockStatus &amp; RKLUnlockedCacheSpinLock) == 0UL, 0L) &amp;&amp; RKL_EXPECTED((rkl_cacheSpinLockStatus &amp; RKLLockedCacheSpinLock) != 0UL, 1L)) {
<a name="l01048"></a>01048     <span class="keywordflow">if</span>(rkl_cacheSpinLock != (OSSpinLock)0) {
<a name="l01049"></a>01049       <span class="keywordflow">if</span>(didPrintForcedUnlockWarning == 0UL) { didPrintForcedUnlockWarning = 1UL; NSLog(<span class="stringliteral">@&quot;[RegexKitLite] Unusual condition detected: Recorded that rkl_cacheSpinLock was locked, but for some reason it was not unlocked.  Forcibly unlocking rkl_cacheSpinLock. Set a breakpoint at rkl_debugCacheSpinLock to debug. This warning is only printed once.&quot;</span>); }
<a name="l01050"></a>01050       rkl_debugCacheSpinLock(); <span class="comment">// Since this is an unusual condition, offer an attempt to catch it before we unlock.</span>
<a name="l01051"></a>01051       OSSpinLockUnlock(&amp;rkl_cacheSpinLock);
<a name="l01052"></a>01052     } <span class="keywordflow">else</span> {
<a name="l01053"></a>01053       <span class="keywordflow">if</span>(didPrintNotLockedWarning    == 0UL) { didPrintNotLockedWarning    = 1UL; NSLog(<span class="stringliteral">@&quot;[RegexKitLite] Unusual condition detected: Recorded that rkl_cacheSpinLock was locked, but for some reason it was not unlocked, yet rkl_cacheSpinLock is currently not locked? Set a breakpoint at rkl_debugCacheSpinLock to debug. This warning is only printed once.&quot;</span>); }
<a name="l01054"></a>01054       rkl_debugCacheSpinLock();
<a name="l01055"></a>01055     }
<a name="l01056"></a>01056   }
<a name="l01057"></a>01057 }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="preprocessor">#endif // RKL_HAVE_CLEANUP</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span>
<a name="l01061"></a>01061 <span class="comment">// rkl_performDictionaryVarArgsOp is a front end to rkl_performRegexOp which converts a &#39;, ...&#39; varargs key/captures list and converts it in to a form that rkl_performRegexOp can use.</span>
<a name="l01062"></a>01062 <span class="comment">// All error checking of arguments is handled by rkl_performRegexOp.</span>
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 <span class="preprocessor">#pragma mark Front end function that handles varargs and calls rkl_performRegexOp with the marshaled results</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>
<a name="l01066"></a>01066 <span class="keyword">static</span> <span class="keywordtype">id</span> rkl_performDictionaryVarArgsOp(<span class="keywordtype">id</span> <span class="keyword">self</span>, <span class="keywordtype">SEL</span> _cmd, RKLRegexOp regexOp, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, NSInteger capture, <span class="keywordtype">id</span> matchString, NSRange *matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, NSError **error, <span class="keywordtype">void</span> *result, <span class="keywordtype">id</span> firstKey, va_list varArgsList) {
<a name="l01067"></a>01067   <span class="keywordtype">id</span>         captureKeys[64];
<a name="l01068"></a>01068   <span class="keywordtype">int</span>        captureKeyIndexes[64];
<a name="l01069"></a>01069   NSUInteger captureKeysCount = 0UL;
<a name="l01070"></a>01070   
<a name="l01071"></a>01071   <span class="keywordflow">if</span>(varArgsList != NULL) {
<a name="l01072"></a>01072     <span class="keywordflow">while</span>(captureKeysCount &lt; 62UL) {
<a name="l01073"></a>01073       <span class="keywordtype">id</span>  thisCaptureKey      = (captureKeysCount == 0) ? firstKey : va_arg(varArgsList, <span class="keywordtype">id</span>);
<a name="l01074"></a>01074       <span class="keywordflow">if</span>(RKL_EXPECTED(thisCaptureKey == NULL, 0L)) { <span class="keywordflow">break</span>; }
<a name="l01075"></a>01075       <span class="keywordtype">int</span> thisCaptureKeyIndex = va_arg(varArgsList, <span class="keywordtype">int</span>);
<a name="l01076"></a>01076       captureKeys[captureKeysCount]       = thisCaptureKey;
<a name="l01077"></a>01077       captureKeyIndexes[captureKeysCount] = thisCaptureKeyIndex;
<a name="l01078"></a>01078       captureKeysCount++;
<a name="l01079"></a>01079     }
<a name="l01080"></a>01080   }
<a name="l01081"></a>01081   
<a name="l01082"></a>01082   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, regexOp, regexString, options, capture, matchString, matchRange, replacementString, error, result, captureKeysCount, captureKeys, captureKeyIndexes));
<a name="l01083"></a>01083 }
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01086"></a>01086 <span class="comment">//  ----------</span>
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 <span class="preprocessor">#pragma mark Primary internal function that Objective-C methods call to perform regular expression operations</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span>
<a name="l01090"></a>01090 <span class="keyword">static</span> <span class="keywordtype">id</span> rkl_performRegexOp(<span class="keywordtype">id</span> <span class="keyword">self</span>, <span class="keywordtype">SEL</span> _cmd, RKLRegexOp regexOp, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, NSInteger capture, <span class="keywordtype">id</span> matchString, NSRange *matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, NSError **error, <span class="keywordtype">void</span> *result, NSUInteger captureKeysCount, <span class="keywordtype">id</span> captureKeys[captureKeysCount], <span class="keyword">const</span> <span class="keywordtype">int</span> captureKeyIndexes[captureKeysCount]) {
<a name="l01091"></a>01091   <span class="keyword">volatile</span> NSUInteger RKL_CLEANUP(rkl_cleanup_cacheSpinLockStatus) rkl_cacheSpinLockStatus = 0UL;
<a name="l01092"></a>01092   
<a name="l01093"></a>01093   NSUInteger replaceMutable = 0UL;
<a name="l01094"></a>01094   RKLRegexOp maskedRegexOp  = (regexOp &amp; RKLMaskOp);
<a name="l01095"></a>01095   BOOL       dictionaryOp   = ((maskedRegexOp == RKLDictionaryOfCapturesOp) || (maskedRegexOp == RKLArrayOfDictionariesOfCapturesOp)) ? YES : NO;
<a name="l01096"></a>01096   
<a name="l01097"></a>01097   if((error != NULL) &amp;&amp; (*error != NULL))                                            { *error = NULL; }
<a name="l01098"></a>01098   
<a name="l01099"></a>01099   <span class="keywordflow">if</span>(RKL_EXPECTED(regexString == NULL, 0L))                                          { RKL_RAISE_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The regular expression argument is NULL.&quot;</span>); }
<a name="l01100"></a>01100   <span class="keywordflow">if</span>(RKL_EXPECTED(matchString == NULL, 0L))                                          { RKL_RAISE_EXCEPTION(NSInternalInconsistencyException, <span class="stringliteral">@&quot;The match string argument is NULL.&quot;</span>); }
<a name="l01101"></a>01101   <span class="keywordflow">if</span>(RKL_EXPECTED(matchRange  == NULL, 0L))                                          { RKL_RAISE_EXCEPTION(NSInternalInconsistencyException, <span class="stringliteral">@&quot;The match range argument is NULL.&quot;</span>);  }
<a name="l01102"></a>01102   <span class="keywordflow">if</span>((maskedRegexOp == RKLReplaceOp) &amp;&amp; RKL_EXPECTED(replacementString == NULL, 0L)) { RKL_RAISE_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The replacement string argument is NULL.&quot;</span>); }
<a name="l01103"></a>01103   <span class="keywordflow">if</span>((dictionaryOp  == YES)          &amp;&amp; RKL_EXPECTED(captureKeys       == NULL, 0L)) { RKL_RAISE_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The keys argument is NULL.&quot;</span>);               }
<a name="l01104"></a>01104   <span class="keywordflow">if</span>((dictionaryOp  == YES)          &amp;&amp; RKL_EXPECTED(captureKeyIndexes == NULL, 0L)) { RKL_RAISE_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The captures argument is NULL.&quot;</span>);           }
<a name="l01105"></a>01105   
<a name="l01106"></a>01106   <span class="keywordtype">id</span>              resultObject    = NULL, exception = NULL;
<a name="l01107"></a>01107   int32_t         status          = U_ZERO_ERROR;
<a name="l01108"></a>01108   <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex     = NULL;
<a name="l01109"></a>01109   NSUInteger      stringU16Length = 0UL, tmpIdx = 0UL;
<a name="l01110"></a>01110   NSRange         stackRanges[2048];
<a name="l01111"></a>01111   <a class="code" href="a00029.html">RKLFindAll</a>      findAll;
<a name="l01112"></a>01112   
<a name="l01113"></a>01113   <span class="comment">// IMPORTANT!   Once we have obtained the lock, code MUST exit via &#39;goto exitNow;&#39; to unlock the lock!  NO EXCEPTIONS!</span>
<a name="l01114"></a>01114   <span class="comment">// ----------</span>
<a name="l01115"></a>01115   OSSpinLockLock(&amp;rkl_cacheSpinLock); <span class="comment">// Grab the lock and get cache entry.</span>
<a name="l01116"></a>01116   rkl_cacheSpinLockStatus |= RKLLockedCacheSpinLock;
<a name="l01117"></a>01117   rkl_dtrace_incrementEventID();
<a name="l01118"></a>01118   
<a name="l01119"></a>01119   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex = rkl_getCachedRegexSetToString(regexString, options, matchString, &amp;stringU16Length, matchRange, error, &amp;exception, &amp;status)) == NULL, 0L)) { stringU16Length = (NSUInteger)CFStringGetLength((CFStringRef)matchString); }
<a name="l01120"></a>01120   <span class="keywordflow">if</span>(RKL_EXPECTED(matchRange-&gt;length == NSUIntegerMax,           0L))                                        { matchRange-&gt;length = stringU16Length; } <span class="comment">// For convenience.</span>
<a name="l01121"></a>01121   <span class="keywordflow">if</span>(RKL_EXPECTED(stringU16Length     &lt; NSMaxRange(*matchRange), 0L) &amp;&amp; RKL_EXPECTED(exception == NULL, 1L)) { exception = (id)RKL_EXCEPTION(NSRangeException, <span class="stringliteral">@&quot;Range or index out of bounds.&quot;</span>);  <span class="keywordflow">goto</span> exitNow; }
<a name="l01122"></a>01122   <span class="keywordflow">if</span>(RKL_EXPECTED(stringU16Length    &gt;= (NSUInteger)INT_MAX,     0L) &amp;&amp; RKL_EXPECTED(exception == NULL, 1L)) { exception = (id)RKL_EXCEPTION(NSRangeException, <span class="stringliteral">@&quot;String length exceeds INT_MAX.&quot;</span>); <span class="keywordflow">goto</span> exitNow; }
<a name="l01123"></a>01123   <span class="keywordflow">if</span>(((maskedRegexOp == RKLRangeOp) || (maskedRegexOp == RKLArrayOfStringsOp)) &amp;&amp; RKL_EXPECTED(cachedRegex != NULL, 1L) &amp;&amp; (RKL_EXPECTED(capture &lt; 0L, 0L) || RKL_EXPECTED(capture &gt; cachedRegex-&gt;captureCount, 0L)) &amp;&amp; RKL_EXPECTED(exception == NULL, 1L)) { exception = (id)RKL_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The capture argument is not valid.&quot;</span>); <span class="keywordflow">goto</span> exitNow; }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="keywordflow">if</span>((dictionaryOp == YES) &amp;&amp; RKL_EXPECTED(cachedRegex != NULL, 1L) &amp;&amp; RKL_EXPECTED(exception == NULL, 1L)) {
<a name="l01126"></a>01126     <span class="keywordflow">for</span>(tmpIdx = 0UL; tmpIdx &lt; captureKeysCount; tmpIdx++) {
<a name="l01127"></a>01127       <span class="keywordflow">if</span>(RKL_EXPECTED(captureKeys[tmpIdx] == NULL, 0L)) { exception = (id)RKL_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The capture key (key %lu of %lu) is NULL.&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmpIdx + 1UL), (<span class="keywordtype">unsigned</span> long)captureKeysCount); <span class="keywordflow">break</span>; }
<a name="l01128"></a>01128       <span class="keywordflow">if</span>((RKL_EXPECTED(captureKeyIndexes[tmpIdx] &lt; 0, 0L) || RKL_EXPECTED(captureKeyIndexes[tmpIdx] &gt; cachedRegex-&gt;captureCount, 0L))) { exception = (id)RKL_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The capture argument %d (capture %lu of %lu) for key &#39;%@&#39; is not valid.&quot;</span>, captureKeyIndexes[tmpIdx], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmpIdx + 1UL), (<span class="keywordtype">unsigned</span> long)captureKeysCount, captureKeys[tmpIdx]); <span class="keywordflow">break</span>; }
<a name="l01129"></a>01129     }
<a name="l01130"></a>01130   }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex == NULL, 0L) || RKL_EXPECTED(status &gt; U_ZERO_ERROR, 0L) || RKL_EXPECTED(exception != NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01133"></a>01133   
<a name="l01134"></a>01134   RKLCDelayedAssert(((cachedRegex &gt;= rkl_cachedRegexes) &amp;&amp; ((cachedRegex - rkl_cachedRegexes) &lt; (ssize_t)_RKL_REGEX_CACHE_LINES)) &amp;&amp; (cachedRegex != NULL) &amp;&amp; (cachedRegex-&gt;icu_regex != NULL) &amp;&amp; (cachedRegex-&gt;regexString != NULL) &amp;&amp; (cachedRegex-&gt;captureCount &gt;= 0L) &amp;&amp; (cachedRegex-&gt;setToString != NULL) &amp;&amp; (cachedRegex-&gt;setToLength &gt;= 0L) &amp;&amp; (cachedRegex-&gt;setToUniChar != NULL) &amp;&amp; ((CFIndex)NSMaxRange(cachedRegex-&gt;setToRange) &lt;= cachedRegex-&gt;setToLength), &amp;exception, exitNow);
<a name="l01135"></a>01135   RKLCDelayedAssert((cachedRegex-&gt;setToNeedsConversion == 0U) ? ((cachedRegex-&gt;setToNeedsConversion == 0U) &amp;&amp; (cachedRegex-&gt;setToUniChar == CFStringGetCharactersPtr(cachedRegex-&gt;setToString))) : ((cachedRegex-&gt;buffer != NULL) &amp;&amp; (cachedRegex-&gt;setToHash == cachedRegex-&gt;buffer-&gt;hash) &amp;&amp; (cachedRegex-&gt;setToLength == cachedRegex-&gt;buffer-&gt;length) &amp;&amp; (cachedRegex-&gt;setToUniChar == cachedRegex-&gt;buffer-&gt;uniChar)), &amp;exception, exitNow);
<a name="l01136"></a>01136   
<a name="l01137"></a>01137   <span class="keywordflow">switch</span>(maskedRegexOp) {
<a name="l01138"></a>01138     <span class="keywordflow">case</span> RKLRangeOp:
<a name="l01139"></a>01139       <span class="keywordflow">if</span>((RKL_EXPECTED(rkl_search(cachedRegex, matchRange, 0UL, &amp;exception, &amp;status) == NO, 0L)) || (RKL_EXPECTED(status &gt; U_ZERO_ERROR, 0L))) { *(NSRange *)result = NSNotFoundRange; <span class="keywordflow">goto</span> exitNow; }
<a name="l01140"></a>01140       <span class="keywordflow">if</span>(RKL_EXPECTED(capture == 0L, 1L)) { *(NSRange *)result = cachedRegex-&gt;lastMatchRange; } <span class="keywordflow">else</span> { <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_getRangeForCapture(cachedRegex, &amp;status, (int32_t)capture, (NSRange *)result) &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01141"></a>01141       <span class="keywordflow">break</span>;
<a name="l01142"></a>01142       
<a name="l01143"></a>01143     <span class="keywordflow">case</span> RKLSplitOp:                         <span class="comment">// Fall-thru...</span>
<a name="l01144"></a>01144     <span class="keywordflow">case</span> RKLArrayOfStringsOp:                <span class="comment">// Fall-thru...</span>
<a name="l01145"></a>01145     <span class="keywordflow">case</span> RKLCapturesArrayOp:                 <span class="comment">// Fall-thru...</span>
<a name="l01146"></a>01146     <span class="keywordflow">case</span> RKLArrayOfCapturesOp:               <span class="comment">// Fall-thru...</span>
<a name="l01147"></a>01147     <span class="keywordflow">case</span> RKLDictionaryOfCapturesOp:          <span class="comment">// Fall-thru...</span>
<a name="l01148"></a>01148     <span class="keywordflow">case</span> RKLArrayOfDictionariesOfCapturesOp:
<a name="l01149"></a>01149       findAll = rkl_makeFindAll(stackRanges, *matchRange, 2048L, (2048UL * <span class="keyword">sizeof</span>(NSRange)), 0UL, &amp;rkl_scratchBuffer[0], &amp;rkl_scratchBuffer[1], &amp;rkl_scratchBuffer[2], &amp;rkl_scratchBuffer[3], &amp;rkl_scratchBuffer[4], 0L, capture, (((maskedRegexOp == RKLCapturesArrayOp) || (maskedRegexOp == RKLDictionaryOfCapturesOp)) ? 1L : NSIntegerMax));
<a name="l01150"></a>01150       
<a name="l01151"></a>01151       <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_findRanges(cachedRegex, regexOp, &amp;findAll, &amp;exception, &amp;status) == NO, 1L)) {
<a name="l01152"></a>01152         <span class="keywordflow">if</span>(RKL_EXPECTED(findAll.found == 0L, 0L)) { resultObject = (maskedRegexOp == RKLDictionaryOfCapturesOp) ? [NSDictionary dictionary] : [NSArray array]; }
<a name="l01153"></a>01153         <span class="keywordflow">else</span> {
<a name="l01154"></a>01154           <span class="keywordflow">if</span>(dictionaryOp == YES) { resultObject = rkl_makeDictionary (cachedRegex, regexOp, &amp;findAll, captureKeysCount, captureKeys, captureKeyIndexes, &amp;exception); }
<a name="l01155"></a>01155           <span class="keywordflow">else</span>                    { resultObject = rkl_makeArray      (cachedRegex, regexOp, &amp;findAll, &amp;exception); }
<a name="l01156"></a>01156         }
<a name="l01157"></a>01157       }
<a name="l01158"></a>01158       
<a name="l01159"></a>01159       <span class="keywordflow">for</span>(tmpIdx = 0UL; tmpIdx &lt; _RKL_SCRATCH_BUFFERS; tmpIdx++) { <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_scratchBuffer[tmpIdx] != NULL, 0L)) { rkl_scratchBuffer[tmpIdx] = rkl_free(&amp;rkl_scratchBuffer[tmpIdx]); } }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161       <span class="keywordflow">break</span>;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     <span class="keywordflow">case</span> RKLReplaceOp: resultObject = rkl_replaceString(cachedRegex, matchString, stringU16Length, replacementString, (NSUInteger)CFStringGetLength((CFStringRef)replacementString), (NSInteger *)result, (replaceMutable = (((regexOp &amp; RKLReplaceMutable) != 0) ? 1UL : 0UL)), &amp;exception, &amp;status); <span class="keywordflow">break</span>;
<a name="l01164"></a>01164 
<a name="l01165"></a>01165     <span class="keywordflow">default</span>:           exception    = RKLCAssertDictionary(<span class="stringliteral">@&quot;Unknown regexOp code.&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01166"></a>01166   }
<a name="l01167"></a>01167   
<a name="l01168"></a>01168 exitNow:
<a name="l01169"></a>01169   OSSpinLockUnlock(&amp;rkl_cacheSpinLock);
<a name="l01170"></a>01170   rkl_cacheSpinLockStatus |= RKLUnlockedCacheSpinLock; <span class="comment">// Warning about rkl_cacheSpinLockStatus never being read can be safely ignored.</span>
<a name="l01171"></a>01171   
<a name="l01172"></a>01172   <span class="keywordflow">if</span>(RKL_EXPECTED(status     &gt; U_ZERO_ERROR, 0L) &amp;&amp; RKL_EXPECTED(exception == NULL, 0L)) { exception = rkl_NSExceptionForRegex(regexString, options, NULL, status); } <span class="comment">// If we had a problem, prepare an exception to be thrown.</span>
<a name="l01173"></a>01173   <span class="keywordflow">if</span>(RKL_EXPECTED(exception != NULL,         0L))                                        { rkl_handleDelayedAssert(<span class="keyword">self</span>, _cmd, exception);                          } <span class="comment">// If there is an exception, throw it at this point.</span>
<a name="l01174"></a>01174   <span class="comment">// If we&#39;re working on a mutable string and there were successful matches/replacements, then we still have work to do.</span>
<a name="l01175"></a>01175   <span class="comment">// This is done outside the cache lock and with the objc replaceCharactersInRange:withString: method because Core Foundation</span>
<a name="l01176"></a>01176   <span class="comment">// does not assert that the string we are attempting to update is actually a mutable string, whereas Foundation ensures</span>
<a name="l01177"></a>01177   <span class="comment">// the object receiving the message is a mutable string and throws an exception if we&#39;re attempting to modify an immutable string.</span>
<a name="l01178"></a>01178   <span class="keywordflow">if</span>(RKL_EXPECTED(replaceMutable == 1UL, 0L) &amp;&amp; RKL_EXPECTED(*((NSInteger *)result) &gt; 0L, 1L) &amp;&amp; RKL_EXPECTED(status == U_ZERO_ERROR, 1L) &amp;&amp; RKL_EXPECTED(resultObject != NULL, 1L)) { [matchString replaceCharactersInRange:*matchRange withString:resultObject]; }
<a name="l01179"></a>01179   <span class="comment">// If status &lt; U_ZERO_ERROR, consider it an error, even though status &lt; U_ZERO_ERROR is a &#39;warning&#39; in ICU nomenclature.</span>
<a name="l01180"></a>01180   <span class="comment">// status &gt; U_ZERO_ERROR are an exception and handled above.</span>
<a name="l01181"></a>01181   <span class="comment">// http://sourceforge.net/tracker/?func=detail&amp;atid=990188&amp;aid=2890810&amp;group_id=204582</span>
<a name="l01182"></a>01182   <span class="keywordflow">if</span>(RKL_EXPECTED(status  &lt; U_ZERO_ERROR, 0L) &amp;&amp; RKL_EXPECTED(resultObject == NULL, 0L) &amp;&amp; (error != NULL)) {
<a name="l01183"></a>01183     <a class="code" href="a00025.html">NSString</a> *replacedString = NULL;
<a name="l01184"></a>01184     NSInteger replacedCount = 0L;
<a name="l01185"></a>01185     RKLUserInfoOptions userInfoOptions = RKLUserInfoNone;
<a name="l01186"></a>01186     <span class="keywordflow">if</span>((maskedRegexOp == RKLReplaceOp) &amp;&amp; (result != NULL)) { userInfoOptions |= RKLUserInfoReplacedCount; replacedString = resultObject; replacedCount = *((NSInteger *)result); }
<a name="l01187"></a>01187     <span class="keywordflow">if</span>(matchRange != NULL) { userInfoOptions |= RKLUserInfoSubjectRange; }
<a name="l01188"></a>01188     *error = rkl_makeNSError(userInfoOptions, regexString, options, NULL, status, matchString, (matchRange != NULL) ? *matchRange : NSNotFoundRange, replacementString, replacedString, replacedCount, (RKLRegexEnumerationOptions)RKLRegexEnumerationNoOptions, <span class="stringliteral">@&quot;The ICU library returned an unexpected error.&quot;</span>);
<a name="l01189"></a>01189   }
<a name="l01190"></a>01190   <span class="keywordflow">return</span>(resultObject);
<a name="l01191"></a>01191 }
<a name="l01192"></a>01192 
<a name="l01193"></a>01193 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_handleDelayedAssert(<span class="keywordtype">id</span> <span class="keyword">self</span>, <span class="keywordtype">SEL</span> _cmd, <span class="keywordtype">id</span> exception) {
<a name="l01194"></a>01194   <span class="keywordflow">if</span>(RKL_EXPECTED(exception != NULL, 1L)) {
<a name="l01195"></a>01195     <span class="keywordflow">if</span>([exception isKindOfClass:[NSException <span class="keyword">class</span>]]) { [[NSException exceptionWithName:[exception name] reason:rkl_stringFromClassAndMethod(self, _cmd, [exception reason]) userInfo:[exception userInfo]] raise]; }
<a name="l01196"></a>01196     <span class="keywordflow">else</span> {
<a name="l01197"></a>01197       <span class="keywordtype">id</span> functionString = [exception objectForKey:@&quot;function&quot;], fileString = [exception objectForKey:@&quot;file&quot;], descriptionString = [exception objectForKey:@&quot;description&quot;], lineNumber = [exception objectForKey:@&quot;line&quot;];
<a name="l01198"></a>01198       RKLCHardAbortAssert((functionString != NULL) &amp;&amp; (fileString != NULL) &amp;&amp; (descriptionString != NULL) &amp;&amp; (lineNumber != NULL));
<a name="l01199"></a>01199       [[NSAssertionHandler currentHandler] handleFailureInFunction:functionString file:fileString lineNumber:(NSInteger)[lineNumber longValue] description:descriptionString];
<a name="l01200"></a>01200     }
<a name="l01201"></a>01201   }
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01205"></a>01205 <span class="comment">//  IMPORTANT!   Should only be called from rkl_performRegexOp() or rkl_findRanges().</span>
<a name="l01206"></a>01206 <span class="comment">//  ----------</span>
<a name="l01207"></a>01207 
<a name="l01208"></a>01208 <span class="preprocessor">#pragma mark Primary means of performing a search with a regular expression</span>
<a name="l01209"></a>01209 <span class="preprocessor"></span>
<a name="l01210"></a>01210 <span class="keyword">static</span> NSUInteger rkl_search(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, NSRange *searchRange, NSUInteger updateSearchRange, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG, int32_t *status) {
<a name="l01211"></a>01211   NSUInteger foundMatch = 0UL;
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keywordflow">if</span>((NSEqualRanges(*searchRange, cachedRegex-&gt;lastFindRange) == YES) &amp;&amp; ((cachedRegex-&gt;lastMatchRange.length &gt; 0UL) || (cachedRegex-&gt;lastMatchRange.location == (NSUInteger)NSNotFound))) { foundMatch = ((cachedRegex-&gt;lastMatchRange.location == (NSUInteger)NSNotFound) ? 0UL : 1UL);}
<a name="l01214"></a>01214   <span class="keywordflow">else</span> { <span class="comment">// Only perform an expensive &#39;find&#39; operation iff the current find range is different than the last find range.</span>
<a name="l01215"></a>01215     NSUInteger findLocation = (searchRange-&gt;location - cachedRegex-&gt;setToRange.location);
<a name="l01216"></a>01216     RKLCDelayedAssert(((searchRange-&gt;location &gt;= cachedRegex-&gt;setToRange.location)) &amp;&amp; (NSRangeInsideRange(*searchRange, cachedRegex-&gt;setToRange) == YES) &amp;&amp; (findLocation &lt; INT_MAX) &amp;&amp; (findLocation &lt;= cachedRegex-&gt;setToRange.length), exception, exitNow);
<a name="l01217"></a>01217     
<a name="l01218"></a>01218     RKL_PREFETCH_UNICHAR(cachedRegex-&gt;setToUniChar, searchRange-&gt;location); <span class="comment">// Spool up the CPU caches.</span>
<a name="l01219"></a>01219     
<a name="l01220"></a>01220     <span class="comment">// Using uregex_findNext can be a slight performance win.</span>
<a name="l01221"></a>01221     NSUInteger useFindNext = (RKL_EXPECTED(searchRange-&gt;location == (NSMaxRange(cachedRegex-&gt;lastMatchRange) + ((RKL_EXPECTED(cachedRegex-&gt;lastMatchRange.length == 0UL, 0L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;lastMatchRange.location &lt; NSMaxRange(cachedRegex-&gt;setToRange), 0L)) ? 1UL : 0UL)), 1L) ? 1UL : 0UL);
<a name="l01222"></a>01222 
<a name="l01223"></a>01223     cachedRegex-&gt;lastFindRange = *searchRange;
<a name="l01224"></a>01224     <span class="keywordflow">if</span>(RKL_EXPECTED(useFindNext == 0UL, 0L)) { <span class="keywordflow">if</span>(RKL_EXPECTED((RKL_ICU_FUNCTION_APPEND(uregex_find)    (cachedRegex-&gt;icu_regex, (int32_t)findLocation, status) == NO), 0L) || RKL_EXPECTED(*status &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> finishedFind; } }
<a name="l01225"></a>01225     <span class="keywordflow">else</span> {                                     <span class="keywordflow">if</span>(RKL_EXPECTED((RKL_ICU_FUNCTION_APPEND(uregex_findNext)(cachedRegex-&gt;icu_regex,                        status) == NO), 0L) || RKL_EXPECTED(*status &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> finishedFind; } }
<a name="l01226"></a>01226     foundMatch = 1UL; 
<a name="l01227"></a>01227     
<a name="l01228"></a>01228     <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_getRangeForCapture(cachedRegex, status, 0, &amp;cachedRegex-&gt;lastMatchRange) &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> finishedFind; }
<a name="l01229"></a>01229     RKLCDelayedAssert(NSRangeInsideRange(cachedRegex-&gt;lastMatchRange, *searchRange) == YES, exception, exitNow);
<a name="l01230"></a>01230   }
<a name="l01231"></a>01231   
<a name="l01232"></a>01232 finishedFind:
<a name="l01233"></a>01233   <span class="keywordflow">if</span>(RKL_EXPECTED(*status &gt; U_ZERO_ERROR, 0L)) { foundMatch = 0UL; cachedRegex-&gt;lastFindRange = NSNotFoundRange; }
<a name="l01234"></a>01234   
<a name="l01235"></a>01235   <span class="keywordflow">if</span>(RKL_EXPECTED(foundMatch == 0UL, 0L)) { cachedRegex-&gt;lastFindRange = NSNotFoundRange; cachedRegex-&gt;lastMatchRange = NSNotFoundRange; <span class="keywordflow">if</span>(RKL_EXPECTED(updateSearchRange == 1UL, 1L)) { *searchRange = NSMakeRange(NSMaxRange(*searchRange), 0UL); } }
<a name="l01236"></a>01236   <span class="keywordflow">else</span> {
<a name="l01237"></a>01237     RKLCDelayedAssert(NSRangeInsideRange(cachedRegex-&gt;lastMatchRange, *searchRange) == YES, exception, exitNow);
<a name="l01238"></a>01238     <span class="keywordflow">if</span>(RKL_EXPECTED(updateSearchRange == 1UL, 1L)) {
<a name="l01239"></a>01239       NSUInteger nextLocation = (NSMaxRange(cachedRegex-&gt;lastMatchRange) + ((RKL_EXPECTED(cachedRegex-&gt;lastMatchRange.length == 0UL, 0L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;lastMatchRange.location &lt; NSMaxRange(cachedRegex-&gt;setToRange), 1L)) ? 1UL : 0UL)), locationDiff = nextLocation - searchRange-&gt;location;
<a name="l01240"></a>01240       RKLCDelayedAssert((((locationDiff &gt; 0UL) || ((locationDiff == 0UL) &amp;&amp; (cachedRegex-&gt;lastMatchRange.location == NSMaxRange(cachedRegex-&gt;setToRange)))) &amp;&amp; (locationDiff &lt;= searchRange-&gt;length)), exception, exitNow);
<a name="l01241"></a>01241       searchRange-&gt;location  = nextLocation;
<a name="l01242"></a>01242       searchRange-&gt;length   -= locationDiff;
<a name="l01243"></a>01243     }
<a name="l01244"></a>01244   }
<a name="l01245"></a>01245   
<a name="l01246"></a>01246 <span class="preprocessor">#ifndef NS_BLOCK_ASSERTIONS</span>
<a name="l01247"></a>01247 <span class="preprocessor"></span>exitNow:
<a name="l01248"></a>01248 <span class="preprocessor">#endif</span>
<a name="l01249"></a>01249 <span class="preprocessor"></span>  <span class="keywordflow">return</span>(foundMatch);
<a name="l01250"></a>01250 }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01253"></a>01253 <span class="comment">//  IMPORTANT!   Should only be called from rkl_performRegexOp() or rkl_performEnumerationUsingBlock().</span>
<a name="l01254"></a>01254 <span class="comment">//  ----------</span>
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 <span class="preprocessor">#pragma mark Used to perform multiple searches at once and return the NSRange results in bulk</span>
<a name="l01257"></a>01257 <span class="preprocessor"></span>
<a name="l01258"></a>01258 <span class="keyword">static</span> BOOL rkl_findRanges(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKLRegexOp regexOp, <a class="code" href="a00029.html">RKLFindAll</a> *findAll, <span class="keywordtype">id</span> *exception, int32_t *status) {
<a name="l01259"></a>01259   BOOL returnWithError = YES;
<a name="l01260"></a>01260   RKLCDelayedAssert((((cachedRegex != NULL) &amp;&amp; (cachedRegex-&gt;icu_regex != NULL) &amp;&amp; (cachedRegex-&gt;setToUniChar != NULL) &amp;&amp; (cachedRegex-&gt;captureCount &gt;= 0L) &amp;&amp; (cachedRegex-&gt;setToRange.location != (NSUInteger)NSNotFound)) &amp;&amp; (status != NULL) &amp;&amp; ((findAll != NULL) &amp;&amp; (findAll-&gt;found == 0L) &amp;&amp; (findAll-&gt;addedSplitRanges == 0L) &amp;&amp; ((findAll-&gt;capacity &gt;= 0L) &amp;&amp; (((findAll-&gt;capacity &gt; 0L) || (findAll-&gt;size &gt; 0UL)) ? ((findAll-&gt;ranges != NULL) &amp;&amp; (findAll-&gt;capacity &gt; 0L) &amp;&amp; (findAll-&gt;size &gt; 0UL)) : 1)) &amp;&amp; ((findAll-&gt;capture &gt;= 0L) &amp;&amp; (findAll-&gt;capture &lt;= cachedRegex-&gt;captureCount)))), exception, exitNow);
<a name="l01261"></a>01261   
<a name="l01262"></a>01262   NSInteger  captureCount  = cachedRegex-&gt;captureCount, findAllRangeIndexOfLastNonZeroLength = 0L;
<a name="l01263"></a>01263   NSUInteger lastLocation  = findAll-&gt;findInRange.location;
<a name="l01264"></a>01264   RKLRegexOp maskedRegexOp = (regexOp &amp; RKLMaskOp);
<a name="l01265"></a>01265   NSRange    searchRange   = findAll-&gt;findInRange;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267   <span class="keywordflow">for</span>(findAll-&gt;found = 0L; (findAll-&gt;found &lt; findAll-&gt;findUpTo) &amp;&amp; ((findAll-&gt;found &lt; findAll-&gt;capacity) || (findAll-&gt;found == 0L)); findAll-&gt;found++) {
<a name="l01268"></a>01268     NSInteger loopCapture, shouldBreak = 0L;
<a name="l01269"></a>01269 
<a name="l01270"></a>01270     <span class="keywordflow">if</span>(RKL_EXPECTED(findAll-&gt;found &gt;= ((findAll-&gt;capacity - ((captureCount + 2L) * 4L)) - 4L), 0L)) { <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_growFindRanges(cachedRegex, lastLocation, findAll, exception) == 0UL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01271"></a>01271     
<a name="l01272"></a>01272     RKLCDelayedAssert((searchRange.location != (NSUInteger)NSNotFound) &amp;&amp; (NSRangeInsideRange(searchRange, cachedRegex-&gt;setToRange) == YES) &amp;&amp; (NSRangeInsideRange(findAll-&gt;findInRange, cachedRegex-&gt;setToRange) == YES), exception, exitNow);
<a name="l01273"></a>01273     
<a name="l01274"></a>01274     <span class="comment">// This fixes a &#39;bug&#39; that is also present in ICU&#39;s uregex_split().  &#39;Bug&#39;, in this case, means that the results of a split operation can differ from those that perl&#39;s split() creates for the same input.</span>
<a name="l01275"></a>01275     <span class="comment">// &quot;I|at|ice I eat rice&quot; split using the regex &quot;\b\s*&quot; demonstrates the problem. ICU bug http://bugs.icu-project.org/trac/ticket/6826</span>
<a name="l01276"></a>01276     <span class="comment">// ICU : &quot;&quot;, &quot;I&quot;, &quot;|&quot;, &quot;at&quot;, &quot;|&quot;, &quot;ice&quot;, &quot;&quot;, &quot;I&quot;, &quot;&quot;, &quot;eat&quot;, &quot;&quot;, &quot;rice&quot; &lt;- Results that RegexKitLite used to produce.</span>
<a name="l01277"></a>01277     <span class="comment">// PERL:     &quot;I&quot;, &quot;|&quot;, &quot;at&quot;, &quot;|&quot;, &quot;ice&quot;,     &quot;I&quot;,     &quot;eat&quot;,     &quot;rice&quot; &lt;- Results that RegexKitLite now produces.</span>
<a name="l01278"></a>01278     <span class="keywordflow">do</span> { <span class="keywordflow">if</span>((rkl_search(cachedRegex, &amp;searchRange, 1UL, exception, status) == NO) || (RKL_EXPECTED(*status &gt; U_ZERO_ERROR, 0L))) { shouldBreak = 1L; } findAll-&gt;remainingRange = searchRange; }
<a name="l01279"></a>01279     <span class="keywordflow">while</span>(RKL_EXPECTED((cachedRegex-&gt;lastMatchRange.location - lastLocation) == 0UL, 0L) &amp;&amp; RKL_EXPECTED(cachedRegex-&gt;lastMatchRange.length == 0UL, 0L) &amp;&amp; (maskedRegexOp == RKLSplitOp) &amp;&amp; RKL_EXPECTED(shouldBreak == 0L, 1L));
<a name="l01280"></a>01280     <span class="keywordflow">if</span>(RKL_EXPECTED(shouldBreak == 1L, 0L)) { <span class="keywordflow">break</span>; }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     RKLCDelayedAssert((searchRange.location != (NSUInteger)NSNotFound) &amp;&amp; (NSRangeInsideRange(searchRange, cachedRegex-&gt;setToRange) == YES) &amp;&amp; (NSRangeInsideRange(findAll-&gt;findInRange, cachedRegex-&gt;setToRange) == YES) &amp;&amp; (NSRangeInsideRange(searchRange, findAll-&gt;findInRange) == YES), exception, exitNow);
<a name="l01283"></a>01283     RKLCDelayedAssert((NSRangeInsideRange(cachedRegex-&gt;lastFindRange, cachedRegex-&gt;setToRange) == YES) &amp;&amp; (NSRangeInsideRange(cachedRegex-&gt;lastMatchRange, cachedRegex-&gt;setToRange) == YES) &amp;&amp; (NSRangeInsideRange(cachedRegex-&gt;lastMatchRange, findAll-&gt;findInRange) == YES), exception, exitNow);
<a name="l01284"></a>01284     RKLCDelayedAssert((findAll-&gt;ranges != NULL) &amp;&amp; (findAll-&gt;found &gt;= 0L) &amp;&amp; (findAll-&gt;capacity &gt;= 0L) &amp;&amp; ((findAll-&gt;found + (captureCount + 3L) + 1L) &lt; (findAll-&gt;capacity - 2L)), exception, exitNow);
<a name="l01285"></a>01285     
<a name="l01286"></a>01286     NSInteger findAllRangesIndexForCapture0 = findAll-&gt;found;
<a name="l01287"></a>01287     <span class="keywordflow">switch</span>(maskedRegexOp) {
<a name="l01288"></a>01288       <span class="keywordflow">case</span> RKLArrayOfStringsOp:
<a name="l01289"></a>01289         <span class="keywordflow">if</span>(findAll-&gt;capture == 0L) { findAll-&gt;ranges[findAll-&gt;found] = cachedRegex-&gt;lastMatchRange; } <span class="keywordflow">else</span> { <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_getRangeForCapture(cachedRegex, status, (int32_t)findAll-&gt;capture, &amp;findAll-&gt;ranges[findAll-&gt;found]) &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01290"></a>01290         <span class="keywordflow">break</span>;
<a name="l01291"></a>01291         
<a name="l01292"></a>01292       <span class="keywordflow">case</span> RKLSplitOp:                         <span class="comment">// Fall-thru...</span>
<a name="l01293"></a>01293       <span class="keywordflow">case</span> RKLCapturesArrayOp:                 <span class="comment">// Fall-thru...</span>
<a name="l01294"></a>01294       <span class="keywordflow">case</span> RKLDictionaryOfCapturesOp:          <span class="comment">// Fall-thru...</span>
<a name="l01295"></a>01295       <span class="keywordflow">case</span> RKLArrayOfDictionariesOfCapturesOp: <span class="comment">// Fall-thru...</span>
<a name="l01296"></a>01296       <span class="keywordflow">case</span> RKLArrayOfCapturesOp:
<a name="l01297"></a>01297         findAll-&gt;ranges[findAll-&gt;found] = ((maskedRegexOp == RKLSplitOp) ? NSMakeRange(lastLocation, cachedRegex-&gt;lastMatchRange.location - lastLocation) : cachedRegex-&gt;lastMatchRange);
<a name="l01298"></a>01298 
<a name="l01299"></a>01299         <span class="keywordflow">for</span>(loopCapture = 1L; loopCapture &lt;= captureCount; loopCapture++) {
<a name="l01300"></a>01300           RKLCDelayedAssert((findAll-&gt;found &gt;= 0L) &amp;&amp; (findAll-&gt;found &lt; (findAll-&gt;capacity - 2L)) &amp;&amp; (loopCapture &lt; INT_MAX), exception, exitNow);
<a name="l01301"></a>01301           <span class="keywordflow">if</span>(RKL_EXPECTED(rkl_getRangeForCapture(cachedRegex, status, (int32_t)loopCapture, &amp;findAll-&gt;ranges[++findAll-&gt;found]) &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01302"></a>01302         }
<a name="l01303"></a>01303         <span class="keywordflow">break</span>;
<a name="l01304"></a>01304         
<a name="l01305"></a>01305       <span class="keywordflow">default</span>: <span class="keywordflow">if</span>(*exception == NULL) { *exception = RKLCAssertDictionary(<span class="stringliteral">@&quot;Unknown regexOp.&quot;</span>); } <span class="keywordflow">goto</span> exitNow; <span class="keywordflow">break</span>;
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307     
<a name="l01308"></a>01308     <span class="keywordflow">if</span>(findAll-&gt;ranges[findAllRangesIndexForCapture0].length &gt; 0UL) { findAllRangeIndexOfLastNonZeroLength = findAll-&gt;found + 1UL; }
<a name="l01309"></a>01309     lastLocation = NSMaxRange(cachedRegex-&gt;lastMatchRange);
<a name="l01310"></a>01310   }
<a name="l01311"></a>01311   
<a name="l01312"></a>01312   <span class="keywordflow">if</span>(RKL_EXPECTED(*status &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01313"></a>01313   
<a name="l01314"></a>01314   RKLCDelayedAssert((findAll-&gt;ranges != NULL) &amp;&amp; (findAll-&gt;found &gt;= 0L) &amp;&amp; (findAll-&gt;found &lt; (findAll-&gt;capacity - 2L)), exception, exitNow);
<a name="l01315"></a>01315   <span class="keywordflow">if</span>(maskedRegexOp == RKLSplitOp) {
<a name="l01316"></a>01316     <span class="keywordflow">if</span>(lastLocation != NSMaxRange(findAll-&gt;findInRange)) { findAll-&gt;addedSplitRanges++; findAll-&gt;ranges[findAll-&gt;found++] = NSMakeRange(lastLocation, NSMaxRange(findAll-&gt;findInRange) - lastLocation); findAllRangeIndexOfLastNonZeroLength = findAll-&gt;found; }
<a name="l01317"></a>01317     findAll-&gt;found = findAllRangeIndexOfLastNonZeroLength;
<a name="l01318"></a>01318   }
<a name="l01319"></a>01319   
<a name="l01320"></a>01320   RKLCDelayedAssert((findAll-&gt;ranges != NULL) &amp;&amp; (findAll-&gt;found &gt;= 0L) &amp;&amp; (findAll-&gt;found &lt; (findAll-&gt;capacity - 2L)), exception, exitNow);
<a name="l01321"></a>01321   returnWithError = NO;
<a name="l01322"></a>01322   
<a name="l01323"></a>01323 exitNow:
<a name="l01324"></a>01324   <span class="keywordflow">return</span>(returnWithError);
<a name="l01325"></a>01325 }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01328"></a>01328 <span class="comment">//  IMPORTANT!   Should only be called from rkl_findRanges().</span>
<a name="l01329"></a>01329 <span class="comment">//  ----------</span>
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="keyword">static</span> NSUInteger rkl_growFindRanges(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, NSUInteger lastLocation, <a class="code" href="a00029.html">RKLFindAll</a> *findAll, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG) {
<a name="l01332"></a>01332   NSUInteger didGrowRanges = 0UL;
<a name="l01333"></a>01333   RKLCDelayedAssert((((cachedRegex != NULL) &amp;&amp; (cachedRegex-&gt;captureCount &gt;= 0L)) &amp;&amp; ((findAll != NULL) &amp;&amp; (findAll-&gt;capacity &gt;= 0L) &amp;&amp; (findAll-&gt;rangesScratchBuffer != NULL) &amp;&amp; (findAll-&gt;found &gt;= 0L) &amp;&amp; (((findAll-&gt;capacity &gt; 0L) || (findAll-&gt;size &gt; 0UL) || (findAll-&gt;ranges != NULL)) ? ((findAll-&gt;capacity &gt; 0L) &amp;&amp; (findAll-&gt;size &gt; 0UL) &amp;&amp; (findAll-&gt;ranges != NULL) &amp;&amp; (((<span class="keywordtype">size_t</span>)findAll-&gt;capacity * <span class="keyword">sizeof</span>(NSRange)) == findAll-&gt;size)) : 1))), exception, exitNow);
<a name="l01334"></a>01334   
<a name="l01335"></a>01335   <span class="comment">// Attempt to guesstimate the required capacity based on: the total length needed to search / (length we&#39;ve searched so far / ranges found so far).</span>
<a name="l01336"></a>01336   NSInteger newCapacity = (findAll-&gt;capacity + (findAll-&gt;capacity / 2L)), estimate = (NSInteger)((float)cachedRegex-&gt;setToLength / (((float)lastLocation + 1.0f) / ((float)findAll-&gt;found + 1.0f)));
<a name="l01337"></a>01337   newCapacity = (((newCapacity + ((estimate &gt; newCapacity) ? estimate : newCapacity)) / 2L) + ((cachedRegex-&gt;captureCount + 2L) * 4L) + 4L);
<a name="l01338"></a>01338   
<a name="l01339"></a>01339   NSUInteger                               needToCopy = ((*findAll-&gt;rangesScratchBuffer != findAll-&gt;ranges) &amp;&amp; (findAll-&gt;ranges != NULL)) ? 1UL : 0UL; <span class="comment">// If findAll-&gt;ranges is set to a stack allocation then we need to manually copy the data from the stack to the new heap allocation.</span>
<a name="l01340"></a>01340   <span class="keywordtype">size_t</span>                                   newSize    = ((size_t)newCapacity * <span class="keyword">sizeof</span>(NSRange));
<a name="l01341"></a>01341   RKL_STRONG_REF NSRange * RKL_GC_VOLATILE newRanges  = NULL;
<a name="l01342"></a>01342   
<a name="l01343"></a>01343   <span class="keywordflow">if</span>(RKL_EXPECTED((newRanges = (RKL_STRONG_REF NSRange * RKL_GC_VOLATILE)rkl_realloc((RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE)findAll-&gt;rangesScratchBuffer, newSize, 0UL)) == NULL, 0L)) { findAll-&gt;capacity = 0L; findAll-&gt;size = 0UL; findAll-&gt;ranges = NULL; *findAll-&gt;rangesScratchBuffer = rkl_free((RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE)findAll-&gt;rangesScratchBuffer); <span class="keywordflow">goto</span> exitNow; } <span class="keywordflow">else</span> { didGrowRanges = 1UL; }
<a name="l01344"></a>01344   <span class="keywordflow">if</span>(needToCopy == 1UL) { memcpy(newRanges, findAll-&gt;ranges, findAll-&gt;size); } <span class="comment">// If necessary, copy the existing data to the new heap allocation.</span>
<a name="l01345"></a>01345   
<a name="l01346"></a>01346   findAll-&gt;capacity = newCapacity;
<a name="l01347"></a>01347   findAll-&gt;size     = newSize;
<a name="l01348"></a>01348   findAll-&gt;ranges   = newRanges;
<a name="l01349"></a>01349   
<a name="l01350"></a>01350 exitNow:
<a name="l01351"></a>01351   <span class="keywordflow">return</span>(didGrowRanges);
<a name="l01352"></a>01352 }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01355"></a>01355 <span class="comment">//  IMPORTANT!   Should only be called from rkl_performRegexOp().</span>
<a name="l01356"></a>01356 <span class="comment">//  ----------</span>
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="preprocessor">#pragma mark Convert bulk results from rkl_findRanges in to various NSArray types</span>
<a name="l01359"></a>01359 <span class="preprocessor"></span>
<a name="l01360"></a>01360 <span class="keyword">static</span> NSArray *rkl_makeArray(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKLRegexOp regexOp, <a class="code" href="a00029.html">RKLFindAll</a> *findAll, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG) {
<a name="l01361"></a>01361   NSUInteger  createdStringsCount = 0UL,   createdArraysCount = 0UL,  transferredStringsCount = 0UL;
<a name="l01362"></a>01362   <span class="keywordtype">id</span>         * RKL_GC_VOLATILE matchedStrings = NULL, * RKL_GC_VOLATILE subcaptureArrays = NULL, emptyString = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l01363"></a>01363   NSArray    * RKL_GC_VOLATILE resultArray    = NULL;
<a name="l01364"></a>01364   
<a name="l01365"></a>01365   RKLCDelayedAssert((cachedRegex != NULL) &amp;&amp; ((findAll != NULL) &amp;&amp; (findAll-&gt;found &gt;= 0L) &amp;&amp; (findAll-&gt;stringsScratchBuffer != NULL) &amp;&amp; (findAll-&gt;arraysScratchBuffer != NULL)), exception, exitNow);
<a name="l01366"></a>01366   
<a name="l01367"></a>01367   <span class="keywordtype">size_t</span>      matchedStringsSize = ((size_t)findAll-&gt;found * <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>));
<a name="l01368"></a>01368   CFStringRef setToString        = cachedRegex-&gt;setToString;
<a name="l01369"></a>01369   
<a name="l01370"></a>01370   <span class="keywordflow">if</span>((findAll-&gt;stackUsed + matchedStringsSize) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((matchedStrings = (<span class="keywordtype">id</span> * RKL_GC_VOLATILE)alloca(matchedStringsSize))                                                                   == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } findAll-&gt;stackUsed += matchedStringsSize; }
<a name="l01371"></a>01371   <span class="keywordflow">else</span> {                                                                     <span class="keywordflow">if</span>(RKL_EXPECTED((matchedStrings = (<span class="keywordtype">id</span> * RKL_GC_VOLATILE)rkl_realloc(findAll-&gt;stringsScratchBuffer, matchedStringsSize, (NSUInteger)RKLScannedOption)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01372"></a>01372   
<a name="l01373"></a>01373   { <span class="comment">// This sub-block (and its local variables) is here for the benefit of the optimizer.</span>
<a name="l01374"></a>01374     NSUInteger     found             = (NSUInteger)findAll-&gt;found;
<a name="l01375"></a>01375     <span class="keyword">const</span> NSRange *rangePtr          = findAll-&gt;ranges;
<a name="l01376"></a>01376     <span class="keywordtype">id</span>            *matchedStringsPtr = matchedStrings;
<a name="l01377"></a>01377     
<a name="l01378"></a>01378     <span class="keywordflow">for</span>(createdStringsCount = 0UL; createdStringsCount &lt; found; createdStringsCount++) {
<a name="l01379"></a>01379       NSRange range = *rangePtr++;
<a name="l01380"></a>01380       <span class="keywordflow">if</span>(RKL_EXPECTED(((*matchedStringsPtr++ = RKL_EXPECTED(range.length == 0UL, 0L) ? emptyString : rkl_CreateStringWithSubstring((<span class="keywordtype">id</span>)setToString, range)) == NULL), 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382   }
<a name="l01383"></a>01383   
<a name="l01384"></a>01384   NSUInteger           arrayCount   = createdStringsCount;
<a name="l01385"></a>01385   <span class="keywordtype">id</span> * RKL_GC_VOLATILE arrayObjects = matchedStrings;
<a name="l01386"></a>01386   
<a name="l01387"></a>01387   <span class="keywordflow">if</span>((regexOp &amp; RKLSubcapturesArray) != 0UL) {
<a name="l01388"></a>01388     RKLCDelayedAssert(((createdStringsCount % ((NSUInteger)cachedRegex-&gt;captureCount + 1UL)) == 0UL) &amp;&amp; (createdArraysCount == 0UL), exception, exitNow);
<a name="l01389"></a>01389     
<a name="l01390"></a>01390     NSUInteger captureCount          = ((NSUInteger)cachedRegex-&gt;captureCount + 1UL);
<a name="l01391"></a>01391     NSUInteger subcaptureArraysCount = (createdStringsCount / captureCount);
<a name="l01392"></a>01392     <span class="keywordtype">size_t</span>     subcaptureArraysSize  = ((size_t)subcaptureArraysCount * <span class="keyword">sizeof</span>(<span class="keywordtype">id</span>));
<a name="l01393"></a>01393     
<a name="l01394"></a>01394     <span class="keywordflow">if</span>((findAll-&gt;stackUsed + subcaptureArraysSize) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((subcaptureArrays = (<span class="keywordtype">id</span> * RKL_GC_VOLATILE)alloca(subcaptureArraysSize))                                                                  == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } findAll-&gt;stackUsed += subcaptureArraysSize; }
<a name="l01395"></a>01395     <span class="keywordflow">else</span> {                                                                       <span class="keywordflow">if</span>(RKL_EXPECTED((subcaptureArrays = (<span class="keywordtype">id</span> * RKL_GC_VOLATILE)rkl_realloc(findAll-&gt;arraysScratchBuffer, subcaptureArraysSize, (NSUInteger)RKLScannedOption)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01396"></a>01396     
<a name="l01397"></a>01397     { <span class="comment">// This sub-block (and its local variables) is here for the benefit of the optimizer.</span>
<a name="l01398"></a>01398       <span class="keywordtype">id</span> *subcaptureArraysPtr = subcaptureArrays;
<a name="l01399"></a>01399       <span class="keywordtype">id</span> *matchedStringsPtr   = matchedStrings;
<a name="l01400"></a>01400       
<a name="l01401"></a>01401       <span class="keywordflow">for</span>(createdArraysCount = 0UL; createdArraysCount &lt; subcaptureArraysCount; createdArraysCount++) {
<a name="l01402"></a>01402         <span class="keywordflow">if</span>(RKL_EXPECTED((*subcaptureArraysPtr++ = rkl_CreateArrayWithObjects((<span class="keywordtype">void</span> **)matchedStringsPtr, captureCount)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01403"></a>01403         matchedStringsPtr       += captureCount;
<a name="l01404"></a>01404         transferredStringsCount += captureCount;
<a name="l01405"></a>01405       }
<a name="l01406"></a>01406     }
<a name="l01407"></a>01407     
<a name="l01408"></a>01408     RKLCDelayedAssert((transferredStringsCount == createdStringsCount), exception, exitNow);
<a name="l01409"></a>01409     arrayCount   = createdArraysCount;
<a name="l01410"></a>01410     arrayObjects = subcaptureArrays;
<a name="l01411"></a>01411   }
<a name="l01412"></a>01412   
<a name="l01413"></a>01413   RKLCDelayedAssert((arrayObjects != NULL), exception, exitNow);
<a name="l01414"></a>01414   resultArray = rkl_CreateAutoreleasedArray((<span class="keywordtype">void</span> **)arrayObjects, (NSUInteger)arrayCount);
<a name="l01415"></a>01415   
<a name="l01416"></a>01416 exitNow:
<a name="l01417"></a>01417   <span class="keywordflow">if</span>(RKL_EXPECTED(resultArray == NULL, 0L) &amp;&amp; (rkl_collectingEnabled() == NO)) { <span class="comment">// If we did not create an array then we need to make sure that we release any objects we created.</span>
<a name="l01418"></a>01418     NSUInteger x;
<a name="l01419"></a>01419     <span class="keywordflow">if</span>(matchedStrings   != NULL) { <span class="keywordflow">for</span>(x = transferredStringsCount; x &lt; createdStringsCount; x++) { <span class="keywordflow">if</span>((matchedStrings[x]  != NULL) &amp;&amp; (matchedStrings[x] != emptyString)) { matchedStrings[x]   = rkl_ReleaseObject(matchedStrings[x]);   } } }
<a name="l01420"></a>01420     <span class="keywordflow">if</span>(subcaptureArrays != NULL) { <span class="keywordflow">for</span>(x = 0UL;                     x &lt; createdArraysCount;  x++) { <span class="keywordflow">if</span>(subcaptureArrays[x] != NULL)                                        { subcaptureArrays[x] = rkl_ReleaseObject(subcaptureArrays[x]); } } }
<a name="l01421"></a>01421   }
<a name="l01422"></a>01422   
<a name="l01423"></a>01423   <span class="keywordflow">return</span>(resultArray);
<a name="l01424"></a>01424 }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01427"></a>01427 <span class="comment">//  IMPORTANT!   Should only be called from rkl_performRegexOp().</span>
<a name="l01428"></a>01428 <span class="comment">//  ----------</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="preprocessor">#pragma mark Convert bulk results from rkl_findRanges in to various NSDictionary types</span>
<a name="l01431"></a>01431 <span class="preprocessor"></span>
<a name="l01432"></a>01432 <span class="keyword">static</span> <span class="keywordtype">id</span> rkl_makeDictionary(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKLRegexOp regexOp, <a class="code" href="a00029.html">RKLFindAll</a> *findAll, NSUInteger captureKeysCount, <span class="keywordtype">id</span> captureKeys[captureKeysCount], <span class="keyword">const</span> <span class="keywordtype">int</span> captureKeyIndexes[captureKeysCount], <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG) {
<a name="l01433"></a>01433   NSUInteger                      matchedStringIndex  = 0UL, createdStringsCount = 0UL, createdDictionariesCount = 0UL, matchedDictionariesCount = (findAll-&gt;found / (cachedRegex-&gt;captureCount + 1UL)), transferredDictionariesCount = 0UL;
<a name="l01434"></a>01434   <span class="keywordtype">id</span>           *  RKL_GC_VOLATILE matchedStrings      = NULL, * RKL_GC_VOLATILE matchedKeys = NULL, emptyString = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l01435"></a>01435   <span class="keywordtype">id</span>              RKL_GC_VOLATILE returnObject        = NULL;
<a name="l01436"></a>01436   NSDictionary ** RKL_GC_VOLATILE matchedDictionaries = NULL;
<a name="l01437"></a>01437   
<a name="l01438"></a>01438   RKLCDelayedAssert((cachedRegex != NULL) &amp;&amp; ((findAll != NULL) &amp;&amp; (findAll-&gt;found &gt;= 0L) &amp;&amp; (findAll-&gt;stringsScratchBuffer != NULL) &amp;&amp; (findAll-&gt;dictionariesScratchBuffer != NULL) &amp;&amp; (findAll-&gt;keysScratchBuffer != NULL) &amp;&amp; (captureKeyIndexes != NULL)), exception, exitNow);
<a name="l01439"></a>01439   
<a name="l01440"></a>01440   CFStringRef setToString = cachedRegex-&gt;setToString;
<a name="l01441"></a>01441   
<a name="l01442"></a>01442   <span class="keywordtype">size_t</span>      matchedStringsSize     = ((size_t)captureKeysCount * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *));
<a name="l01443"></a>01443   <span class="keywordflow">if</span>((findAll-&gt;stackUsed + matchedStringsSize) &lt; (size_t)_RKL_STACK_LIMIT) {      <span class="keywordflow">if</span>(RKL_EXPECTED((matchedStrings      = (<span class="keywordtype">id</span>           *  RKL_GC_VOLATILE)alloca(matchedStringsSize))                                                                             == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } findAll-&gt;stackUsed += matchedStringsSize; }
<a name="l01444"></a>01444   <span class="keywordflow">else</span> {                                                                          <span class="keywordflow">if</span>(RKL_EXPECTED((matchedStrings      = (<span class="keywordtype">id</span>           *  RKL_GC_VOLATILE)rkl_realloc(findAll-&gt;stringsScratchBuffer,      matchedStringsSize,      (NSUInteger)RKLScannedOption)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01445"></a>01445   
<a name="l01446"></a>01446   <span class="keywordtype">size_t</span>      matchedKeysSize        = ((size_t)captureKeysCount * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *));
<a name="l01447"></a>01447   <span class="keywordflow">if</span>((findAll-&gt;stackUsed + matchedKeysSize) &lt; (size_t)_RKL_STACK_LIMIT) {         <span class="keywordflow">if</span>(RKL_EXPECTED((matchedKeys         = (<span class="keywordtype">id</span>           *  RKL_GC_VOLATILE)alloca(matchedKeysSize))                                                                                == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } findAll-&gt;stackUsed += matchedKeysSize; }
<a name="l01448"></a>01448   <span class="keywordflow">else</span> {                                                                          <span class="keywordflow">if</span>(RKL_EXPECTED((matchedKeys         = (<span class="keywordtype">id</span>           *  RKL_GC_VOLATILE)rkl_realloc(findAll-&gt;keysScratchBuffer,         matchedKeysSize,         (NSUInteger)RKLScannedOption)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01449"></a>01449   
<a name="l01450"></a>01450   <span class="keywordtype">size_t</span>      matchedDictionariesSize = ((size_t)matchedDictionariesCount * <span class="keyword">sizeof</span>(NSDictionary *));
<a name="l01451"></a>01451   <span class="keywordflow">if</span>((findAll-&gt;stackUsed + matchedDictionariesSize) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((matchedDictionaries = (NSDictionary ** RKL_GC_VOLATILE)alloca(matchedDictionariesSize))                                                                        == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } findAll-&gt;stackUsed += matchedDictionariesSize; }
<a name="l01452"></a>01452   <span class="keywordflow">else</span> {                                                                          <span class="keywordflow">if</span>(RKL_EXPECTED((matchedDictionaries = (NSDictionary ** RKL_GC_VOLATILE)rkl_realloc(findAll-&gt;dictionariesScratchBuffer, matchedDictionariesSize, (NSUInteger)RKLScannedOption)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01453"></a>01453   
<a name="l01454"></a>01454   { <span class="comment">// This sub-block (and its local variables) is here for the benefit of the optimizer.</span>
<a name="l01455"></a>01455     NSUInteger     captureCount           = cachedRegex-&gt;captureCount;
<a name="l01456"></a>01456     NSDictionary **matchedDictionariesPtr = matchedDictionaries;
<a name="l01457"></a>01457     
<a name="l01458"></a>01458     <span class="keywordflow">for</span>(createdDictionariesCount = 0UL; createdDictionariesCount &lt; matchedDictionariesCount; createdDictionariesCount++) {
<a name="l01459"></a>01459       RKLCDelayedAssert(((createdDictionariesCount * captureCount) &lt; (NSUInteger)findAll-&gt;found), exception, exitNow);
<a name="l01460"></a>01460       RKL_STRONG_REF <span class="keyword">const</span> NSRange * RKL_GC_VOLATILE rangePtr = &amp;findAll-&gt;ranges[(createdDictionariesCount * (captureCount + 1UL))];
<a name="l01461"></a>01461       <span class="keywordflow">for</span>(matchedStringIndex = 0UL; matchedStringIndex &lt; captureKeysCount; matchedStringIndex++) {
<a name="l01462"></a>01462         NSRange range = rangePtr[captureKeyIndexes[matchedStringIndex]];
<a name="l01463"></a>01463         <span class="keywordflow">if</span>(RKL_EXPECTED(range.location != NSNotFound, 0L)) {
<a name="l01464"></a>01464           <span class="keywordflow">if</span>(RKL_EXPECTED(((matchedStrings[createdStringsCount] = RKL_EXPECTED(range.length == 0UL, 0L) ? emptyString : rkl_CreateStringWithSubstring((<span class="keywordtype">id</span>)setToString, range)) == NULL), 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01465"></a>01465           matchedKeys[createdStringsCount] = captureKeys[createdStringsCount];
<a name="l01466"></a>01466           createdStringsCount++;
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468       }
<a name="l01469"></a>01469       RKLCDelayedAssert((matchedStringIndex &lt;= captureCount), exception, exitNow);
<a name="l01470"></a>01470       <span class="keywordflow">if</span>(RKL_EXPECTED(((*matchedDictionariesPtr++ = (NSDictionary * RKL_GC_VOLATILE)CFDictionaryCreate(NULL, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)matchedKeys, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)matchedStrings, (CFIndex)createdStringsCount, &amp;rkl_transferOwnershipDictionaryKeyCallBacks, &amp;rkl_transferOwnershipDictionaryValueCallBacks)) == NULL), 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01471"></a>01471       createdStringsCount = 0UL;
<a name="l01472"></a>01472     }
<a name="l01473"></a>01473   }
<a name="l01474"></a>01474   
<a name="l01475"></a>01475   <span class="keywordflow">if</span>(createdDictionariesCount &gt; 0UL) {
<a name="l01476"></a>01476     <span class="keywordflow">if</span>((regexOp &amp; RKLMaskOp) == RKLArrayOfDictionariesOfCapturesOp) {
<a name="l01477"></a>01477       RKLCDelayedAssert((matchedDictionaries != NULL) &amp;&amp; (createdDictionariesCount &gt; 0UL), exception, exitNow);
<a name="l01478"></a>01478       <span class="keywordflow">if</span>((returnObject = rkl_CreateAutoreleasedArray((<span class="keywordtype">void</span> **)matchedDictionaries, createdDictionariesCount)) == NULL) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01479"></a>01479       transferredDictionariesCount = createdDictionariesCount;
<a name="l01480"></a>01480     } <span class="keywordflow">else</span> {
<a name="l01481"></a>01481       RKLCDelayedAssert((matchedDictionaries != NULL) &amp;&amp; (createdDictionariesCount == 1UL), exception, exitNow);
<a name="l01482"></a>01482       <span class="keywordflow">if</span>((returnObject = rkl_CFAutorelease(matchedDictionaries[0])) == NULL) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01483"></a>01483       transferredDictionariesCount = 1UL;
<a name="l01484"></a>01484     }
<a name="l01485"></a>01485   }
<a name="l01486"></a>01486   
<a name="l01487"></a>01487 exitNow:
<a name="l01488"></a>01488   RKLCDelayedAssert((createdDictionariesCount &lt;= transferredDictionariesCount) &amp;&amp; ((transferredDictionariesCount &gt; 0UL) ? (createdStringsCount == 0UL) : 1), exception, exitNow2);
<a name="l01489"></a>01489 <span class="preprocessor">#ifndef NS_BLOCK_ASSERTIONS</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span>exitNow2:
<a name="l01491"></a>01491 <span class="preprocessor">#endif</span>
<a name="l01492"></a>01492 <span class="preprocessor"></span>
<a name="l01493"></a>01493   <span class="keywordflow">if</span>(rkl_collectingEnabled() == NO) { <span class="comment">// Release any objects, if necessary.</span>
<a name="l01494"></a>01494     NSUInteger x;
<a name="l01495"></a>01495     <span class="keywordflow">if</span>(matchedStrings      != NULL) { <span class="keywordflow">for</span>(x = 0UL;                          x &lt; createdStringsCount;      x++) { <span class="keywordflow">if</span>((matchedStrings[x]      != NULL) &amp;&amp; (matchedStrings[x] != emptyString)) { matchedStrings[x]      = rkl_ReleaseObject(matchedStrings[x]);      } } }
<a name="l01496"></a>01496     <span class="keywordflow">if</span>(matchedDictionaries != NULL) { <span class="keywordflow">for</span>(x = transferredDictionariesCount; x &lt; createdDictionariesCount; x++) { <span class="keywordflow">if</span>((matchedDictionaries[x] != NULL))                                       { matchedDictionaries[x] = rkl_ReleaseObject(matchedDictionaries[x]); } } }
<a name="l01497"></a>01497   }
<a name="l01498"></a>01498   
<a name="l01499"></a>01499   <span class="keywordflow">return</span>(returnObject);
<a name="l01500"></a>01500 }
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01503"></a>01503 <span class="comment">//  IMPORTANT!   Should only be called from rkl_performRegexOp().</span>
<a name="l01504"></a>01504 <span class="comment">//  ----------</span>
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 <span class="preprocessor">#pragma mark Perform &quot;search and replace&quot; operations on strings using ICUs uregex_*replace* functions</span>
<a name="l01507"></a>01507 <span class="preprocessor"></span>
<a name="l01508"></a>01508 <span class="keyword">static</span> <a class="code" href="a00025.html">NSString</a> *rkl_replaceString(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, <span class="keywordtype">id</span> searchString, NSUInteger searchU16Length, <a class="code" href="a00025.html">NSString</a> *replacementString, NSUInteger replacementU16Length, NSInteger *replacedCountPtr, NSUInteger replaceMutable, <span class="keywordtype">id</span> *exception, int32_t *status) {
<a name="l01509"></a>01509   RKL_STRONG_REF UniChar       * RKL_GC_VOLATILE tempUniCharBuffer  = NULL;
<a name="l01510"></a>01510   RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE replacementUniChar = NULL;
<a name="l01511"></a>01511   uint64_t           searchU16Length64  = (uint64_t)searchU16Length, replacementU16Length64 = (uint64_t)replacementU16Length;
<a name="l01512"></a>01512   int32_t            resultU16Length    = 0, tempUniCharBufferU16Capacity = 0, needU16Capacity = 0;
<a name="l01513"></a>01513   <span class="keywordtype">id</span> RKL_GC_VOLATILE resultObject       = NULL;
<a name="l01514"></a>01514   NSInteger          replacedCount      = -1L;
<a name="l01515"></a>01515   
<a name="l01516"></a>01516   <span class="keywordflow">if</span>((RKL_EXPECTED(replacementU16Length64 &gt;= (uint64_t)INT_MAX, 0L) || RKL_EXPECTED(((searchU16Length64 / 2ULL) + (replacementU16Length64 * 2ULL)) &gt;= (uint64_t)INT_MAX, 0L))) { *exception = [NSException exceptionWithName:NSRangeException reason:@&quot;Replacement string length exceeds INT_MAX.&quot; userInfo:NULL]; <span class="keywordflow">goto</span> exitNow; }
<a name="l01517"></a>01517 
<a name="l01518"></a>01518   RKLCDelayedAssert((searchU16Length64 &lt; (uint64_t)INT_MAX) &amp;&amp; (replacementU16Length64 &lt; (uint64_t)INT_MAX) &amp;&amp; (((searchU16Length64 / 2ULL) + (replacementU16Length64 * 2ULL)) &lt; (uint64_t)INT_MAX), exception, exitNow);
<a name="l01519"></a>01519   
<a name="l01520"></a>01520   <span class="comment">// Zero order approximation of the buffer sizes for holding the replaced string or split strings and split strings pointer offsets.  As UTF16 code units.</span>
<a name="l01521"></a>01521   tempUniCharBufferU16Capacity = (int32_t)(16UL + (searchU16Length + (searchU16Length / 2UL)) + (replacementU16Length * 2UL));
<a name="l01522"></a>01522   RKLCDelayedAssert((tempUniCharBufferU16Capacity &lt; INT_MAX) &amp;&amp; (tempUniCharBufferU16Capacity &gt; 0), exception, exitNow);  
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <span class="comment">// Buffer sizes converted from native units to bytes.</span>
<a name="l01525"></a>01525   <span class="keywordtype">size_t</span> stackSize = 0UL, replacementSize = ((size_t)replacementU16Length * <span class="keyword">sizeof</span>(UniChar)), tempUniCharBufferSize = ((<span class="keywordtype">size_t</span>)tempUniCharBufferU16Capacity * <span class="keyword">sizeof</span>(UniChar));
<a name="l01526"></a>01526   
<a name="l01527"></a>01527   <span class="comment">// For the various buffers we require, we first try to allocate from the stack if we&#39;re not over the RKL_STACK_LIMIT.  If we are, switch to using the heap for the buffer.</span>
<a name="l01528"></a>01528   <span class="keywordflow">if</span>((stackSize + tempUniCharBufferSize) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((tempUniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)alloca(tempUniCharBufferSize))                                  == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } stackSize += tempUniCharBufferSize; }
<a name="l01529"></a>01529   <span class="keywordflow">else</span>                                                               { <span class="keywordflow">if</span>(RKL_EXPECTED((tempUniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_realloc(&amp;rkl_scratchBuffer[0], tempUniCharBufferSize, 0UL)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01530"></a>01530   
<a name="l01531"></a>01531   <span class="comment">// Try to get the pointer to the replacement strings UTF16 data.  If we can&#39;t, allocate some buffer space, then covert to UTF16.</span>
<a name="l01532"></a>01532   <span class="keywordflow">if</span>((replacementUniChar = CFStringGetCharactersPtr((CFStringRef)replacementString)) == NULL) {
<a name="l01533"></a>01533     RKL_STRONG_REF UniChar * RKL_GC_VOLATILE uniCharBuffer = NULL;
<a name="l01534"></a>01534     <span class="keywordflow">if</span>((stackSize + replacementSize) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((uniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)alloca(replacementSize))                                  == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } stackSize += replacementSize; } 
<a name="l01535"></a>01535     <span class="keywordflow">else</span>                                                         { <span class="keywordflow">if</span>(RKL_EXPECTED((uniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_realloc(&amp;rkl_scratchBuffer[1], replacementSize, 0UL)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01536"></a>01536     CFStringGetCharacters((CFStringRef)replacementString, CFMakeRange(0L, replacementU16Length), uniCharBuffer); <span class="comment">// Convert to a UTF16 string.</span>
<a name="l01537"></a>01537     replacementUniChar = uniCharBuffer;
<a name="l01538"></a>01538   }
<a name="l01539"></a>01539   
<a name="l01540"></a>01540   resultU16Length = rkl_replaceAll(cachedRegex, replacementUniChar, (int32_t)replacementU16Length, tempUniCharBuffer, tempUniCharBufferU16Capacity, &amp;replacedCount, &amp;needU16Capacity, exception, status);
<a name="l01541"></a>01541   RKLCDelayedAssert((resultU16Length &lt;= tempUniCharBufferU16Capacity) &amp;&amp; (needU16Capacity &gt;= resultU16Length) &amp;&amp; (needU16Capacity &gt;= 0), exception, exitNow);
<a name="l01542"></a>01542   <span class="keywordflow">if</span>(RKL_EXPECTED((needU16Capacity + 4) &gt;= INT_MAX, 0L)) { *exception = [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Replaced string length exceeds INT_MAX.&quot; userInfo:NULL]; <span class="keywordflow">goto</span> exitNow; }
<a name="l01543"></a>01543   
<a name="l01544"></a>01544   <span class="keywordflow">if</span>(RKL_EXPECTED(*status == U_BUFFER_OVERFLOW_ERROR, 0L)) { <span class="comment">// Our buffer guess(es) were too small.  Resize the buffers and try again.</span>
<a name="l01545"></a>01545     <span class="comment">// rkl_replaceAll will turn a status of U_STRING_NOT_TERMINATED_WARNING in to a U_BUFFER_OVERFLOW_ERROR.</span>
<a name="l01546"></a>01546     <span class="comment">// As an extra precaution, we pad out the amount needed by an extra four characters &quot;just in case&quot;.</span>
<a name="l01547"></a>01547     <span class="comment">// http://lists.apple.com/archives/Cocoa-dev/2010/Jan/msg01011.html</span>
<a name="l01548"></a>01548     needU16Capacity += 4;
<a name="l01549"></a>01549     tempUniCharBufferSize = ((size_t)(tempUniCharBufferU16Capacity = needU16Capacity + 4) * <span class="keyword">sizeof</span>(UniChar)); <span class="comment">// Use needU16Capacity. Bug 2890810.</span>
<a name="l01550"></a>01550     <span class="keywordflow">if</span>((stackSize + tempUniCharBufferSize) &lt; (size_t)_RKL_STACK_LIMIT) { <span class="keywordflow">if</span>(RKL_EXPECTED((tempUniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)alloca(tempUniCharBufferSize))                                  == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } stackSize += tempUniCharBufferSize; } <span class="comment">// Warning about stackSize can be safely ignored.</span>
<a name="l01551"></a>01551     <span class="keywordflow">else</span>                                                               { <span class="keywordflow">if</span>(RKL_EXPECTED((tempUniCharBuffer = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_realloc(&amp;rkl_scratchBuffer[0], tempUniCharBufferSize, 0UL)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } }
<a name="l01552"></a>01552     
<a name="l01553"></a>01553     *status         = U_ZERO_ERROR; <span class="comment">// Make sure the status var is cleared and try again.</span>
<a name="l01554"></a>01554     resultU16Length = rkl_replaceAll(cachedRegex, replacementUniChar, (int32_t)replacementU16Length, tempUniCharBuffer, tempUniCharBufferU16Capacity, &amp;replacedCount, &amp;needU16Capacity, exception, status);
<a name="l01555"></a>01555     RKLCDelayedAssert((resultU16Length &lt;= tempUniCharBufferU16Capacity) &amp;&amp; (needU16Capacity &gt;= resultU16Length) &amp;&amp; (needU16Capacity &gt;= 0), exception, exitNow);
<a name="l01556"></a>01556   }
<a name="l01557"></a>01557   
<a name="l01558"></a>01558   <span class="comment">// If status != U_ZERO_ERROR, consider it an error, even though status &lt; U_ZERO_ERROR is a &#39;warning&#39; in ICU nomenclature.</span>
<a name="l01559"></a>01559   <span class="comment">// http://sourceforge.net/tracker/?func=detail&amp;atid=990188&amp;aid=2890810&amp;group_id=204582</span>
<a name="l01560"></a>01560   <span class="keywordflow">if</span>(RKL_EXPECTED(*status != U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Something went wrong.</span>
<a name="l01561"></a>01561 
<a name="l01562"></a>01562   RKLCDelayedAssert((replacedCount &gt;= 0L), exception, exitNow);  
<a name="l01563"></a>01563   <span class="keywordflow">if</span>(RKL_EXPECTED(resultU16Length == 0, 0L)) { resultObject = <span class="stringliteral">@&quot;&quot;</span>; } <span class="comment">// Optimize the case where the replaced text length == 0 with a @&quot;&quot; string.</span>
<a name="l01564"></a>01564   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(RKL_EXPECTED((NSUInteger)resultU16Length == searchU16Length, 0L) &amp;&amp; RKL_EXPECTED(replacedCount == 0L, 1L)) { <span class="comment">// Optimize the case where the replacement == original by creating a copy. Very fast if self is immutable.</span>
<a name="l01565"></a>01565     <span class="keywordflow">if</span>(replaceMutable == 0UL) { resultObject = rkl_CFAutorelease(CFStringCreateCopy(NULL, (CFStringRef)searchString)); } <span class="comment">// .. but only if this is not replacing a mutable self.  Warning about potential leak can be safely ignored.</span>
<a name="l01566"></a>01566   } <span class="keywordflow">else</span> { resultObject = rkl_CFAutorelease(CFStringCreateWithCharacters(NULL, tempUniCharBuffer, (CFIndex)resultU16Length)); } <span class="comment">// otherwise, create a new string.  Warning about potential leak can be safely ignored.</span>
<a name="l01567"></a>01567   
<a name="l01568"></a>01568   <span class="comment">// If replaceMutable == 1UL, we don&#39;t do the replacement here.  We wait until after we return and unlock the cache lock.</span>
<a name="l01569"></a>01569   <span class="comment">// This is because we may be trying to mutate an immutable string object.</span>
<a name="l01570"></a>01570   <span class="keywordflow">if</span>((replaceMutable == 1UL) &amp;&amp; RKL_EXPECTED(replacedCount &gt; 0L, 1L)) { <span class="comment">// We&#39;re working on a mutable string and there were successful matches with replaced text, so there&#39;s work to do.</span>
<a name="l01571"></a>01571     <span class="keywordflow">if</span>(cachedRegex-&gt;buffer != NULL) { rkl_clearBuffer(cachedRegex-&gt;buffer, 0UL); cachedRegex-&gt;buffer = NULL; }
<a name="l01572"></a>01572     NSUInteger  idx = 0UL;
<a name="l01573"></a>01573     <span class="keywordflow">for</span>(idx = 0UL; idx &lt; _RKL_LRU_CACHE_SET_WAYS; idx++) {
<a name="l01574"></a>01574       <a class="code" href="a00027.html">RKLBuffer</a> *buffer = ((NSUInteger)cachedRegex-&gt;setToLength &lt; _RKL_FIXED_LENGTH) ? &amp;rkl_lruFixedBuffer[idx] : &amp;rkl_lruDynamicBuffer[idx];
<a name="l01575"></a>01575       <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;setToString == buffer-&gt;string, 0L) &amp;&amp; (cachedRegex-&gt;setToLength == buffer-&gt;length) &amp;&amp; (cachedRegex-&gt;setToHash == buffer-&gt;hash)) { rkl_clearBuffer(buffer, 0UL); }
<a name="l01576"></a>01576     }
<a name="l01577"></a>01577     rkl_clearCachedRegexSetTo(cachedRegex); <span class="comment">// Flush any cached information about this string since it will mutate.</span>
<a name="l01578"></a>01578   }
<a name="l01579"></a>01579   
<a name="l01580"></a>01580 exitNow:
<a name="l01581"></a>01581   <span class="keywordflow">if</span>(RKL_EXPECTED(status == NULL, 0L) || RKL_EXPECTED(*status != U_ZERO_ERROR, 0L) || RKL_EXPECTED(exception == NULL, 0L) || RKL_EXPECTED(*exception != NULL, 0L)) { replacedCount = -1L; }
<a name="l01582"></a>01582   <span class="keywordflow">if</span>(rkl_scratchBuffer[0] != NULL) { rkl_scratchBuffer[0] = rkl_free(&amp;rkl_scratchBuffer[0]); }
<a name="l01583"></a>01583   <span class="keywordflow">if</span>(rkl_scratchBuffer[1] != NULL) { rkl_scratchBuffer[1] = rkl_free(&amp;rkl_scratchBuffer[1]); }
<a name="l01584"></a>01584   <span class="keywordflow">if</span>(replacedCountPtr     != NULL) { *replacedCountPtr    = replacedCount;                   }
<a name="l01585"></a>01585   <span class="keywordflow">return</span>(resultObject);
<a name="l01586"></a>01586 } <span class="comment">// The two warnings about potential leaks can be safely ignored.</span>
<a name="l01587"></a>01587 
<a name="l01588"></a>01588 <span class="comment">//  IMPORTANT!   Should only be called from rkl_replaceString().</span>
<a name="l01589"></a>01589 <span class="comment">//  ----------</span>
<a name="l01590"></a>01590 <span class="comment">//  Modified version of the ICU libraries uregex_replaceAll() that keeps count of the number of replacements made.</span>
<a name="l01591"></a>01591 
<a name="l01592"></a>01592 <span class="keyword">static</span> int32_t rkl_replaceAll(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex, RKL_STRONG_REF <span class="keyword">const</span> UniChar * RKL_GC_VOLATILE replacementUniChar, int32_t replacementU16Length, UniChar *replacedUniChar, int32_t replacedU16Capacity, NSInteger *replacedCount, int32_t *needU16Capacity, <span class="keywordtype">id</span> *exception RKL_UNUSED_ASSERTION_ARG, int32_t *status) {
<a name="l01593"></a>01593   int32_t    u16Length        = 0,   initialReplacedU16Capacity = replacedU16Capacity;
<a name="l01594"></a>01594   NSUInteger bufferOverflowed = 0UL;
<a name="l01595"></a>01595   NSInteger  replaced         = -1L;
<a name="l01596"></a>01596   RKLCDelayedAssert((cachedRegex != NULL) &amp;&amp; (replacementUniChar != NULL) &amp;&amp; (replacedUniChar != NULL) &amp;&amp; (replacedCount != NULL) &amp;&amp; (needU16Capacity != NULL) &amp;&amp; (status != NULL) &amp;&amp; (replacementU16Length &gt;= 0) &amp;&amp; (replacedU16Capacity &gt;= 0), exception, exitNow);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598   cachedRegex-&gt;lastFindRange = cachedRegex-&gt;lastMatchRange = NSNotFoundRange; <span class="comment">// Clear the cached find information for this regex so a subsequent find works correctly.</span>
<a name="l01599"></a>01599   RKL_ICU_FUNCTION_APPEND(uregex_reset)(cachedRegex-&gt;icu_regex, 0, status);
<a name="l01600"></a>01600   
<a name="l01601"></a>01601   <span class="comment">// Work around for ICU uregex_reset() bug, see http://bugs.icu-project.org/trac/ticket/6545</span>
<a name="l01602"></a>01602   <span class="comment">// http://sourceforge.net/tracker/index.php?func=detail&amp;aid=2105213&amp;group_id=204582&amp;atid=990188</span>
<a name="l01603"></a>01603   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;setToRange.length == 0UL, 0L) &amp;&amp; (*status == U_INDEX_OUTOFBOUNDS_ERROR)) { *status = U_ZERO_ERROR; }
<a name="l01604"></a>01604   replaced = 0L;
<a name="l01605"></a>01605   <span class="comment">// This loop originally came from ICU source/i18n/uregex.cpp, uregex_replaceAll.</span>
<a name="l01606"></a>01606   <span class="comment">// There is a bug in that code which causes the size of the buffer required for the replaced text to not be calculated correctly.</span>
<a name="l01607"></a>01607   <span class="comment">// This contains a work around using the variable bufferOverflowed.</span>
<a name="l01608"></a>01608   <span class="comment">// ICU bug: http://bugs.icu-project.org/trac/ticket/6656</span>
<a name="l01609"></a>01609   <span class="comment">// http://sourceforge.net/tracker/index.php?func=detail&amp;aid=2408447&amp;group_id=204582&amp;atid=990188</span>
<a name="l01610"></a>01610   <span class="keywordflow">while</span>(RKL_ICU_FUNCTION_APPEND(uregex_findNext)(cachedRegex-&gt;icu_regex, status)) {
<a name="l01611"></a>01611     replaced++;
<a name="l01612"></a>01612     u16Length += RKL_ICU_FUNCTION_APPEND(uregex_appendReplacement)(cachedRegex-&gt;icu_regex, replacementUniChar, replacementU16Length, &amp;replacedUniChar, &amp;replacedU16Capacity, status);
<a name="l01613"></a>01613     <span class="keywordflow">if</span>(RKL_EXPECTED(*status == U_BUFFER_OVERFLOW_ERROR, 0L)) { bufferOverflowed = 1UL; *status = U_ZERO_ERROR; }
<a name="l01614"></a>01614   }
<a name="l01615"></a>01615   <span class="keywordflow">if</span>(RKL_EXPECTED(*status == U_BUFFER_OVERFLOW_ERROR, 0L)) { bufferOverflowed = 1UL; *status = U_ZERO_ERROR; }
<a name="l01616"></a>01616   <span class="keywordflow">if</span>(RKL_EXPECTED(*status &lt;= U_ZERO_ERROR, 1L))            { u16Length += RKL_ICU_FUNCTION_APPEND(uregex_appendTail)(cachedRegex-&gt;icu_regex, &amp;replacedUniChar, &amp;replacedU16Capacity, status); }
<a name="l01617"></a>01617   
<a name="l01618"></a>01618   <span class="comment">// Try to work around a status of U_STRING_NOT_TERMINATED_WARNING.  For now, we treat it as a &quot;Buffer Overflow&quot; error.</span>
<a name="l01619"></a>01619   <span class="comment">// As an extra precaution, in rkl_replaceString, we pad out the amount needed by an extra four characters &quot;just in case&quot;.</span>
<a name="l01620"></a>01620   <span class="comment">// http://lists.apple.com/archives/Cocoa-dev/2010/Jan/msg01011.html</span>
<a name="l01621"></a>01621   <span class="keywordflow">if</span>(RKL_EXPECTED(*status == U_STRING_NOT_TERMINATED_WARNING, 0L)) { *status = U_BUFFER_OVERFLOW_ERROR; }
<a name="l01622"></a>01622 
<a name="l01623"></a>01623   <span class="comment">// Check for status &lt;= U_ZERO_ERROR (a &#39;warning&#39; in ICU nomenclature) rather than just status == U_ZERO_ERROR.</span>
<a name="l01624"></a>01624   <span class="comment">// Under just the right circumstances, status might be equal to U_STRING_NOT_TERMINATED_WARNING.  When this occurred,</span>
<a name="l01625"></a>01625   <span class="comment">// rkl_replaceString would never get the U_BUFFER_OVERFLOW_ERROR status, and thus never grow the buffer to the size needed.</span>
<a name="l01626"></a>01626   <span class="comment">// http://sourceforge.net/tracker/?func=detail&amp;atid=990188&amp;aid=2890810&amp;group_id=204582</span>
<a name="l01627"></a>01627   <span class="keywordflow">if</span>(RKL_EXPECTED(bufferOverflowed == 1UL, 0L) &amp;&amp; RKL_EXPECTED(*status &lt;= U_ZERO_ERROR, 1L)) { *status = U_BUFFER_OVERFLOW_ERROR; }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 <span class="preprocessor">#ifndef   NS_BLOCK_ASSERTIONS</span>
<a name="l01630"></a>01630 <span class="preprocessor"></span>exitNow:
<a name="l01631"></a>01631 <span class="preprocessor">#endif // NS_BLOCK_ASSERTIONS</span>
<a name="l01632"></a>01632 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(RKL_EXPECTED(replacedCount   != NULL, 1L)) { *replacedCount   = replaced;  }
<a name="l01633"></a>01633   <span class="keywordflow">if</span>(RKL_EXPECTED(needU16Capacity != NULL, 1L)) { *needU16Capacity = u16Length; } <span class="comment">// Use needU16Capacity to return the number of characters that are needed for the completely replaced string. Bug 2890810.</span>
<a name="l01634"></a>01634   <span class="keywordflow">return</span>(initialReplacedU16Capacity - replacedU16Capacity);                       <span class="comment">// Return the number of characters of replacedUniChar that were used.</span>
<a name="l01635"></a>01635 }
<a name="l01636"></a>01636 
<a name="l01637"></a>01637 <span class="preprocessor">#pragma mark Internal function used to check if a regular expression is valid.</span>
<a name="l01638"></a>01638 <span class="preprocessor"></span>
<a name="l01639"></a>01639 <span class="keyword">static</span> NSUInteger rkl_isRegexValid(<span class="keywordtype">id</span> <span class="keyword">self</span>, <span class="keywordtype">SEL</span> _cmd, <a class="code" href="a00025.html">NSString</a> *regex, RKLRegexOptions options, NSInteger *captureCountPtr, NSError **error) {
<a name="l01640"></a>01640   <span class="keyword">volatile</span> NSUInteger RKL_CLEANUP(rkl_cleanup_cacheSpinLockStatus) rkl_cacheSpinLockStatus = 0UL;
<a name="l01641"></a>01641   
<a name="l01642"></a>01642   <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex    = NULL;
<a name="l01643"></a>01643   NSUInteger      gotCachedRegex = 0UL;
<a name="l01644"></a>01644   NSInteger       captureCount   = -1L;
<a name="l01645"></a>01645   <span class="keywordtype">id</span>              exception      = NULL;
<a name="l01646"></a>01646   
<a name="l01647"></a>01647   if((error != NULL) &amp;&amp; (*error != NULL)) { *error = NULL; }
<a name="l01648"></a>01648   <span class="keywordflow">if</span>(RKL_EXPECTED(regex == NULL, 0L)) { RKL_RAISE_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The regular expression argument is NULL.&quot;</span>); }
<a name="l01649"></a>01649   
<a name="l01650"></a>01650   OSSpinLockLock(&amp;rkl_cacheSpinLock);
<a name="l01651"></a>01651   rkl_cacheSpinLockStatus |= RKLLockedCacheSpinLock;
<a name="l01652"></a>01652   rkl_dtrace_incrementEventID();
<a name="l01653"></a>01653   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex = rkl_getCachedRegex(regex, options, error, &amp;exception)) != NULL, 1L)) { gotCachedRegex = 1UL; captureCount = cachedRegex-&gt;captureCount; }
<a name="l01654"></a>01654   cachedRegex = NULL;
<a name="l01655"></a>01655   OSSpinLockUnlock(&amp;rkl_cacheSpinLock);
<a name="l01656"></a>01656   rkl_cacheSpinLockStatus |= RKLUnlockedCacheSpinLock; <span class="comment">// Warning about rkl_cacheSpinLockStatus never being read can be safely ignored.</span>
<a name="l01657"></a>01657   
<a name="l01658"></a>01658   <span class="keywordflow">if</span>(captureCountPtr != NULL) { *captureCountPtr = captureCount; }
<a name="l01659"></a>01659   <span class="keywordflow">if</span>(RKL_EXPECTED(exception != NULL, 0L)) { rkl_handleDelayedAssert(<span class="keyword">self</span>, _cmd, exception); }
<a name="l01660"></a>01660   <span class="keywordflow">return</span>(gotCachedRegex);
<a name="l01661"></a>01661 }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="preprocessor">#pragma mark Functions used for clearing and releasing resources for various internal data structures</span>
<a name="l01664"></a>01664 <span class="preprocessor"></span>
<a name="l01665"></a>01665 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_clearStringCache(<span class="keywordtype">void</span>) {
<a name="l01666"></a>01666   RKLCAbortAssert(rkl_cacheSpinLock != (OSSpinLock)0);
<a name="l01667"></a>01667   rkl_lastCachedRegex = NULL;
<a name="l01668"></a>01668   NSUInteger x = 0UL;
<a name="l01669"></a>01669   <span class="keywordflow">for</span>(x = 0UL; x &lt; _RKL_SCRATCH_BUFFERS;    x++) { <span class="keywordflow">if</span>(rkl_scratchBuffer[x] != NULL) { rkl_scratchBuffer[x] = rkl_free(&amp;rkl_scratchBuffer[x]); }  }
<a name="l01670"></a>01670   <span class="keywordflow">for</span>(x = 0UL; x &lt; _RKL_REGEX_CACHE_LINES;  x++) { rkl_clearCachedRegex(&amp;rkl_cachedRegexes[x]);                                                  }
<a name="l01671"></a>01671   <span class="keywordflow">for</span>(x = 0UL; x &lt; _RKL_LRU_CACHE_SET_WAYS; x++) { rkl_clearBuffer(&amp;rkl_lruFixedBuffer[x], 0UL); rkl_clearBuffer(&amp;rkl_lruDynamicBuffer[x], 1UL); }
<a name="l01672"></a>01672 }
<a name="l01673"></a>01673 
<a name="l01674"></a>01674 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_clearBuffer(<a class="code" href="a00027.html">RKLBuffer</a> *buffer, NSUInteger freeDynamicBuffer) {
<a name="l01675"></a>01675   RKLCAbortAssert(buffer != NULL);
<a name="l01676"></a>01676   <span class="keywordflow">if</span>(RKL_EXPECTED(buffer == NULL, 0L)) { <span class="keywordflow">return</span>; }
<a name="l01677"></a>01677   <span class="keywordflow">if</span>(RKL_EXPECTED(freeDynamicBuffer == 1UL,  0L) &amp;&amp; RKL_EXPECTED(buffer-&gt;uniChar != NULL, 1L)) { RKL_STRONG_REF <span class="keywordtype">void</span> * RKL_GC_VOLATILE p = (RKL_STRONG_REF <span class="keywordtype">void</span> * RKL_GC_VOLATILE)buffer-&gt;uniChar; buffer-&gt;uniChar = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_free(&amp;p); }
<a name="l01678"></a>01678   <span class="keywordflow">if</span>(RKL_EXPECTED(buffer-&gt;string    != NULL, 1L))                                              { CFRelease((CFTypeRef)buffer-&gt;string); buffer-&gt;string = NULL; }
<a name="l01679"></a>01679   buffer-&gt;length = 0L;
<a name="l01680"></a>01680   buffer-&gt;hash   = 0UL;
<a name="l01681"></a>01681 }
<a name="l01682"></a>01682 
<a name="l01683"></a>01683 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_clearCachedRegex(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex) {
<a name="l01684"></a>01684   RKLCAbortAssert(cachedRegex != NULL);
<a name="l01685"></a>01685   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex == NULL, 0L)) { <span class="keywordflow">return</span>; }
<a name="l01686"></a>01686   rkl_clearCachedRegexSetTo(cachedRegex);
<a name="l01687"></a>01687   <span class="keywordflow">if</span>(rkl_lastCachedRegex      == cachedRegex) { rkl_lastCachedRegex = NULL; }
<a name="l01688"></a>01688   <span class="keywordflow">if</span>(cachedRegex-&gt;icu_regex   != NULL)        { RKL_ICU_FUNCTION_APPEND(uregex_close)(cachedRegex-&gt;icu_regex); cachedRegex-&gt;icu_regex   = NULL; cachedRegex-&gt;captureCount = -1L;                               }
<a name="l01689"></a>01689   <span class="keywordflow">if</span>(cachedRegex-&gt;regexString != NULL)        { CFRelease((CFTypeRef)cachedRegex-&gt;regexString);                cachedRegex-&gt;regexString = NULL; cachedRegex-&gt;options      =  0U; cachedRegex-&gt;regexHash = 0UL; }
<a name="l01690"></a>01690 }
<a name="l01691"></a>01691 
<a name="l01692"></a>01692 <span class="keyword">static</span> <span class="keywordtype">void</span> rkl_clearCachedRegexSetTo(<a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex) {
<a name="l01693"></a>01693   RKLCAbortAssert(cachedRegex != NULL);
<a name="l01694"></a>01694   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex              == NULL, 0L)) { <span class="keywordflow">return</span>; }
<a name="l01695"></a>01695   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;icu_regex   != NULL, 1L)) { int32_t status = 0; RKL_ICU_FUNCTION_APPEND(uregex_setText)(cachedRegex-&gt;icu_regex, &amp;rkl_emptyUniCharString[0], 0, &amp;status); }
<a name="l01696"></a>01696   <span class="keywordflow">if</span>(RKL_EXPECTED(cachedRegex-&gt;setToString != NULL, 1L)) { CFRelease((CFTypeRef)cachedRegex-&gt;setToString); cachedRegex-&gt;setToString = NULL; }
<a name="l01697"></a>01697   cachedRegex-&gt;lastFindRange    = cachedRegex-&gt;lastMatchRange       = cachedRegex-&gt;setToRange = NSNotFoundRange;
<a name="l01698"></a>01698   cachedRegex-&gt;setToIsImmutable = cachedRegex-&gt;setToNeedsConversion = 0U;
<a name="l01699"></a>01699   cachedRegex-&gt;setToUniChar     = NULL;
<a name="l01700"></a>01700   cachedRegex-&gt;setToHash        = 0UL;
<a name="l01701"></a>01701   cachedRegex-&gt;setToLength      = 0L;
<a name="l01702"></a>01702   cachedRegex-&gt;buffer           = NULL;
<a name="l01703"></a>01703 }
<a name="l01704"></a>01704 
<a name="l01705"></a>01705 <span class="preprocessor">#pragma mark Internal functions used to implement NSException and NSError functionality and userInfo NSDictionaries</span>
<a name="l01706"></a>01706 <span class="preprocessor"></span>
<a name="l01707"></a>01707 <span class="comment">// Helps to keep things tidy.</span>
<a name="l01708"></a>01708 <span class="preprocessor">#define addKeyAndObject(objs, keys, i, k, o) ({id _o=(o), _k=(k); if((_o != NULL) &amp;&amp; (_k != NULL)) { objs[i] = _o; keys[i] = _k; i++; } })</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>
<a name="l01710"></a>01710 <span class="keyword">static</span> NSDictionary *rkl_userInfoDictionary(RKLUserInfoOptions userInfoOptions, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, <span class="keyword">const</span> <a class="code" href="a00030.html">UParseError</a> *parseError, int32_t status, <a class="code" href="a00025.html">NSString</a> *matchString, NSRange matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, <a class="code" href="a00025.html">NSString</a> *replacedString, NSInteger replacedCount, RKLRegexEnumerationOptions enumerationOptions, ...) {
<a name="l01711"></a>01711   va_list varArgsList;
<a name="l01712"></a>01712   va_start(varArgsList, enumerationOptions);
<a name="l01713"></a>01713   <span class="keywordflow">if</span>(regexString == NULL) { regexString = <span class="stringliteral">@&quot;&lt;NULL regex&gt;&quot;</span>; }
<a name="l01714"></a>01714 
<a name="l01715"></a>01715   <span class="keywordtype">id</span> objects[64], keys[64];
<a name="l01716"></a>01716   NSUInteger count = 0UL;
<a name="l01717"></a>01717   
<a name="l01718"></a>01718   <a class="code" href="a00025.html">NSString</a> * RKL_GC_VOLATILE errorNameString = [<a class="code" href="a00025.html">NSString</a> stringWithUTF8String:RKL_ICU_FUNCTION_APPEND(u_errorName)(status)];
<a name="l01719"></a>01719   
<a name="l01720"></a>01720   addKeyAndObject(objects, keys, count, RKLICURegexRegexErrorKey,        regexString);
<a name="l01721"></a>01721   addKeyAndObject(objects, keys, count, RKLICURegexRegexOptionsErrorKey, [NSNumber numberWithUnsignedInt:options]);
<a name="l01722"></a>01722   addKeyAndObject(objects, keys, count, RKLICURegexErrorCodeErrorKey,    [NSNumber numberWithInt:status]);
<a name="l01723"></a>01723   addKeyAndObject(objects, keys, count, RKLICURegexErrorNameErrorKey,    errorNameString);
<a name="l01724"></a>01724 
<a name="l01725"></a>01725   <span class="keywordflow">if</span>(matchString                                            != NULL) { addKeyAndObject(objects, keys, count, RKLICURegexSubjectStringErrorKey,      matchString);                                             }  
<a name="l01726"></a>01726   <span class="keywordflow">if</span>((userInfoOptions &amp; RKLUserInfoSubjectRange)            != 0UL)  { addKeyAndObject(objects, keys, count, RKLICURegexSubjectRangeErrorKey,       [NSValue valueWithRange:matchRange]);                     }
<a name="l01727"></a>01727   <span class="keywordflow">if</span>(replacementString                                      != NULL) { addKeyAndObject(objects, keys, count, RKLICURegexReplacementStringErrorKey,  replacementString);                                       }
<a name="l01728"></a>01728   <span class="keywordflow">if</span>(replacedString                                         != NULL) { addKeyAndObject(objects, keys, count, RKLICURegexReplacedStringErrorKey,     replacedString);                                          }
<a name="l01729"></a>01729   <span class="keywordflow">if</span>((userInfoOptions &amp; RKLUserInfoReplacedCount)           != 0UL)  { addKeyAndObject(objects, keys, count, RKLICURegexReplacedCountErrorKey,      [NSNumber numberWithInteger:replacedCount]);              }
<a name="l01730"></a>01730   <span class="keywordflow">if</span>((userInfoOptions &amp; RKLUserInfoRegexEnumerationOptions) != 0UL)  { addKeyAndObject(objects, keys, count, RKLICURegexEnumerationOptionsErrorKey, [NSNumber numberWithUnsignedInteger:enumerationOptions]); }
<a name="l01731"></a>01731   
<a name="l01732"></a>01732   <span class="keywordflow">if</span>((parseError != NULL) &amp;&amp; (parseError-&gt;line != -1)) {
<a name="l01733"></a>01733     <a class="code" href="a00025.html">NSString</a> *preContextString  = [<a class="code" href="a00025.html">NSString</a> stringWithCharacters:&amp;parseError-&gt;preContext[0]  length:(NSUInteger)RKL_ICU_FUNCTION_APPEND(u_strlen)(&amp;parseError-&gt;preContext[0])];
<a name="l01734"></a>01734     <a class="code" href="a00025.html">NSString</a> *postContextString = [<a class="code" href="a00025.html">NSString</a> stringWithCharacters:&amp;parseError-&gt;postContext[0] length:(NSUInteger)RKL_ICU_FUNCTION_APPEND(u_strlen)(&amp;parseError-&gt;postContext[0])];
<a name="l01735"></a>01735     
<a name="l01736"></a>01736     addKeyAndObject(objects, keys, count, RKLICURegexLineErrorKey,        [NSNumber numberWithInt:parseError-&gt;line]);
<a name="l01737"></a>01737     addKeyAndObject(objects, keys, count, RKLICURegexOffsetErrorKey,      [NSNumber numberWithInt:parseError-&gt;offset]);
<a name="l01738"></a>01738     addKeyAndObject(objects, keys, count, RKLICURegexPreContextErrorKey,  preContextString);
<a name="l01739"></a>01739     addKeyAndObject(objects, keys, count, RKLICURegexPostContextErrorKey, postContextString);
<a name="l01740"></a>01740     addKeyAndObject(objects, keys, count, <span class="stringliteral">@&quot;NSLocalizedFailureReason&quot;</span>,    ([<a class="code" href="a00025.html">NSString</a> stringWithFormat:<span class="stringliteral">@&quot;The error %@ occurred at line %d, column %d: %@&lt;&lt;HERE&gt;&gt;%@&quot;</span>, errorNameString, parseError-&gt;line, parseError-&gt;offset, preContextString, postContextString]));
<a name="l01741"></a>01741   } <span class="keywordflow">else</span> {
<a name="l01742"></a>01742     addKeyAndObject(objects, keys, count, <span class="stringliteral">@&quot;NSLocalizedFailureReason&quot;</span>,    ([<a class="code" href="a00025.html">NSString</a> stringWithFormat:<span class="stringliteral">@&quot;The error %@ occurred.&quot;</span>, errorNameString]));
<a name="l01743"></a>01743   }
<a name="l01744"></a>01744   
<a name="l01745"></a>01745   <span class="keywordflow">while</span>(count &lt; 62UL) { <span class="keywordtype">id</span> obj = va_arg(varArgsList, <span class="keywordtype">id</span>), key = va_arg(varArgsList, <span class="keywordtype">id</span>); <span class="keywordflow">if</span>((obj != NULL) &amp;&amp; (key != NULL)) { addKeyAndObject(objects, keys, count, key, obj); } <span class="keywordflow">else</span> { <span class="keywordflow">break</span>; } }
<a name="l01746"></a>01746   va_end(varArgsList);
<a name="l01747"></a>01747   
<a name="l01748"></a>01748   <span class="keywordflow">return</span>([NSDictionary dictionaryWithObjects:&amp;objects[0] forKeys:&amp;keys[0] count:count]);
<a name="l01749"></a>01749 }
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 <span class="keyword">static</span> NSError *rkl_makeNSError(RKLUserInfoOptions userInfoOptions, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, <span class="keyword">const</span> <a class="code" href="a00030.html">UParseError</a> *parseError, int32_t status, <a class="code" href="a00025.html">NSString</a> *matchString, NSRange matchRange, <a class="code" href="a00025.html">NSString</a> *replacementString, <a class="code" href="a00025.html">NSString</a> *replacedString, NSInteger replacedCount, RKLRegexEnumerationOptions enumerationOptions, <a class="code" href="a00025.html">NSString</a> *errorDescription) {
<a name="l01752"></a>01752   <span class="keywordflow">if</span>(errorDescription == NULL) { errorDescription = (status == U_ZERO_ERROR) ? <span class="stringliteral">@&quot;No description of this error is available.&quot;</span> : [<a class="code" href="a00025.html">NSString</a> stringWithFormat:<span class="stringliteral">@&quot;ICU regular expression error #%d, %s.&quot;</span>, status, RKL_ICU_FUNCTION_APPEND(u_errorName)(status)]; }
<a name="l01753"></a>01753   <span class="keywordflow">return</span>([NSError errorWithDomain:RKLICURegexErrorDomain code:(NSInteger)status userInfo:rkl_userInfoDictionary(userInfoOptions, regexString, options, parseError, status, matchString, matchRange, replacementString, replacedString, replacedCount, enumerationOptions, errorDescription, <span class="stringliteral">@&quot;NSLocalizedDescription&quot;</span>, NULL)]);
<a name="l01754"></a>01754 }
<a name="l01755"></a>01755 
<a name="l01756"></a>01756 <span class="keyword">static</span> NSException *rkl_NSExceptionForRegex(<a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options, <span class="keyword">const</span> <a class="code" href="a00030.html">UParseError</a> *parseError, int32_t status) {
<a name="l01757"></a>01757   <span class="keywordflow">return</span>([NSException exceptionWithName:RKLICURegexException reason:[<a class="code" href="a00025.html">NSString</a> stringWithFormat:<span class="stringliteral">@&quot;ICU regular expression error #%d, %s.&quot;</span>, status, RKL_ICU_FUNCTION_APPEND(u_errorName)(status)] userInfo:rkl_userInfoDictionary((RKLUserInfoOptions)RKLUserInfoNone, regexString, options, parseError, status, NULL, NSNotFoundRange, NULL, NULL, 0L, (RKLRegexEnumerationOptions)RKLRegexEnumerationNoOptions, NULL)]);
<a name="l01758"></a>01758 }
<a name="l01759"></a>01759 
<a name="l01760"></a>01760 <span class="keyword">static</span> NSDictionary *rkl_makeAssertDictionary(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">function</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line, <a class="code" href="a00025.html">NSString</a> *format, ...) {
<a name="l01761"></a>01761   va_list varArgsList;
<a name="l01762"></a>01762   va_start(varArgsList, format);
<a name="l01763"></a>01763   <a class="code" href="a00025.html">NSString</a> * RKL_GC_VOLATILE formatString   = [[[<a class="code" href="a00025.html">NSString</a> alloc] initWithFormat:format arguments:varArgsList] autorelease];
<a name="l01764"></a>01764   va_end(varArgsList);
<a name="l01765"></a>01765   <a class="code" href="a00025.html">NSString</a> * RKL_GC_VOLATILE functionString = [<a class="code" href="a00025.html">NSString</a> stringWithUTF8String:function], *fileString = [<a class="code" href="a00025.html">NSString</a> stringWithUTF8String:file];
<a name="l01766"></a>01766   <span class="keywordflow">return</span>([NSDictionary dictionaryWithObjectsAndKeys:formatString, <span class="stringliteral">@&quot;description&quot;</span>, functionString, <span class="stringliteral">@&quot;function&quot;</span>, fileString, <span class="stringliteral">@&quot;file&quot;</span>, [NSNumber numberWithInt:line], <span class="stringliteral">@&quot;line&quot;</span>, NSInternalInconsistencyException, <span class="stringliteral">@&quot;exceptionName&quot;</span>, NULL]);
<a name="l01767"></a>01767 }
<a name="l01768"></a>01768 
<a name="l01769"></a>01769 <span class="keyword">static</span> <a class="code" href="a00025.html">NSString</a> *rkl_stringFromClassAndMethod(<span class="keywordtype">id</span> <span class="keywordtype">object</span>, <span class="keywordtype">SEL</span> selector, <a class="code" href="a00025.html">NSString</a> *format, ...) {
<a name="l01770"></a>01770   va_list varArgsList;
<a name="l01771"></a>01771   va_start(varArgsList, format);
<a name="l01772"></a>01772   <a class="code" href="a00025.html">NSString</a> * RKL_GC_VOLATILE formatString = [[[<a class="code" href="a00025.html">NSString</a> alloc] initWithFormat:format arguments:varArgsList] autorelease];
<a name="l01773"></a>01773   va_end(varArgsList);
<a name="l01774"></a>01774   Class objectsClass = (<span class="keywordtype">object</span> == NULL) ? NULL : [<span class="keywordtype">object</span> <span class="keyword">class</span>];
<a name="l01775"></a>01775   <span class="keywordflow">return</span>([<a class="code" href="a00025.html">NSString</a> stringWithFormat:<span class="stringliteral">@&quot;*** %c[%@ %@]: %@&quot;</span>, (<span class="keywordtype">object</span> == objectsClass) ? <span class="charliteral">&#39;+&#39;</span> : <span class="charliteral">&#39;-&#39;</span>, (objectsClass == NULL) ? <span class="stringliteral">@&quot;&lt;NULL&gt;&quot;</span> : NSStringFromClass(objectsClass), (selector == NULL) ? <span class="stringliteral">@&quot;:NULL:&quot;</span> : NSStringFromSelector(selector), formatString]);
<a name="l01776"></a>01776 }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="preprocessor">#ifdef    _RKL_BLOCKS_ENABLED</span>
<a name="l01779"></a>01779 <span class="preprocessor"></span>
<a name="l01781"></a>01781 <span class="preprocessor">#pragma mark -</span>
<a name="l01782"></a>01782 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Objective-C ^Blocks Support</span>
<a name="l01783"></a>01783 <span class="preprocessor"></span><span class="preprocessor">#pragma mark -</span>
<a name="l01784"></a>01784 <span class="preprocessor"></span>
<a name="l01785"></a>01785 
<a name="l01786"></a>01786 <span class="comment">// Prototypes</span>
<a name="l01787"></a>01787 
<a name="l01788"></a>01788 <span class="keyword">static</span> <span class="keywordtype">id</span> rkl_performEnumerationUsingBlock(<span class="keywordtype">id</span> <span class="keyword">self</span>, <span class="keywordtype">SEL</span> _cmd,
<a name="l01789"></a>01789                                            RKLRegexOp regexOp, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options,
<a name="l01790"></a>01790                                            <span class="keywordtype">id</span> matchString, NSRange matchRange,
<a name="l01791"></a>01791                                            RKLBlockEnumerationOp blockEnumerationOp, RKLRegexEnumerationOptions enumerationOptions,
<a name="l01792"></a>01792                                            NSInteger *replacedCountPtr, NSUInteger *errorFreePtr,
<a name="l01793"></a>01793                                            NSError **error,
<a name="l01794"></a>01794                                            <span class="keywordtype">void</span> (^stringsAndRangesBlock)(NSInteger capturedCount, <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> capturedStrings[capturedCount], <span class="keyword">const</span> NSRange capturedStringRanges[capturedCount], <span class="keyword">volatile</span> BOOL * <span class="keyword">const</span> stop),
<a name="l01795"></a>01795                                            <a class="code" href="a00025.html">NSString</a> *(^replaceStringsAndRangesBlock)(NSInteger capturedCount, <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> capturedStrings[capturedCount], <span class="keyword">const</span> NSRange capturedStringRanges[capturedCount], <span class="keyword">volatile</span> BOOL * <span class="keyword">const</span> stop)
<a name="l01796"></a>01796                                            ) RKL_NONNULL_ARGS(1,2,4,6);
<a name="l01797"></a>01797 
<a name="l01798"></a>01798 <span class="comment">// This is an object meant for internal use only.  It wraps and abstracts various functionality to simplify ^Blocks support.</span>
<a name="l01799"></a>01799 
<a name="l01800"></a>01800 <span class="keyword">@interface </span>RKLBlockEnumerationHelper : NSObject {
<a name="l01801"></a>01801   <span class="keyword">@public</span>
<a name="l01802"></a>01802   <a class="code" href="a00028.html">RKLCachedRegex</a> cachedRegex;
<a name="l01803"></a>01803   <a class="code" href="a00027.html">RKLBuffer</a>      buffer;
<a name="l01804"></a>01804   RKL_STRONG_REF <span class="keywordtype">void</span> * RKL_GC_VOLATILE scratchBuffer[_RKL_SCRATCH_BUFFERS];
<a name="l01805"></a>01805   NSUInteger     needToFreeBufferUniChar:1;
<a name="l01806"></a>01806 }
<a name="l01807"></a>01807 - (id)initWithRegex:(<a class="code" href="a00025.html">NSString</a> *)initRegexString options:(RKLRegexOptions)initOptions string:(<a class="code" href="a00025.html">NSString</a> *)initString range:(NSRange)initRange error:(NSError **)initError;
<a name="l01808"></a>01808 <span class="keyword">@end</span>
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="keyword">@implementation </span>RKLBlockEnumerationHelper
<a name="l01811"></a>01811 
<a name="l01812"></a>01812 - (id)initWithRegex:(<a class="code" href="a00025.html">NSString</a> *)initRegexString options:(RKLRegexOptions)initOptions string:(<a class="code" href="a00025.html">NSString</a> *)initString range:(NSRange)initRange error:(NSError **)initError
<a name="l01813"></a>01813 {
<a name="l01814"></a>01814   <span class="keyword">volatile</span> NSUInteger RKL_CLEANUP(rkl_cleanup_cacheSpinLockStatus) rkl_cacheSpinLockStatus = 0UL;
<a name="l01815"></a>01815 
<a name="l01816"></a>01816   int32_t         status               = U_ZERO_ERROR;
<a name="l01817"></a>01817   <span class="keywordtype">id</span>              exception            = NULL;
<a name="l01818"></a>01818   <a class="code" href="a00028.html">RKLCachedRegex</a> *retrievedCachedRegex = NULL;
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 <span class="preprocessor">#ifdef _RKL_DTRACE_ENABLED</span>
<a name="l01821"></a>01821 <span class="preprocessor"></span>  NSUInteger      thisDTraceEventID    = 0UL;
<a name="l01822"></a>01822   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    lookupResultFlags    = 0U;
<a name="l01823"></a>01823 <span class="preprocessor">#endif</span>
<a name="l01824"></a>01824 <span class="preprocessor"></span>  
<a name="l01825"></a>01825   <span class="keywordflow">if</span>(RKL_EXPECTED((<span class="keyword">self</span> = [super init]) == NULL, 0L)) { <span class="keywordflow">goto</span> errorExit; }
<a name="l01826"></a>01826 
<a name="l01827"></a>01827   RKLCDelayedAssert((initRegexString != NULL) &amp;&amp; (initString != NULL), &amp;exception, errorExit);
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   <span class="comment">// IMPORTANT!   Once we have obtained the lock, code MUST exit via &#39;goto exitNow;&#39; to unlock the lock!  NO EXCEPTIONS!</span>
<a name="l01830"></a>01830   <span class="comment">// ----------</span>
<a name="l01831"></a>01831   OSSpinLockLock(&amp;rkl_cacheSpinLock); <span class="comment">// Grab the lock and get cache entry.</span>
<a name="l01832"></a>01832   rkl_cacheSpinLockStatus |= RKLLockedCacheSpinLock;
<a name="l01833"></a>01833   rkl_dtrace_incrementAndGetEventID(thisDTraceEventID);
<a name="l01834"></a>01834   
<a name="l01835"></a>01835   <span class="keywordflow">if</span>(RKL_EXPECTED((retrievedCachedRegex = rkl_getCachedRegex(initRegexString, initOptions, initError, &amp;exception)) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01836"></a>01836   RKLCDelayedAssert(((retrievedCachedRegex &gt;= rkl_cachedRegexes) &amp;&amp; ((retrievedCachedRegex - &amp;rkl_cachedRegexes[0]) &lt; (ssize_t)_RKL_REGEX_CACHE_LINES)) &amp;&amp; (retrievedCachedRegex != NULL) &amp;&amp; (retrievedCachedRegex-&gt;icu_regex != NULL) &amp;&amp; (retrievedCachedRegex-&gt;regexString != NULL) &amp;&amp; (retrievedCachedRegex-&gt;captureCount &gt;= 0L) &amp;&amp; (retrievedCachedRegex == rkl_lastCachedRegex), &amp;exception, exitNow);
<a name="l01837"></a>01837   
<a name="l01838"></a>01838   <span class="keywordflow">if</span>(RKL_EXPECTED(retrievedCachedRegex == NULL, 0L) || RKL_EXPECTED(status &gt; U_ZERO_ERROR, 0L) || RKL_EXPECTED(exception != NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01839"></a>01839 
<a name="l01840"></a>01840   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex.icu_regex   = RKL_ICU_FUNCTION_APPEND(uregex_clone)(retrievedCachedRegex-&gt;icu_regex, &amp;status)) == NULL, 0L) || RKL_EXPECTED(status != U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> exitNow; }
<a name="l01841"></a>01841   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex.regexString = (CFStringRef)CFRetain((CFTypeRef)retrievedCachedRegex-&gt;regexString))             == NULL, 0L))                                             { <span class="keywordflow">goto</span> exitNow; }
<a name="l01842"></a>01842   cachedRegex.options      = initOptions;
<a name="l01843"></a>01843   cachedRegex.captureCount = retrievedCachedRegex-&gt;captureCount;
<a name="l01844"></a>01844   cachedRegex.regexHash    = retrievedCachedRegex-&gt;regexHash;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846   RKLCDelayedAssert((cachedRegex.icu_regex != NULL) &amp;&amp; (cachedRegex.regexString != NULL) &amp;&amp; (cachedRegex.captureCount &gt;= 0L), &amp;exception, exitNow);
<a name="l01847"></a>01847 
<a name="l01848"></a>01848 exitNow:
<a name="l01849"></a>01849   <span class="keywordflow">if</span>((rkl_cacheSpinLockStatus &amp; RKLLockedCacheSpinLock) != 0UL) { <span class="comment">// In case we arrive at exitNow: without obtaining the rkl_cacheSpinLock.</span>
<a name="l01850"></a>01850     OSSpinLockUnlock(&amp;rkl_cacheSpinLock);
<a name="l01851"></a>01851     rkl_cacheSpinLockStatus |= RKLUnlockedCacheSpinLock; <span class="comment">// Warning about rkl_cacheSpinLockStatus never being read can be safely ignored.</span>
<a name="l01852"></a>01852   }
<a name="l01853"></a>01853 
<a name="l01854"></a>01854   <span class="keywordflow">if</span>(RKL_EXPECTED(<span class="keyword">self</span> == NULL, 0L) || RKL_EXPECTED(retrievedCachedRegex == NULL, 0L) || RKL_EXPECTED(cachedRegex.icu_regex == NULL, 0L) || RKL_EXPECTED(status != U_ZERO_ERROR, 0L) || RKL_EXPECTED(exception != NULL, 0L)) { <span class="keywordflow">goto</span> errorExit; }
<a name="l01855"></a>01855   retrievedCachedRegex = NULL; <span class="comment">// Since we no longer hold the lock, ensure that nothing accesses the retrieved cache regex after this point.</span>
<a name="l01856"></a>01856 
<a name="l01857"></a>01857   rkl_dtrace_addLookupFlag(lookupResultFlags, RKLEnumerationBufferLookupFlag);
<a name="l01858"></a>01858 
<a name="l01859"></a>01859   <span class="keywordflow">if</span>(RKL_EXPECTED((buffer.string = CFStringCreateCopy(NULL, (CFStringRef)initString)) == NULL, 0L)) { <span class="keywordflow">goto</span> errorExit; }
<a name="l01860"></a>01860   buffer.hash   = CFHash((CFTypeRef)buffer.string);
<a name="l01861"></a>01861   buffer.length = CFStringGetLength(buffer.string);
<a name="l01862"></a>01862 
<a name="l01863"></a>01863   <span class="keywordflow">if</span>((buffer.uniChar = (UniChar *)CFStringGetCharactersPtr(buffer.string)) == NULL) {
<a name="l01864"></a>01864     rkl_dtrace_addLookupFlag(lookupResultFlags, RKLConversionRequiredLookupFlag);
<a name="l01865"></a>01865     <span class="keywordflow">if</span>(RKL_EXPECTED((buffer.uniChar = (RKL_STRONG_REF UniChar * RKL_GC_VOLATILE)rkl_realloc((RKL_STRONG_REF <span class="keywordtype">void</span> ** RKL_GC_VOLATILE)&amp;buffer.uniChar, ((<span class="keywordtype">size_t</span>)buffer.length * <span class="keyword">sizeof</span>(UniChar)), 0UL)) == NULL, 0L)) { <span class="keywordflow">goto</span> errorExit; } <span class="comment">// Resize the buffer.</span>
<a name="l01866"></a>01866     needToFreeBufferUniChar = rkl_collectingEnabled() ? 0U : 1U;
<a name="l01867"></a>01867     CFStringGetCharacters(buffer.string, CFMakeRange(0L, buffer.length), (UniChar *)buffer.uniChar); <span class="comment">// Convert to a UTF16 string.</span>
<a name="l01868"></a>01868   }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870   <span class="keywordflow">if</span>(RKL_EXPECTED((cachedRegex.setToString = (CFStringRef)CFRetain((CFTypeRef)buffer.string)) == NULL, 0L)) { <span class="keywordflow">goto</span> errorExit; }
<a name="l01871"></a>01871   cachedRegex.setToHash    = buffer.hash;
<a name="l01872"></a>01872   cachedRegex.setToLength  = buffer.length;
<a name="l01873"></a>01873   cachedRegex.setToUniChar = buffer.uniChar;
<a name="l01874"></a>01874   cachedRegex.buffer       = &amp;buffer;
<a name="l01875"></a>01875   
<a name="l01876"></a>01876   RKLCDelayedAssert((cachedRegex.icu_regex != NULL) &amp;&amp; (cachedRegex.setToUniChar != NULL) &amp;&amp; (cachedRegex.setToLength &lt; INT_MAX) &amp;&amp; (NSMaxRange(initRange) &lt;= (NSUInteger)cachedRegex.setToLength) &amp;&amp; (NSMaxRange(initRange) &lt; INT_MAX), &amp;exception, errorExit);
<a name="l01877"></a>01877   cachedRegex.lastFindRange = cachedRegex.lastMatchRange = NSNotFoundRange;
<a name="l01878"></a>01878   cachedRegex.setToRange    = initRange;
<a name="l01879"></a>01879   RKL_ICU_FUNCTION_APPEND(uregex_setText)(cachedRegex.icu_regex, cachedRegex.setToUniChar + cachedRegex.setToRange.location, (int32_t)cachedRegex.setToRange.length, &amp;status);
<a name="l01880"></a>01880   <span class="keywordflow">if</span>(RKL_EXPECTED(status &gt; U_ZERO_ERROR, 0L)) { <span class="keywordflow">goto</span> errorExit; }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882   rkl_dtrace_addLookupFlag(lookupResultFlags, RKLSetTextLookupFlag);
<a name="l01883"></a>01883   rkl_dtrace_utf16ConversionCacheWithEventID(thisDTraceEventID, lookupResultFlags, initString, cachedRegex.setToRange.location, cachedRegex.setToRange.length, cachedRegex.setToLength);
<a name="l01884"></a>01884 
<a name="l01885"></a>01885   <span class="keywordflow">return</span>(<span class="keyword">self</span>);
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 errorExit:
<a name="l01888"></a>01888   <span class="keywordflow">if</span>(RKL_EXPECTED(<span class="keyword">self</span>      != NULL,         1L))                                        {  [<span class="keyword">self</span> autorelease]; }
<a name="l01889"></a>01889   <span class="keywordflow">if</span>(RKL_EXPECTED(status     &gt; U_ZERO_ERROR, 0L) &amp;&amp; RKL_EXPECTED(exception == NULL, 0L)) {  exception = rkl_NSExceptionForRegex(initRegexString, initOptions, NULL, status); } <span class="comment">// If we had a problem, prepare an exception to be thrown.</span>
<a name="l01890"></a>01890   <span class="keywordflow">if</span>(RKL_EXPECTED(status     &lt; U_ZERO_ERROR, 0L) &amp;&amp; (initError != NULL))                 { *initError = rkl_makeNSError((RKLUserInfoOptions)RKLUserInfoNone, initRegexString, initOptions, NULL, status, initString, initRange, NULL, NULL, 0L, (RKLRegexEnumerationOptions)RKLRegexEnumerationNoOptions, <span class="stringliteral">@&quot;The ICU library returned an unexpected error.&quot;</span>); }
<a name="l01891"></a>01891   <span class="keywordflow">if</span>(RKL_EXPECTED(exception != NULL,         0L))                                        {  rkl_handleDelayedAssert(<span class="keyword">self</span>, _cmd, exception); }
<a name="l01892"></a>01892 
<a name="l01893"></a>01893   <span class="keywordflow">return</span>(NULL);
<a name="l01894"></a>01894 }
<a name="l01895"></a>01895 
<a name="l01896"></a>01896 <span class="preprocessor">#ifdef    __OBJC_GC__</span>
<a name="l01897"></a>01897 <span class="preprocessor"></span>- (void)finalize
<a name="l01898"></a>01898 {
<a name="l01899"></a>01899   rkl_clearCachedRegex(&amp;cachedRegex);
<a name="l01900"></a>01900   rkl_clearBuffer(&amp;buffer, (needToFreeBufferUniChar != 0U) ? 1LU : 0LU);
<a name="l01901"></a>01901   NSUInteger tmpIdx = 0UL; <span class="comment">// The rkl_free() below is &quot;probably&quot; a no-op when GC is on, but better to be safe than sorry...</span>
<a name="l01902"></a>01902   <span class="keywordflow">for</span>(tmpIdx = 0UL; tmpIdx &lt; _RKL_SCRATCH_BUFFERS; tmpIdx++) { <span class="keywordflow">if</span>(RKL_EXPECTED(scratchBuffer[tmpIdx] != NULL, 0L)) { scratchBuffer[tmpIdx] = rkl_free(&amp;scratchBuffer[tmpIdx]); } }
<a name="l01903"></a>01903   [<span class="keyword">super</span> finalize];
<a name="l01904"></a>01904 }
<a name="l01905"></a>01905 <span class="preprocessor">#endif // __OBJC_GC__</span>
<a name="l01906"></a>01906 <span class="preprocessor"></span>  
<a name="l01907"></a>01907 - (void)dealloc
<a name="l01908"></a>01908 {
<a name="l01909"></a>01909   rkl_clearCachedRegex(&amp;cachedRegex);
<a name="l01910"></a>01910   rkl_clearBuffer(&amp;buffer, (needToFreeBufferUniChar != 0U) ? 1LU : 0LU);
<a name="l01911"></a>01911   NSUInteger tmpIdx = 0UL;
<a name="l01912"></a>01912   <span class="keywordflow">for</span>(tmpIdx = 0UL; tmpIdx &lt; _RKL_SCRATCH_BUFFERS; tmpIdx++) { <span class="keywordflow">if</span>(RKL_EXPECTED(scratchBuffer[tmpIdx] != NULL, 0L)) { scratchBuffer[tmpIdx] = rkl_free(&amp;scratchBuffer[tmpIdx]); } }
<a name="l01913"></a>01913   [<span class="keyword">super</span> dealloc];
<a name="l01914"></a>01914 }
<a name="l01915"></a>01915 
<a name="l01916"></a>01916 <span class="keyword">@end</span>
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 <span class="comment">//  IMPORTANT!   This code is critical path code.  Because of this, it has been written for speed, not clarity.</span>
<a name="l01919"></a>01919 <span class="comment">//  ----------</span>
<a name="l01920"></a>01920 <span class="comment">//</span>
<a name="l01921"></a>01921 <span class="comment">//  Return value: BOOL. Per &quot;Error Handling Programming Guide&quot; wrt/ NSError, return NO on error / failure, and set *error to an NSError object.</span>
<a name="l01922"></a>01922 <span class="comment">//  </span>
<a name="l01923"></a>01923 <span class="comment">//  rkl_performEnumerationUsingBlock reference counted / manual memory management notes:</span>
<a name="l01924"></a>01924 <span class="comment">//</span>
<a name="l01925"></a>01925 <span class="comment">//  When running using reference counting, rkl_performEnumerationUsingBlock() creates a CFMutableArray called autoreleaseArray, which is -autoreleased.</span>
<a name="l01926"></a>01926 <span class="comment">//  autoreleaseArray uses the rkl_transferOwnershipArrayCallBacks CFArray callbacks which do not perform a -retain/CFRetain() when objects are added, but do perform a -release/CFRelease() when an object is removed.</span>
<a name="l01927"></a>01927 <span class="comment">//</span>
<a name="l01928"></a>01928 <span class="comment">//  A special class, RKLBlockEnumerationHelper, is used to manage the details of creating a private instantiation of the ICU regex (via uregex_clone()) and setting up the details of the UTF-16 buffer required by the ICU regex engine.</span>
<a name="l01929"></a>01929 <span class="comment">//  The instantiated RKLBlockEnumerationHelper is not autoreleased, but added to autoreleaseArray.  When rkl_performEnumerationUsingBlock() exits, it calls CFArrayRemoveAllValues(autoreleaseArray), which empties the array.</span>
<a name="l01930"></a>01930 <span class="comment">//  This has the effect of immediately -releasing the instantiated RKLBlockEnumerationHelper object, and all the memory used to hold the ICU regex and UTF-16 conversion buffer.</span>
<a name="l01931"></a>01931 <span class="comment">//  This means the memory is reclaimed immediately and we do not have to wait until the autorelease pool pops.</span>
<a name="l01932"></a>01932 <span class="comment">//</span>
<a name="l01933"></a>01933 <span class="comment">//  If we are performing a &quot;string replacement&quot; operation, we create a temporary NSMutableString named mutableReplacementString to hold the replaced strings results.  mutableReplacementString is also added to autoreleaseArray so that it</span>
<a name="l01934"></a>01934 <span class="comment">//  can be properly released on an error.</span>
<a name="l01935"></a>01935 <span class="comment">//</span>
<a name="l01936"></a>01936 <span class="comment">//  Temporary strings that are created during the enumeration of matches are added to autoreleaseArray.</span>
<a name="l01937"></a>01937 <span class="comment">//  The strings are added by doing a CFArrayReplaceValues(), which simultaneously releases the previous iterations temporary strings while adding the current iterations temporary strings to the array.</span>
<a name="l01938"></a>01938 <span class="comment">//</span>
<a name="l01939"></a>01939 <span class="comment">//  autoreleaseArray always has a reference to any &quot;live&quot; and in use objects. If anything &quot;Goes Wrong&quot;, at any point, for any reason (ie, exception is thrown), autoreleaseArray is in the current NSAutoreleasePool</span>
<a name="l01940"></a>01940 <span class="comment">//  and will automatically be released when that pool pops.  This ensures that we don&#39;t leak anything even when things go seriously sideways.  This also allows us to keep the total amount of memory in use</span>
<a name="l01941"></a>01941 <span class="comment">//  down to a minimum, which can be substantial if the user is enumerating a large string, for example a regex of &#39;\w+&#39; on a 500K+ text file.</span>
<a name="l01942"></a>01942 <span class="comment">//</span>
<a name="l01943"></a>01943 <span class="comment">//  The only &#39;caveat&#39; is that the user needs to -retain any strings that they want to use past the point at which their ^block returns.  Logically, it is as if the following takes place:</span>
<a name="l01944"></a>01944 <span class="comment">//  </span>
<a name="l01945"></a>01945 <span class="comment">//  for(eachMatchOfRegexInStringToSearch) {</span>
<a name="l01946"></a>01946 <span class="comment">//    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span>
<a name="l01947"></a>01947 <span class="comment">//    callUsersBlock(capturedCount, capturedStrings, capturedStringRanges, stop);</span>
<a name="l01948"></a>01948 <span class="comment">//    [pool release];</span>
<a name="l01949"></a>01949 <span class="comment">//  }</span>
<a name="l01950"></a>01950 <span class="comment">//</span>
<a name="l01951"></a>01951 <span class="comment">//  But in reality, no NSAutoreleasePool is created, it&#39;s all slight of hand done via the CFMutableArray autoreleaseArray.</span>
<a name="l01952"></a>01952 <span class="comment">//</span>
<a name="l01953"></a>01953 <span class="comment">//  rkl_performEnumerationUsingBlock garbage collected / automatic memory management notes:</span>
<a name="l01954"></a>01954 <span class="comment">//</span>
<a name="l01955"></a>01955 <span class="comment">//  When RegexKitLite is built with -fobjc-gc or -fobjc-gc-only, and (in the case of -fobjc-gc) RegexKitLite determines that GC is active at execution time, then rkl_performEnumerationUsingBlock essentially</span>
<a name="l01956"></a>01956 <span class="comment">//  skips all of the above reference counted autoreleaseArray stuff. </span>
<a name="l01957"></a>01957 <span class="comment">//</span>
<a name="l01958"></a>01958 <span class="comment">//  rkl_performEnumerationUsingBlock and RKLRegexEnumerationReleaseStringReturnedByReplacementBlock notes</span>
<a name="l01959"></a>01959 <span class="comment">//</span>
<a name="l01960"></a>01960 <span class="comment">//  Under reference counting, this enumeration option allows the user to return a non-autoreleased string, and then have RegexKitLite send the object a -release message once it&#39;s done with it.</span>
<a name="l01961"></a>01961 <span class="comment">//  The primary reason to do this is to immediately reclaim the memory used by the string holding the replacement text.</span>
<a name="l01962"></a>01962 <span class="comment">//  Just in case the user returns one of the strings we passed via capturedStrings[], we check to see if the string return by the block is any of the strings we created and passed via capturedStrings[].</span>
<a name="l01963"></a>01963 <span class="comment">//  If it is one of our strings, we do not send the string a -release since that would over release it.  It is assumed that the user will /NOT/ add a -retain to our strings in this case.</span>
<a name="l01964"></a>01964 <span class="comment">//  Under GC, RKLRegexEnumerationReleaseStringReturnedByReplacementBlock is ignored and no -release messages are sent.</span>
<a name="l01965"></a>01965 <span class="comment">//  </span>
<a name="l01966"></a>01966 
<a name="l01967"></a>01967 <span class="preprocessor">#pragma mark Primary internal function that Objective-C ^Blocks related methods call to perform regular expression operations</span>
<a name="l01968"></a>01968 <span class="preprocessor"></span>
<a name="l01969"></a>01969 <span class="keyword">static</span> <span class="keywordtype">id</span> rkl_performEnumerationUsingBlock(<span class="keywordtype">id</span> <span class="keyword">self</span>, <span class="keywordtype">SEL</span> _cmd,
<a name="l01970"></a>01970                                            RKLRegexOp regexOp, <a class="code" href="a00025.html">NSString</a> *regexString, RKLRegexOptions options,
<a name="l01971"></a>01971                                            <span class="keywordtype">id</span> matchString, NSRange matchRange,
<a name="l01972"></a>01972                                            RKLBlockEnumerationOp blockEnumerationOp, RKLRegexEnumerationOptions enumerationOptions,
<a name="l01973"></a>01973                                            NSInteger *replacedCountPtr, NSUInteger *errorFreePtr,
<a name="l01974"></a>01974                                            NSError **error,
<a name="l01975"></a>01975                                            <span class="keywordtype">void</span> (^stringsAndRangesBlock)(NSInteger capturedCount, <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> capturedStrings[capturedCount], <span class="keyword">const</span> NSRange capturedStringRanges[capturedCount], <span class="keyword">volatile</span> BOOL * <span class="keyword">const</span> stop),
<a name="l01976"></a>01976                                            <a class="code" href="a00025.html">NSString</a> *(^replaceStringsAndRangesBlock)(NSInteger capturedCount, <a class="code" href="a00025.html">NSString</a> * <span class="keyword">const</span> capturedStrings[capturedCount], <span class="keyword">const</span> NSRange capturedStringRanges[capturedCount], <span class="keyword">volatile</span> BOOL * <span class="keyword">const</span> stop)) {
<a name="l01977"></a>01977   NSMutableArray            * RKL_GC_VOLATILE autoreleaseArray              = NULL;
<a name="l01978"></a>01978   RKLBlockEnumerationHelper * RKL_GC_VOLATILE blockEnumerationHelper        = NULL;
<a name="l01979"></a>01979   <a class="code" href="a00014.html">NSMutableString</a>           * RKL_GC_VOLATILE mutableReplacementString      = NULL;
<a name="l01980"></a>01980   RKL_STRONG_REF UniChar    * RKL_GC_VOLATILE blockEnumerationHelperUniChar = NULL;
<a name="l01981"></a>01981   NSUInteger    errorFree                = NO;
<a name="l01982"></a>01982   <span class="keywordtype">id</span>            exception                = NULL, returnObject  = NULL;
<a name="l01983"></a>01983   CFRange       autoreleaseReplaceRange  = CFMakeRange(0L, 0L);
<a name="l01984"></a>01984   int32_t       status                   = U_ZERO_ERROR;
<a name="l01985"></a>01985   RKLRegexOp    maskedRegexOp            = (regexOp &amp; RKLMaskOp);
<a name="l01986"></a>01986   <span class="keyword">volatile</span> BOOL shouldStop               = NO;
<a name="l01987"></a>01987   NSInteger     replacedCount            = -1L;
<a name="l01988"></a>01988   NSRange       lastMatchedRange         = NSNotFoundRange;
<a name="l01989"></a>01989   NSUInteger    stringU16Length          = 0UL;
<a name="l01990"></a>01990   
<a name="l01991"></a>01991   BOOL performStringReplacement = (blockEnumerationOp == RKLBlockEnumerationReplaceOp) ? YES : NO;
<a name="l01992"></a>01992   
<a name="l01993"></a>01993   <span class="keywordflow">if</span>((error != NULL) &amp;&amp; (*error != NULL)) { *error = NULL; }
<a name="l01994"></a>01994   
<a name="l01995"></a>01995   <span class="keywordflow">if</span>(RKL_EXPECTED(regexString == NULL, 0L)) { exception = (id)RKL_EXCEPTION(NSInvalidArgumentException,       <span class="stringliteral">@&quot;The regular expression argument is NULL.&quot;</span>); <span class="keywordflow">goto</span> exitNow; }
<a name="l01996"></a>01996   <span class="keywordflow">if</span>(RKL_EXPECTED(matchString == NULL, 0L)) { exception = (id)RKL_EXCEPTION(NSInternalInconsistencyException, <span class="stringliteral">@&quot;The match string argument is NULL.&quot;</span>);       <span class="keywordflow">goto</span> exitNow; }
<a name="l01997"></a>01997 
<a name="l01998"></a>01998   <span class="keywordflow">if</span>((((enumerationOptions &amp; RKLRegexEnumerationCapturedStringsNotRequired)              != 0UL) &amp;&amp; ((enumerationOptions &amp; RKLRegexEnumerationFastCapturedStringsXXX) != 0UL)) ||
<a name="l01999"></a>01999      (((enumerationOptions &amp; RKLRegexEnumerationReleaseStringReturnedByReplacementBlock) != 0UL) &amp;&amp; (blockEnumerationOp != RKLBlockEnumerationReplaceOp)) ||
<a name="l02000"></a>02000      ((enumerationOptions &amp; (~((RKLRegexEnumerationOptions)(RKLRegexEnumerationCapturedStringsNotRequired | RKLRegexEnumerationReleaseStringReturnedByReplacementBlock | RKLRegexEnumerationFastCapturedStringsXXX)))) != 0UL)) {
<a name="l02001"></a>02001     exception = (id)RKL_EXCEPTION(NSInvalidArgumentException, <span class="stringliteral">@&quot;The RKLRegexEnumerationOptions argument is not valid.&quot;</span>);
<a name="l02002"></a>02002     <span class="keywordflow">goto</span> exitNow;
<a name="l02003"></a>02003   }
<a name="l02004"></a>02004   
<a name="l02005"></a>02005   stringU16Length = (NSUInteger)CFStringGetLength((CFStringRef)matchString);
<a name="l02006"></a>02006   
<a name="l02007"></a>02007   <span class="keywordflow">if</span>(RKL_EXPECTED(matchRange.length == NSUIntegerMax,          1L)) { matchRange.length = stringU16Length; } <span class="comment">// For convenience.</span>
<a name="l02008"></a>02008   <span class="keywordflow">if</span>(RKL_EXPECTED(stringU16Length    &lt; NSMaxRange(matchRange), 0L)) { exception = (id)RKL_EXCEPTION(NSRangeException, <span class="stringliteral">@&quot;Range or index out of bounds.&quot;</span>);  <span class="keywordflow">goto</span> exitNow; }
<a name="l02009"></a>02009   <span class="keywordflow">if</span>(RKL_EXPECTED(stringU16Length   &gt;= (NSUInteger)INT_MAX,    0L)) { exception = (id)RKL_EXCEPTION(NSRangeException, <span class="stringliteral">@&quot;String length exceeds INT_MAX.&quot;</span>); <span class="keywordflow">goto</span> exitNow; }
<a name="l02010"></a>02010   
<a name="l02011"></a>02011   RKLCDelayedAssert((<span class="keyword">self</span> != NULL) &amp;&amp; (_cmd != NULL) &amp;&amp; ((blockEnumerationOp == RKLBlockEnumerationMatchOp) ? (((regexOp == RKLCapturesArrayOp) || (regexOp == RKLSplitOp)) &amp;&amp; (stringsAndRangesBlock != NULL) &amp;&amp; (replaceStringsAndRangesBlock == NULL)) : 1) &amp;&amp; ((blockEnumerationOp == RKLBlockEnumerationReplaceOp) ? ((regexOp == RKLCapturesArrayOp) &amp;&amp; (stringsAndRangesBlock == NULL) &amp;&amp; (replaceStringsAndRangesBlock != NULL)) : 1) , &amp;exception, exitNow);
<a name="l02012"></a>02012 
<a name="l02013"></a>02013   <span class="keywordflow">if</span>((rkl_collectingEnabled() == NO) &amp;&amp; RKL_EXPECTED((autoreleaseArray = rkl_CFAutorelease(CFArrayCreateMutable(NULL, 0L, &amp;rkl_transferOwnershipArrayCallBacks))) == NULL, 0L))          { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Warning about potential leak of Core Foundation object can be safely ignored.</span>
<a name="l02014"></a>02014   <span class="keywordflow">if</span>(RKL_EXPECTED((blockEnumerationHelper = [[RKLBlockEnumerationHelper alloc] initWithRegex:regexString options:options <span class="keywordtype">string</span>:matchString range:matchRange error:error]) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Warning about potential leak of blockEnumerationHelper can be safely ignored.</span>
<a name="l02015"></a>02015   <span class="keywordflow">if</span>(autoreleaseArray != NULL) { CFArrayAppendValue((CFMutableArrayRef)autoreleaseArray, blockEnumerationHelper); autoreleaseReplaceRange.location++; } <span class="comment">// We do not autorelease blockEnumerationHelper, but instead add it to autoreleaseArray.</span>
<a name="l02016"></a>02016   
<a name="l02017"></a>02017   <span class="keywordflow">if</span>(performStringReplacement == YES) {
<a name="l02018"></a>02018     <span class="keywordflow">if</span>(RKL_EXPECTED((mutableReplacementString = [[<a class="code" href="a00014.html">NSMutableString</a> alloc] init]) == NULL, 0L)) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Warning about potential leak of mutableReplacementString can be safely ignored.</span>
<a name="l02019"></a>02019     <span class="keywordflow">if</span>(autoreleaseArray != NULL) { CFArrayAppendValue((CFMutableArrayRef)autoreleaseArray, mutableReplacementString); autoreleaseReplaceRange.location++; } <span class="comment">// We do not autorelease mutableReplacementString, but instead add it to autoreleaseArray.</span>
<a name="l02020"></a>02020   }
<a name="l02021"></a>02021 
<a name="l02022"></a>02022   <span class="comment">// RKLBlockEnumerationHelper creates an immutable copy of the string to match (matchString) which we reference via blockEnumerationHelperString.  We use blockEnumerationHelperString when creating the captured strings from a match.</span>
<a name="l02023"></a>02023   <span class="comment">// This protects us against the user mutating matchString while we are in the middle of enumerating matches.</span>
<a name="l02024"></a>02024   <a class="code" href="a00025.html">NSString</a>           * RKL_GC_VOLATILE blockEnumerationHelperString = (<a class="code" href="a00025.html">NSString</a> *)blockEnumerationHelper-&gt;buffer.string, ** RKL_GC_VOLATILE capturedStrings = NULL, *emptyString = <span class="stringliteral">@&quot;&quot;</span>;
<a name="l02025"></a>02025   CFMutableStringRef * RKL_GC_VOLATILE fastCapturedStrings          = NULL;
<a name="l02026"></a>02026   NSInteger  captureCountBlockArgument = (blockEnumerationHelper-&gt;cachedRegex.captureCount + 1L);
<a name="l02027"></a>02027   <span class="keywordtype">size_t</span>     capturedStringsCapacity   = ((size_t)captureCountBlockArgument + 4UL);
<a name="l02028"></a>02028   <span class="keywordtype">size_t</span>     capturedRangesCapacity    = (((size_t)captureCountBlockArgument + 4UL) * 5UL);
<a name="l02029"></a>02029   NSRange   *capturedRanges            = NULL;
<a name="l02030"></a>02030 
<a name="l02031"></a>02031   lastMatchedRange              = NSMakeRange(matchRange.location, 0UL);
<a name="l02032"></a>02032   blockEnumerationHelperUniChar = blockEnumerationHelper-&gt;buffer.uniChar;
<a name="l02033"></a>02033   
<a name="l02034"></a>02034   RKLCDelayedAssert((blockEnumerationHelperString != NULL) &amp;&amp; (blockEnumerationHelperUniChar != NULL) &amp;&amp; (captureCountBlockArgument &gt; 0L) &amp;&amp; (capturedStringsCapacity &gt; 0UL) &amp;&amp; (capturedRangesCapacity &gt; 0UL), &amp;exception, exitNow);
<a name="l02035"></a>02035   
<a name="l02036"></a>02036   <span class="keywordflow">if</span>((capturedStrings = (<a class="code" href="a00025.html">NSString</a> ** RKL_GC_VOLATILE)alloca(<span class="keyword">sizeof</span>(<a class="code" href="a00025.html">NSString</a> *) * capturedStringsCapacity)) == NULL) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Space to hold the captured strings from a match.</span>
<a name="l02037"></a>02037   <span class="keywordflow">if</span>((capturedRanges  = (NSRange *)                  alloca(<span class="keyword">sizeof</span>(NSRange)    * capturedRangesCapacity))  == NULL) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Space to hold the NSRanges of the captured strings from a match.</span>
<a name="l02038"></a>02038   
<a name="l02039"></a>02039 <span class="preprocessor">#ifdef NS_BLOCK_ASSERTIONS</span>
<a name="l02040"></a>02040 <span class="preprocessor"></span>  { <span class="comment">// Initialize the padded capturedStrings and capturedRanges to values that should tickle a fault if they are ever used.</span>
<a name="l02041"></a>02041     <span class="keywordtype">size_t</span> idx = 0UL;
<a name="l02042"></a>02042     <span class="keywordflow">for</span>(idx = captureCountBlockArgument; idx &lt; capturedStringsCapacity; idx++) { capturedStrings[idx] = (<a class="code" href="a00025.html">NSString</a> *)RKLIllegalPointer; }
<a name="l02043"></a>02043     <span class="keywordflow">for</span>(idx = captureCountBlockArgument; idx &lt; capturedRangesCapacity;  idx++) { capturedRanges[idx]  =             RKLIllegalRange;   }
<a name="l02044"></a>02044   }
<a name="l02045"></a>02045 <span class="preprocessor">#else</span>
<a name="l02046"></a>02046 <span class="preprocessor"></span>  { <span class="comment">// Initialize all of the capturedStrings and capturedRanges to values that should tickle a fault if they are ever used.</span>
<a name="l02047"></a>02047     <span class="keywordtype">size_t</span> idx = 0UL;
<a name="l02048"></a>02048     <span class="keywordflow">for</span>(idx = 0UL; idx &lt; capturedStringsCapacity; idx++) { capturedStrings[idx] = (<a class="code" href="a00025.html">NSString</a> *)RKLIllegalPointer; }
<a name="l02049"></a>02049     <span class="keywordflow">for</span>(idx = 0UL; idx &lt; capturedRangesCapacity;  idx++) { capturedRanges[idx]  =             RKLIllegalRange;   }
<a name="l02050"></a>02050   }
<a name="l02051"></a>02051 <span class="preprocessor">#endif</span>
<a name="l02052"></a>02052 <span class="preprocessor"></span>  
<a name="l02053"></a>02053   <span class="keywordflow">if</span>((enumerationOptions &amp; RKLRegexEnumerationFastCapturedStringsXXX) != 0UL) {
<a name="l02054"></a>02054     RKLCDelayedAssert(((enumerationOptions &amp; RKLRegexEnumerationCapturedStringsNotRequired) == 0UL), &amp;exception, exitNow);
<a name="l02055"></a>02055     <span class="keywordtype">size_t</span> idx = 0UL;
<a name="l02056"></a>02056     <span class="keywordflow">if</span>((fastCapturedStrings = (CFMutableStringRef * RKL_GC_VOLATILE)alloca(<span class="keyword">sizeof</span>(<a class="code" href="a00025.html">NSString</a> *) * capturedStringsCapacity)) == NULL) { <span class="keywordflow">goto</span> exitNow; } <span class="comment">// Space to hold the &quot;fast&quot; captured strings from a match.</span>
<a name="l02057"></a>02057 
<a name="l02058"></a>02058     <span class="keywordflow">for</span>(idx = 0UL; idx &lt; (size_t)captureCountBlockArgument; idx++) {
<a name="l02059"></a>02059       <span class="keywordflow">if</span>((fastCapturedStrings[idx] = CFStringCreateMutableWithExternalCharactersNoCopy(NULL, NULL, 0L, 0L, kCFAllocatorNull)) == NULL) { <span class="keywordflow">goto</span> exitNow; }
<a name="l02060"></a>02060       <span class="keywordflow">if</span>(autoreleaseArray != NULL) { CFArrayAppendValue((CFMutableArrayRef)autoreleaseArray, fastCapturedStrings[idx]); autoreleaseReplaceRange.location++; } <span class="comment">// We do not autorelease mutableReplacementString, but instead add it to autoreleaseArray.</span>
<a name="l02061"></a>02061       capturedStrings[idx] = (<a class="code" href="a00025.html">NSString</a> *)fastCapturedStrings[idx];
<a name="l02062"></a>02062     }
<a name="l02063"></a>02063   }
<a name="l02064"></a>02064 
<a name="l02065"></a>02065   <a class="code" href="a00029.html">RKLFindAll</a> findAll = rkl_makeFindAll(capturedRanges, matchRange, (NSInteger)capturedRangesCapacity, (capturedRangesCapacity * <span class="keyword">sizeof</span>(NSRange)), 0UL, &amp;blockEnumerationHelper-&gt;scratchBuffer[0], &amp;blockEnumerationHelper-&gt;scratchBuffer[1], &amp;blockEnumerationHelper-&gt;scratchBuffer[2], &amp;blockEnumerationHelper-&gt;scratchBuffer[3], &amp;blockEnumerationHelper-&gt;scratchBuffer[4], 0L, 0L, 1L);
<a name="l02066"></a>02066   
<a name="l02067"></a>02067   <a class="code" href="a00025.html">NSString</a> ** RKL_GC_VOLATILE capturedStringsBlockArgument = NULL; <span class="comment">// capturedStringsBlockArgument is what we pass to the &#39;capturedStrings[]&#39; argument of the users ^block.  Will pass NULL if the user doesn&#39;t want the captured strings created automatically.</span>
<a name="l02068"></a>02068   <span class="keywordflow">if</span>((enumerationOptions &amp; RKLRegexEnumerationCapturedStringsNotRequired) == 0UL) { capturedStringsBlockArgument = capturedStrings; } <span class="comment">// If the user wants the captured strings automatically created, set to capturedStrings.</span>
<a name="l02069"></a>02069   
<a name="l02070"></a>02070   replacedCount = 0L;
<a name="l02071"></a>02071   <span class="keywordflow">while</span>(RKL_EXPECTED(rkl_findRanges(&amp;blockEnumerationHelper-&gt;cachedRegex, regexOp, &amp;findAll, &amp;exception, &amp;status) == NO, 1L) &amp;&amp; RKL_EXPECTED(findAll.found &gt; 0L, 1L) &amp;&amp; RKL_EXPECTED(exception == NULL, 1L) &amp;&amp; RKL_EXPECTED(status == U_ZERO_ERROR, 1L)) {
<a name="l02072"></a>02072     <span class="keywordflow">if</span>(performStringReplacement == YES) {
<a name="l02073"></a>02073       NSUInteger lastMatchedMaxLocation = (lastMatchedRange.location + lastMatchedRange.length);
<a name="l02074"></a>02074       NSRange    previousUnmatchedRange = NSMakeRange(lastMatchedMaxLocation, findAll.ranges[0].location - lastMatchedMaxLocation);
<a name="l02075"></a>02075       RKLCDelayedAssert((NSMaxRange(previousUnmatchedRange) &lt;= stringU16Length) &amp;&amp; (NSRangeInsideRange(previousUnmatchedRange, matchRange) == YES), &amp;exception, exitNow);
<a name="l02076"></a>02076       <span class="keywordflow">if</span>(RKL_EXPECTED(previousUnmatchedRange.length &gt; 0UL, 1L)) { CFStringAppendCharacters((CFMutableStringRef)mutableReplacementString, blockEnumerationHelperUniChar + previousUnmatchedRange.location, (CFIndex)previousUnmatchedRange.length); }
<a name="l02077"></a>02077     }
<a name="l02078"></a>02078 
<a name="l02079"></a>02079     findAll.found -= findAll.addedSplitRanges;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081     NSInteger passCaptureCountBlockArgument = ((findAll.found == 0L) &amp;&amp; (findAll.addedSplitRanges == 1L) &amp;&amp; (maskedRegexOp == RKLSplitOp)) ? 1L : findAll.found, capturedStringsIdx = passCaptureCountBlockArgument;
<a name="l02082"></a>02082     RKLCDelayedHardAssert(passCaptureCountBlockArgument &lt;= captureCountBlockArgument, &amp;exception, exitNow);
<a name="l02083"></a>02083     <span class="keywordflow">if</span>(capturedStringsBlockArgument != NULL) { <span class="comment">// Only create the captured strings if the user has requested them.</span>
<a name="l02084"></a>02084       BOOL hadError = NO;                      <span class="comment">// Loop over all the strings rkl_findRanges found.  If rkl_CreateStringWithSubstring() returns NULL due to an error, set returnBool to NO, and break out of the for() loop.</span>
<a name="l02085"></a>02085 
<a name="l02086"></a>02086       <span class="keywordflow">for</span>(capturedStringsIdx = 0L; capturedStringsIdx &lt; passCaptureCountBlockArgument; capturedStringsIdx++) {
<a name="l02087"></a>02087         RKLCDelayedHardAssert(capturedStringsIdx &lt; captureCountBlockArgument, &amp;exception, exitNow);
<a name="l02088"></a>02088         <span class="keywordflow">if</span>((enumerationOptions &amp; RKLRegexEnumerationFastCapturedStringsXXX) != 0UL) {
<a name="l02089"></a>02089           <span class="comment">// Analyzer report of &quot;Dereference of null pointer&quot; can be safely ignored for the next line.  Bug filed: http://llvm.org/bugs/show_bug.cgi?id=6150</span>
<a name="l02090"></a>02090           CFStringSetExternalCharactersNoCopy(fastCapturedStrings[capturedStringsIdx], &amp;blockEnumerationHelperUniChar[findAll.ranges[capturedStringsIdx].location], (CFIndex)findAll.ranges[capturedStringsIdx].length, (CFIndex)findAll.ranges[capturedStringsIdx].length);
<a name="l02091"></a>02091         } <span class="keywordflow">else</span> {
<a name="l02092"></a>02092           <span class="keywordflow">if</span>((capturedStrings[capturedStringsIdx] = (findAll.ranges[capturedStringsIdx].length == 0UL) ? emptyString : rkl_CreateStringWithSubstring(blockEnumerationHelperString, findAll.ranges[capturedStringsIdx])) == NULL) { hadError = YES; <span class="keywordflow">break</span>; }
<a name="l02093"></a>02093         }
<a name="l02094"></a>02094       }
<a name="l02095"></a>02095       <span class="keywordflow">if</span>(((enumerationOptions &amp; RKLRegexEnumerationFastCapturedStringsXXX) == 0UL) &amp;&amp; RKL_EXPECTED(autoreleaseArray != NULL, 1L)) { CFArrayReplaceValues((CFMutableArrayRef)autoreleaseArray, autoreleaseReplaceRange, (<span class="keyword">const</span> <span class="keywordtype">void</span> **)capturedStrings, capturedStringsIdx); autoreleaseReplaceRange.length = capturedStringsIdx; } <span class="comment">// Add to autoreleaseArray all the strings the for() loop created.</span>
<a name="l02096"></a>02096       <span class="keywordflow">if</span>(RKL_EXPECTED(hadError == YES,  0L)) { <span class="keywordflow">goto</span> exitNow; }           <span class="comment">// hadError == YES will be set if rkl_CreateStringWithSubstring() returned NULL.</span>
<a name="l02097"></a>02097     }
<a name="l02098"></a>02098     <span class="comment">// For safety, set any capturedRanges and capturedStrings up to captureCountBlockArgument + 1 to values that indicate that they are not valid.</span>
<a name="l02099"></a>02099     <span class="comment">// These values are chosen such that they should tickle any misuse by users.</span>
<a name="l02100"></a>02100     <span class="comment">// capturedStringsIdx is initialized to passCaptureCountBlockArgument, but if capturedStringsBlockArgument != NULL, it is reset to 0 by the loop that creates strings.</span>
<a name="l02101"></a>02101     <span class="comment">// If the loop that creates strings has an error, execution should transfer to exitNow and this will never get run.</span>
<a name="l02102"></a>02102     <span class="comment">// Again, this is for safety for users that do not check the passed block argument &#39;captureCount&#39; and instead depend on something like [regex captureCount].</span>
<a name="l02103"></a>02103     <span class="keywordflow">for</span>(; capturedStringsIdx &lt; captureCountBlockArgument + 1L; capturedStringsIdx++) { RKLCDelayedAssert((capturedStringsIdx &lt; (NSInteger)capturedStringsCapacity) &amp;&amp; (capturedStringsIdx &lt; (NSInteger)capturedRangesCapacity), &amp;exception, exitNow); capturedRanges[capturedStringsIdx] = RKLIllegalRange; capturedStrings[capturedStringsIdx] = (<a class="code" href="a00025.html">NSString</a> *)RKLIllegalPointer; }
<a name="l02104"></a>02104 
<a name="l02105"></a>02105     RKLCDelayedAssert((passCaptureCountBlockArgument &gt; 0L) &amp;&amp; (NSMaxRange(capturedRanges[0]) &lt;= stringU16Length) &amp;&amp; (capturedRanges[0].location &lt; NSIntegerMax) &amp;&amp; (capturedRanges[0].length &lt; NSIntegerMax), &amp;exception, exitNow);
<a name="l02106"></a>02106 
<a name="l02107"></a>02107     <span class="keywordflow">switch</span>(blockEnumerationOp) {
<a name="l02108"></a>02108       <span class="keywordflow">case</span> RKLBlockEnumerationMatchOp: stringsAndRangesBlock(passCaptureCountBlockArgument, capturedStringsBlockArgument, capturedRanges, &amp;shouldStop); <span class="keywordflow">break</span>;
<a name="l02109"></a>02109 
<a name="l02110"></a>02110       <span class="keywordflow">case</span> RKLBlockEnumerationReplaceOp: {
<a name="l02111"></a>02111           <a class="code" href="a00025.html">NSString</a> *blockReturnedReplacementString = replaceStringsAndRangesBlock(passCaptureCountBlockArgument, capturedStringsBlockArgument, capturedRanges, &amp;shouldStop);
<a name="l02112"></a>02112     
<a name="l02113"></a>02113           <span class="keywordflow">if</span>(RKL_EXPECTED(blockReturnedReplacementString != NULL, 1L)) {
<a name="l02114"></a>02114             CFStringAppend((CFMutableStringRef)mutableReplacementString, (CFStringRef)blockReturnedReplacementString);
<a name="l02115"></a>02115             BOOL shouldRelease = (((enumerationOptions &amp; RKLRegexEnumerationReleaseStringReturnedByReplacementBlock) != 0UL) &amp;&amp; (capturedStringsBlockArgument != NULL) &amp;&amp; (rkl_collectingEnabled() == NO)) ? YES : NO;
<a name="l02116"></a>02116             <span class="keywordflow">if</span>(shouldRelease == YES) { NSInteger idx = 0L; <span class="keywordflow">for</span>(idx = 0L; idx &lt; passCaptureCountBlockArgument; idx++) { <span class="keywordflow">if</span>(capturedStrings[idx] == blockReturnedReplacementString) { shouldRelease = NO; <span class="keywordflow">break</span>; } } }
<a name="l02117"></a>02117             <span class="keywordflow">if</span>(shouldRelease == YES) { [blockReturnedReplacementString release]; }
<a name="l02118"></a>02118           }
<a name="l02119"></a>02119       }
<a name="l02120"></a>02120       <span class="keywordflow">break</span>;
<a name="l02121"></a>02121 
<a name="l02122"></a>02122       <span class="keywordflow">default</span>: exception = RKLCAssertDictionary(<span class="stringliteral">@&quot;Unknown blockEnumerationOp code.&quot;</span>); <span class="keywordflow">goto</span> exitNow; <span class="keywordflow">break</span>;
<a name="l02123"></a>02123     }
<a name="l02124"></a>02124     
<a name="l02125"></a>02125     replacedCount++;    
<a name="l02126"></a>02126     findAll.addedSplitRanges = 0L;                     <span class="comment">// rkl_findRanges() expects findAll.addedSplitRanges to be 0 on entry.</span>
<a name="l02127"></a>02127     findAll.found            = 0L;                     <span class="comment">// rkl_findRanges() expects findAll.found to be 0 on entry.</span>
<a name="l02128"></a>02128     findAll.findInRange      = findAll.remainingRange; <span class="comment">// Ask rkl_findRanges() to search the part of the string after the current match.</span>
<a name="l02129"></a>02129     lastMatchedRange         = findAll.ranges[0];
<a name="l02130"></a>02130 
<a name="l02131"></a>02131     <span class="keywordflow">if</span>(RKL_EXPECTED(shouldStop != NO, 0L)) { <span class="keywordflow">break</span>; }
<a name="l02132"></a>02132   }
<a name="l02133"></a>02133   errorFree = YES;
<a name="l02134"></a>02134   
<a name="l02135"></a>02135 exitNow:
<a name="l02136"></a>02136   <span class="keywordflow">if</span>(RKL_EXPECTED(errorFree == NO, 0L)) { replacedCount = -1L; }
<a name="l02137"></a>02137   <span class="keywordflow">if</span>((blockEnumerationOp == RKLBlockEnumerationReplaceOp) &amp;&amp; RKL_EXPECTED(errorFree == YES, 1L)) {
<a name="l02138"></a>02138     RKLCDelayedAssert(replacedCount &gt;= 0L, &amp;exception, exitNow2);
<a name="l02139"></a>02139     <span class="keywordflow">if</span>(RKL_EXPECTED(replacedCount == 0UL, 0L)) {
<a name="l02140"></a>02140       RKLCDelayedAssert((blockEnumerationHelper != NULL) &amp;&amp; (blockEnumerationHelper-&gt;buffer.string != NULL), &amp;exception, exitNow2);
<a name="l02141"></a>02141       returnObject = rkl_CreateStringWithSubstring((<span class="keywordtype">id</span>)blockEnumerationHelper-&gt;buffer.string, matchRange);
<a name="l02142"></a>02142       <span class="keywordflow">if</span>(rkl_collectingEnabled() == NO) { returnObject = rkl_CFAutorelease(returnObject); }
<a name="l02143"></a>02143     }
<a name="l02144"></a>02144     <span class="keywordflow">else</span> {
<a name="l02145"></a>02145       NSUInteger lastMatchedMaxLocation = (lastMatchedRange.location + lastMatchedRange.length);
<a name="l02146"></a>02146       NSRange    previousUnmatchedRange = NSMakeRange(lastMatchedMaxLocation, NSMaxRange(matchRange) - lastMatchedMaxLocation);
<a name="l02147"></a>02147       RKLCDelayedAssert((NSMaxRange(previousUnmatchedRange) &lt;= stringU16Length) &amp;&amp; (NSRangeInsideRange(previousUnmatchedRange, matchRange) == YES), &amp;exception, exitNow2);
<a name="l02148"></a>02148       
<a name="l02149"></a>02149       <span class="keywordflow">if</span>(RKL_EXPECTED(previousUnmatchedRange.length &gt; 0UL, 1L)) { CFStringAppendCharacters((CFMutableStringRef)mutableReplacementString, blockEnumerationHelperUniChar + previousUnmatchedRange.location, (CFIndex)previousUnmatchedRange.length); }
<a name="l02150"></a>02150       returnObject = rkl_CFAutorelease(CFStringCreateCopy(NULL, (CFStringRef)mutableReplacementString)); <span class="comment">// Warning about potential leak of Core Foundation object can be safely ignored.</span>
<a name="l02151"></a>02151     }
<a name="l02152"></a>02152   }
<a name="l02153"></a>02153   
<a name="l02154"></a>02154 <span class="preprocessor">#ifndef   NS_BLOCK_ASSERTIONS</span>
<a name="l02155"></a>02155 <span class="preprocessor"></span>exitNow2:
<a name="l02156"></a>02156 <span class="preprocessor">#endif // NS_BLOCK_ASSERTIONS</span>
<a name="l02157"></a>02157 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(RKL_EXPECTED(autoreleaseArray != NULL, 1L)) { CFArrayRemoveAllValues((CFMutableArrayRef)autoreleaseArray); } <span class="comment">// Causes blockEnumerationHelper to be released immediately, freeing all of its resources (such as a large UTF-16 conversion buffer).</span>
<a name="l02158"></a>02158   <span class="keywordflow">if</span>(RKL_EXPECTED(exception        != NULL, 0L)) { rkl_handleDelayedAssert(<span class="keyword">self</span>, _cmd, exception);              } <span class="comment">// If there is an exception, throw it at this point.</span>
<a name="l02159"></a>02159   <span class="keywordflow">if</span>(((errorFree == NO) || ((errorFree == YES) &amp;&amp; (returnObject == NULL))) &amp;&amp; (error != NULL) &amp;&amp; (*error == NULL)) {
<a name="l02160"></a>02160     RKLUserInfoOptions  userInfoOptions = (RKLUserInfoSubjectRange | RKLUserInfoRegexEnumerationOptions);
<a name="l02161"></a>02161     <a class="code" href="a00025.html">NSString</a>           *replacedString  = NULL;
<a name="l02162"></a>02162     <span class="keywordflow">if</span>(blockEnumerationOp == RKLBlockEnumerationReplaceOp) { userInfoOptions |= RKLUserInfoReplacedCount; <span class="keywordflow">if</span>(RKL_EXPECTED(errorFree == YES, 1L)) { replacedString = returnObject; } }
<a name="l02163"></a>02163     *error = rkl_makeNSError(userInfoOptions, regexString, options, NULL, status, (blockEnumerationHelper != NULL) ? (blockEnumerationHelper-&gt;buffer.string != NULL) ? (<a class="code" href="a00025.html">NSString</a> *)blockEnumerationHelper-&gt;buffer.string : matchString : matchString, matchRange, NULL, replacedString, replacedCount, enumerationOptions, <span class="stringliteral">@&quot;An unexpected error occurred.&quot;</span>);
<a name="l02164"></a>02164   }
<a name="l02165"></a>02165   <span class="keywordflow">if</span>(replacedCountPtr != NULL) { *replacedCountPtr = replacedCount; }
<a name="l02166"></a>02166   <span class="keywordflow">if</span>(errorFreePtr     != NULL) { *errorFreePtr     = errorFree;     }
<a name="l02167"></a>02167   <span class="keywordflow">return</span>(returnObject);
<a name="l02168"></a>02168 } <span class="comment">// The two warnings about potential leaks can be safely ignored.</span>
<a name="l02169"></a>02169 
<a name="l02170"></a>02170 <span class="preprocessor">#endif // _RKL_BLOCKS_ENABLED</span>
<a name="l02171"></a>02171 <span class="preprocessor"></span>
<a name="l02173"></a>02173 <span class="preprocessor">#pragma mark -</span>
<a name="l02174"></a>02174 <span class="preprocessor"></span><span class="preprocessor">#pragma mark Objective-C Public Interface</span>
<a name="l02175"></a>02175 <span class="preprocessor"></span><span class="preprocessor">#pragma mark -</span>
<a name="l02176"></a>02176 <span class="preprocessor"></span>
<a name="l02177"></a>02177 
<a name="l02178"></a><a class="code" href="a00025.html">02178</a> <span class="keyword">@implementation </span><a class="code" href="a00025.html">NSString</a> (RegexKitLiteAdditions)
<a name="l02179"></a>02179 
<a name="l02180"></a>02180 <span class="preprocessor">#pragma mark +clearStringCache</span>
<a name="l02181"></a>02181 <span class="preprocessor"></span>
<a name="l02182"></a>02182 + (void)RKL_METHOD_PREPEND(clearStringCache)
<a name="l02183"></a>02183 {
<a name="l02184"></a>02184   <span class="keyword">volatile</span> NSUInteger RKL_CLEANUP(rkl_cleanup_cacheSpinLockStatus) rkl_cacheSpinLockStatus = 0UL;
<a name="l02185"></a>02185   OSSpinLockLock(&amp;rkl_cacheSpinLock);
<a name="l02186"></a>02186   rkl_cacheSpinLockStatus |= RKLLockedCacheSpinLock;
<a name="l02187"></a>02187   rkl_clearStringCache();
<a name="l02188"></a>02188   OSSpinLockUnlock(&amp;rkl_cacheSpinLock);
<a name="l02189"></a>02189   rkl_cacheSpinLockStatus |= RKLUnlockedCacheSpinLock; <span class="comment">// Warning about rkl_cacheSpinLockStatus never being read can be safely ignored.</span>
<a name="l02190"></a>02190 }
<a name="l02191"></a>02191 
<a name="l02192"></a>02192 <span class="preprocessor">#pragma mark +captureCountForRegex:</span>
<a name="l02193"></a>02193 <span class="preprocessor"></span>
<a name="l02194"></a>02194 + (NSInteger)RKL_METHOD_PREPEND(captureCountForRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02195"></a>02195 {
<a name="l02196"></a>02196   NSInteger captureCount = -1L;
<a name="l02197"></a>02197   rkl_isRegexValid(<span class="keyword">self</span>, _cmd, regex, RKLNoOptions, &amp;captureCount, NULL);
<a name="l02198"></a>02198   <span class="keywordflow">return</span>(captureCount);
<a name="l02199"></a>02199 }
<a name="l02200"></a>02200 
<a name="l02201"></a>02201 + (NSInteger)RKL_METHOD_PREPEND(captureCountForRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options error:(NSError **)error
<a name="l02202"></a>02202 {
<a name="l02203"></a>02203   NSInteger captureCount = -1L;
<a name="l02204"></a>02204   rkl_isRegexValid(<span class="keyword">self</span>, _cmd, regex, options,      &amp;captureCount, error);
<a name="l02205"></a>02205   <span class="keywordflow">return</span>(captureCount);
<a name="l02206"></a>02206 }
<a name="l02207"></a>02207 
<a name="l02208"></a>02208 <span class="preprocessor">#pragma mark -captureCount:</span>
<a name="l02209"></a>02209 <span class="preprocessor"></span>
<a name="l02210"></a>02210 - (NSInteger)RKL_METHOD_PREPEND(captureCount)
<a name="l02211"></a>02211 {
<a name="l02212"></a>02212   NSInteger captureCount = -1L;
<a name="l02213"></a>02213   rkl_isRegexValid(<span class="keyword">self</span>, _cmd, <span class="keyword">self</span>, RKLNoOptions,  &amp;captureCount, NULL);
<a name="l02214"></a>02214   <span class="keywordflow">return</span>(captureCount);
<a name="l02215"></a>02215 }
<a name="l02216"></a>02216 
<a name="l02217"></a>02217 - (NSInteger)RKL_METHOD_PREPEND(captureCountWithOptions):(RKLRegexOptions)options error:(NSError **)error
<a name="l02218"></a>02218 {
<a name="l02219"></a>02219   NSInteger captureCount = -1L;
<a name="l02220"></a>02220   rkl_isRegexValid(<span class="keyword">self</span>, _cmd, <span class="keyword">self</span>, options,       &amp;captureCount, error);
<a name="l02221"></a>02221   <span class="keywordflow">return</span>(captureCount);
<a name="l02222"></a>02222 }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 <span class="preprocessor">#pragma mark -componentsSeparatedByRegex:</span>
<a name="l02225"></a>02225 <span class="preprocessor"></span>
<a name="l02226"></a>02226 - (NSArray *)RKL_METHOD_PREPEND(componentsSeparatedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02227"></a>02227 {
<a name="l02228"></a>02228   NSRange range = NSMaxiumRange;
<a name="l02229"></a>02229   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLSplitOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range, NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02230"></a>02230 }
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 - (NSArray *)RKL_METHOD_PREPEND(componentsSeparatedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex range:(NSRange)range
<a name="l02233"></a>02233 {
<a name="l02234"></a>02234   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLSplitOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range, NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 - (NSArray *)RKL_METHOD_PREPEND(componentsSeparatedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error
<a name="l02238"></a>02238 {
<a name="l02239"></a>02239   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLSplitOp, regex, options,      0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, 0UL, NULL, NULL));
<a name="l02240"></a>02240 }
<a name="l02241"></a>02241 
<a name="l02242"></a>02242 <span class="preprocessor">#pragma mark -isMatchedByRegex:</span>
<a name="l02243"></a>02243 <span class="preprocessor"></span>
<a name="l02244"></a>02244 - (BOOL)RKL_METHOD_PREPEND(isMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02245"></a>02245 {
<a name="l02246"></a>02246   NSRange result = NSNotFoundRange, range = NSMaxiumRange;
<a name="l02247"></a>02247   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;result, 0UL, NULL, NULL);
<a name="l02248"></a>02248   <span class="keywordflow">return</span>((result.location == (NSUInteger)NSNotFound) ? NO : YES);
<a name="l02249"></a>02249 }
<a name="l02250"></a>02250 
<a name="l02251"></a>02251 - (BOOL)RKL_METHOD_PREPEND(isMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex inRange:(NSRange)range
<a name="l02252"></a>02252 {
<a name="l02253"></a>02253   NSRange result = NSNotFoundRange;
<a name="l02254"></a>02254   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;result, 0UL, NULL, NULL);
<a name="l02255"></a>02255   <span class="keywordflow">return</span>((result.location == (NSUInteger)NSNotFound) ? NO : YES);
<a name="l02256"></a>02256 }
<a name="l02257"></a>02257 
<a name="l02258"></a>02258 - (BOOL)RKL_METHOD_PREPEND(isMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range error:(NSError **)error
<a name="l02259"></a>02259 {
<a name="l02260"></a>02260   NSRange result = NSNotFoundRange;
<a name="l02261"></a>02261   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, options,      0L, <span class="keyword">self</span>, &amp;range, NULL, error, &amp;result, 0UL, NULL, NULL);
<a name="l02262"></a>02262   <span class="keywordflow">return</span>((result.location == (NSUInteger)NSNotFound) ? NO : YES);
<a name="l02263"></a>02263 }
<a name="l02264"></a>02264 
<a name="l02265"></a>02265 <span class="preprocessor">#pragma mark -isRegexValid</span>
<a name="l02266"></a>02266 <span class="preprocessor"></span>
<a name="l02267"></a>02267 - (BOOL)RKL_METHOD_PREPEND(isRegexValid)
<a name="l02268"></a>02268 {
<a name="l02269"></a>02269   <span class="keywordflow">return</span>(rkl_isRegexValid(<span class="keyword">self</span>, _cmd, <span class="keyword">self</span>, RKLNoOptions, NULL, NULL)  == 1UL ? YES : NO);
<a name="l02270"></a>02270 }
<a name="l02271"></a>02271 
<a name="l02272"></a>02272 - (BOOL)RKL_METHOD_PREPEND(isRegexValidWithOptions):(RKLRegexOptions)options error:(NSError **)error
<a name="l02273"></a>02273 {
<a name="l02274"></a>02274   <span class="keywordflow">return</span>(rkl_isRegexValid(<span class="keyword">self</span>, _cmd, <span class="keyword">self</span>, options,      NULL, error) == 1UL ? YES : NO);
<a name="l02275"></a>02275 }
<a name="l02276"></a>02276 
<a name="l02277"></a>02277 <span class="preprocessor">#pragma mark -flushCachedRegexData</span>
<a name="l02278"></a>02278 <span class="preprocessor"></span>
<a name="l02279"></a>02279 - (void)RKL_METHOD_PREPEND(flushCachedRegexData)
<a name="l02280"></a>02280 {
<a name="l02281"></a>02281   <span class="keyword">volatile</span> NSUInteger RKL_CLEANUP(rkl_cleanup_cacheSpinLockStatus) rkl_cacheSpinLockStatus = 0UL;
<a name="l02282"></a>02282 
<a name="l02283"></a>02283   CFIndex    selfLength = CFStringGetLength((CFStringRef)self);
<a name="l02284"></a>02284   CFHashCode selfHash   = CFHash((CFTypeRef)self);
<a name="l02285"></a>02285   
<a name="l02286"></a>02286   OSSpinLockLock(&amp;rkl_cacheSpinLock);
<a name="l02287"></a>02287   rkl_cacheSpinLockStatus |= RKLLockedCacheSpinLock;
<a name="l02288"></a>02288   rkl_dtrace_incrementEventID();
<a name="l02289"></a>02289 
<a name="l02290"></a>02290   NSUInteger idx;
<a name="l02291"></a>02291   for(idx = 0UL; idx &lt; _RKL_REGEX_CACHE_LINES; idx++) {
<a name="l02292"></a>02292     <a class="code" href="a00028.html">RKLCachedRegex</a> *cachedRegex = &amp;rkl_cachedRegexes[idx];
<a name="l02293"></a>02293     <span class="keywordflow">if</span>((cachedRegex-&gt;setToString != NULL) &amp;&amp; ( (cachedRegex-&gt;setToString == (CFStringRef)<span class="keyword">self</span>) || ((cachedRegex-&gt;setToLength == selfLength) &amp;&amp; (cachedRegex-&gt;setToHash == selfHash)) ) ) { rkl_clearCachedRegexSetTo(cachedRegex); }
<a name="l02294"></a>02294   }
<a name="l02295"></a>02295   <span class="keywordflow">for</span>(idx = 0UL; idx &lt; _RKL_LRU_CACHE_SET_WAYS; idx++) { <a class="code" href="a00027.html">RKLBuffer</a> *buffer = &amp;rkl_lruFixedBuffer[idx];   <span class="keywordflow">if</span>((buffer-&gt;string != NULL) &amp;&amp; ((buffer-&gt;string == (CFStringRef)<span class="keyword">self</span>) || ((buffer-&gt;length == selfLength) &amp;&amp; (buffer-&gt;hash == selfHash)))) { rkl_clearBuffer(buffer, 0UL); } }
<a name="l02296"></a>02296   <span class="keywordflow">for</span>(idx = 0UL; idx &lt; _RKL_LRU_CACHE_SET_WAYS; idx++) { <a class="code" href="a00027.html">RKLBuffer</a> *buffer = &amp;rkl_lruDynamicBuffer[idx]; <span class="keywordflow">if</span>((buffer-&gt;string != NULL) &amp;&amp; ((buffer-&gt;string == (CFStringRef)<span class="keyword">self</span>) || ((buffer-&gt;length == selfLength) &amp;&amp; (buffer-&gt;hash == selfHash)))) { rkl_clearBuffer(buffer, 0UL); } }
<a name="l02297"></a>02297 
<a name="l02298"></a>02298   OSSpinLockUnlock(&amp;rkl_cacheSpinLock);
<a name="l02299"></a>02299   rkl_cacheSpinLockStatus |= RKLUnlockedCacheSpinLock; <span class="comment">// Warning about rkl_cacheSpinLockStatus never being read can be safely ignored.</span>
<a name="l02300"></a>02300 }
<a name="l02301"></a>02301 
<a name="l02302"></a>02302 <span class="preprocessor">#pragma mark -rangeOfRegex:</span>
<a name="l02303"></a>02303 <span class="preprocessor"></span>
<a name="l02304"></a>02304 - (NSRange)RKL_METHOD_PREPEND(rangeOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02305"></a>02305 {
<a name="l02306"></a>02306   NSRange result = NSNotFoundRange, range = NSMaxiumRange;
<a name="l02307"></a>02307   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions, 0L,      <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;result, 0UL, NULL, NULL);
<a name="l02308"></a>02308   <span class="keywordflow">return</span>(result);
<a name="l02309"></a>02309 }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311 - (NSRange)RKL_METHOD_PREPEND(rangeOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex capture:(NSInteger)capture
<a name="l02312"></a>02312 {
<a name="l02313"></a>02313   NSRange result = NSNotFoundRange, range = NSMaxiumRange;
<a name="l02314"></a>02314   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions, capture, <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;result, 0UL, NULL, NULL);
<a name="l02315"></a>02315   <span class="keywordflow">return</span>(result);
<a name="l02316"></a>02316 }
<a name="l02317"></a>02317 
<a name="l02318"></a>02318 - (NSRange)RKL_METHOD_PREPEND(rangeOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex inRange:(NSRange)range
<a name="l02319"></a>02319 {
<a name="l02320"></a>02320   NSRange result = NSNotFoundRange;
<a name="l02321"></a>02321   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions, 0L,      <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;result, 0UL, NULL, NULL);
<a name="l02322"></a>02322   <span class="keywordflow">return</span>(result);
<a name="l02323"></a>02323 }
<a name="l02324"></a>02324 
<a name="l02325"></a>02325 - (NSRange)RKL_METHOD_PREPEND(rangeOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range capture:(NSInteger)capture error:(NSError **)error
<a name="l02326"></a>02326 {
<a name="l02327"></a>02327   NSRange result = NSNotFoundRange;
<a name="l02328"></a>02328   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, options,      capture, <span class="keyword">self</span>, &amp;range, NULL, error, &amp;result, 0UL, NULL, NULL);
<a name="l02329"></a>02329   <span class="keywordflow">return</span>(result);
<a name="l02330"></a>02330 }
<a name="l02331"></a>02331 
<a name="l02332"></a>02332 <span class="preprocessor">#pragma mark -stringByMatching:</span>
<a name="l02333"></a>02333 <span class="preprocessor"></span>
<a name="l02334"></a>02334 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByMatching):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02335"></a>02335 {
<a name="l02336"></a>02336   NSRange matchedRange = NSNotFoundRange, range = NSMaxiumRange;
<a name="l02337"></a>02337   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions,      0L,      <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;matchedRange, 0UL, NULL, NULL);
<a name="l02338"></a>02338   <span class="keywordflow">return</span>((matchedRange.location == (NSUInteger)NSNotFound) ? NULL : rkl_CFAutorelease(CFStringCreateWithSubstring(NULL, (CFStringRef)<span class="keyword">self</span>, CFMakeRange(matchedRange.location, matchedRange.length)))); <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02339"></a>02339 } <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02340"></a>02340 
<a name="l02341"></a>02341 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByMatching):(<a class="code" href="a00025.html">NSString</a> *)regex capture:(NSInteger)capture
<a name="l02342"></a>02342 {
<a name="l02343"></a>02343   NSRange matchedRange = NSNotFoundRange, range = NSMaxiumRange;
<a name="l02344"></a>02344   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions,      capture, <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;matchedRange, 0UL, NULL, NULL);
<a name="l02345"></a>02345   <span class="keywordflow">return</span>((matchedRange.location == (NSUInteger)NSNotFound) ? NULL : rkl_CFAutorelease(CFStringCreateWithSubstring(NULL, (CFStringRef)<span class="keyword">self</span>, CFMakeRange(matchedRange.location, matchedRange.length)))); <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02346"></a>02346 } <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02347"></a>02347 
<a name="l02348"></a>02348 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByMatching):(<a class="code" href="a00025.html">NSString</a> *)regex inRange:(NSRange)range
<a name="l02349"></a>02349 {
<a name="l02350"></a>02350   NSRange matchedRange = NSNotFoundRange;
<a name="l02351"></a>02351   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, RKLNoOptions,      0L,      <span class="keyword">self</span>, &amp;range, NULL, NULL,  &amp;matchedRange, 0UL, NULL, NULL);
<a name="l02352"></a>02352   <span class="keywordflow">return</span>((matchedRange.location == (NSUInteger)NSNotFound) ? NULL : rkl_CFAutorelease(CFStringCreateWithSubstring(NULL, (CFStringRef)<span class="keyword">self</span>, CFMakeRange(matchedRange.location, matchedRange.length)))); <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02353"></a>02353 } <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02354"></a>02354 
<a name="l02355"></a>02355 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByMatching):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range capture:(NSInteger)capture error:(NSError **)error
<a name="l02356"></a>02356 {
<a name="l02357"></a>02357   NSRange matchedRange = NSNotFoundRange;
<a name="l02358"></a>02358   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLRangeOp, regex, options,           capture, <span class="keyword">self</span>, &amp;range, NULL, error, &amp;matchedRange, 0UL, NULL, NULL);
<a name="l02359"></a>02359   <span class="keywordflow">return</span>((matchedRange.location == (NSUInteger)NSNotFound) ? NULL : rkl_CFAutorelease(CFStringCreateWithSubstring(NULL, (CFStringRef)<span class="keyword">self</span>, CFMakeRange(matchedRange.location, matchedRange.length)))); <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02360"></a>02360 } <span class="comment">// Warning about potential leak can be safely ignored.</span>
<a name="l02361"></a>02361 
<a name="l02362"></a>02362 <span class="preprocessor">#pragma mark -stringByReplacingOccurrencesOfRegex:</span>
<a name="l02363"></a>02363 <span class="preprocessor"></span>
<a name="l02364"></a>02364 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByReplacingOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withString:(<a class="code" href="a00025.html">NSString</a> *)replacement
<a name="l02365"></a>02365 {
<a name="l02366"></a>02366   NSRange searchRange = NSMaxiumRange;
<a name="l02367"></a>02367   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLReplaceOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, replacement, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02368"></a>02368 }
<a name="l02369"></a>02369 
<a name="l02370"></a>02370 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByReplacingOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withString:(<a class="code" href="a00025.html">NSString</a> *)replacement range:(NSRange)searchRange
<a name="l02371"></a>02371 {
<a name="l02372"></a>02372   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLReplaceOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, replacement, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02373"></a>02373 }
<a name="l02374"></a>02374 
<a name="l02375"></a>02375 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByReplacingOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withString:(<a class="code" href="a00025.html">NSString</a> *)replacement options:(RKLRegexOptions)options range:(NSRange)searchRange error:(NSError **)error
<a name="l02376"></a>02376 {
<a name="l02377"></a>02377   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLReplaceOp, regex, options,      0L, <span class="keyword">self</span>, &amp;searchRange, replacement, error, NULL, 0UL, NULL, NULL));
<a name="l02378"></a>02378 }
<a name="l02379"></a>02379 
<a name="l02380"></a>02380 <span class="preprocessor">#pragma mark -componentsMatchedByRegex:</span>
<a name="l02381"></a>02381 <span class="preprocessor"></span>
<a name="l02382"></a>02382 - (NSArray *)RKL_METHOD_PREPEND(componentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02383"></a>02383 {
<a name="l02384"></a>02384   NSRange searchRange = NSMaxiumRange;
<a name="l02385"></a>02385   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfStringsOp, regex, RKLNoOptions, 0L,      <span class="keyword">self</span>, &amp;searchRange, NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02386"></a>02386 }
<a name="l02387"></a>02387 
<a name="l02388"></a>02388 - (NSArray *)RKL_METHOD_PREPEND(componentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex capture:(NSInteger)capture
<a name="l02389"></a>02389 {
<a name="l02390"></a>02390   NSRange searchRange = NSMaxiumRange;
<a name="l02391"></a>02391   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfStringsOp, regex, RKLNoOptions, capture, <span class="keyword">self</span>, &amp;searchRange, NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02392"></a>02392 }
<a name="l02393"></a>02393 
<a name="l02394"></a>02394 - (NSArray *)RKL_METHOD_PREPEND(componentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex range:(NSRange)range
<a name="l02395"></a>02395 {
<a name="l02396"></a>02396   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfStringsOp, regex, RKLNoOptions, 0L,      <span class="keyword">self</span>, &amp;range,       NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02397"></a>02397 }
<a name="l02398"></a>02398 
<a name="l02399"></a>02399 - (NSArray *)RKL_METHOD_PREPEND(componentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range capture:(NSInteger)capture error:(NSError **)error
<a name="l02400"></a>02400 {
<a name="l02401"></a>02401   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfStringsOp, regex, options,      capture, <span class="keyword">self</span>, &amp;range,       NULL, error, NULL, 0UL, NULL, NULL));
<a name="l02402"></a>02402 }
<a name="l02403"></a>02403 
<a name="l02404"></a>02404 <span class="preprocessor">#pragma mark -captureComponentsMatchedByRegex:</span>
<a name="l02405"></a>02405 <span class="preprocessor"></span>
<a name="l02406"></a>02406 - (NSArray *)RKL_METHOD_PREPEND(captureComponentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02407"></a>02407 {
<a name="l02408"></a>02408   NSRange searchRange = NSMaxiumRange;
<a name="l02409"></a>02409   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02410"></a>02410 }
<a name="l02411"></a>02411 
<a name="l02412"></a>02412 - (NSArray *)RKL_METHOD_PREPEND(captureComponentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex range:(NSRange)range
<a name="l02413"></a>02413 {
<a name="l02414"></a>02414   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range,       NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02415"></a>02415 }
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 - (NSArray *)RKL_METHOD_PREPEND(captureComponentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error
<a name="l02418"></a>02418 {
<a name="l02419"></a>02419   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, options,      0L, <span class="keyword">self</span>, &amp;range,       NULL, error, NULL, 0UL, NULL, NULL));
<a name="l02420"></a>02420 }
<a name="l02421"></a>02421 
<a name="l02422"></a>02422 <span class="preprocessor">#pragma mark -arrayOfCaptureComponentsMatchedByRegex:</span>
<a name="l02423"></a>02423 <span class="preprocessor"></span>
<a name="l02424"></a>02424 - (NSArray *)RKL_METHOD_PREPEND(arrayOfCaptureComponentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex
<a name="l02425"></a>02425 {
<a name="l02426"></a>02426   NSRange searchRange = NSMaxiumRange;
<a name="l02427"></a>02427   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)(RKLArrayOfCapturesOp | RKLSubcapturesArray), regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02428"></a>02428 }
<a name="l02429"></a>02429 
<a name="l02430"></a>02430 - (NSArray *)RKL_METHOD_PREPEND(arrayOfCaptureComponentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex range:(NSRange)range
<a name="l02431"></a>02431 {
<a name="l02432"></a>02432   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)(RKLArrayOfCapturesOp | RKLSubcapturesArray), regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range,       NULL, NULL,  NULL, 0UL, NULL, NULL));
<a name="l02433"></a>02433 }
<a name="l02434"></a>02434 
<a name="l02435"></a>02435 - (NSArray *)RKL_METHOD_PREPEND(arrayOfCaptureComponentsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error
<a name="l02436"></a>02436 {
<a name="l02437"></a>02437   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)(RKLArrayOfCapturesOp | RKLSubcapturesArray), regex, options,      0L, <span class="keyword">self</span>, &amp;range,       NULL, error, NULL, 0UL, NULL, NULL));
<a name="l02438"></a>02438 }
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="preprocessor">#pragma mark -dictionaryByMatchingRegex:</span>
<a name="l02441"></a>02441 <span class="preprocessor"></span>
<a name="l02442"></a>02442 - (NSDictionary *)RKL_METHOD_PREPEND(dictionaryByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withKeysAndCaptures:(<span class="keywordtype">id</span>)firstKey, ...
<a name="l02443"></a>02443 {
<a name="l02444"></a>02444   NSRange searchRange  = NSMaxiumRange;
<a name="l02445"></a>02445   <span class="keywordtype">id</span>      returnObject = NULL;
<a name="l02446"></a>02446   va_list varArgsList;
<a name="l02447"></a>02447   va_start(varArgsList, firstKey);
<a name="l02448"></a>02448   returnObject = rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLDictionaryOfCapturesOp, regex, (RKLRegexOptions)RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, NULL, NULL, NULL, firstKey, varArgsList);
<a name="l02449"></a>02449   va_end(varArgsList);
<a name="l02450"></a>02450   <span class="keywordflow">return</span>(returnObject);
<a name="l02451"></a>02451 }
<a name="l02452"></a>02452 
<a name="l02453"></a>02453 - (NSDictionary *)RKL_METHOD_PREPEND(dictionaryByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex range:(NSRange)range withKeysAndCaptures:(<span class="keywordtype">id</span>)firstKey, ...
<a name="l02454"></a>02454 {
<a name="l02455"></a>02455   <span class="keywordtype">id</span> returnObject = NULL;
<a name="l02456"></a>02456   va_list varArgsList;
<a name="l02457"></a>02457   va_start(varArgsList, firstKey);
<a name="l02458"></a>02458   returnObject = rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLDictionaryOfCapturesOp, regex, (RKLRegexOptions)RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range, NULL, NULL, NULL, firstKey, varArgsList);
<a name="l02459"></a>02459   va_end(varArgsList);
<a name="l02460"></a>02460   <span class="keywordflow">return</span>(returnObject);
<a name="l02461"></a>02461 }
<a name="l02462"></a>02462 
<a name="l02463"></a>02463 - (NSDictionary *)RKL_METHOD_PREPEND(dictionaryByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error withKeysAndCaptures:(<span class="keywordtype">id</span>)firstKey, ...
<a name="l02464"></a>02464 {
<a name="l02465"></a>02465   <span class="keywordtype">id</span> returnObject = NULL;
<a name="l02466"></a>02466   va_list varArgsList;
<a name="l02467"></a>02467   va_start(varArgsList, firstKey);
<a name="l02468"></a>02468   returnObject = rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLDictionaryOfCapturesOp, regex, options, 0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, firstKey, varArgsList);
<a name="l02469"></a>02469   va_end(varArgsList);
<a name="l02470"></a>02470   <span class="keywordflow">return</span>(returnObject);
<a name="l02471"></a>02471 }
<a name="l02472"></a>02472 
<a name="l02473"></a>02473 - (NSDictionary *)RKL_METHOD_PREPEND(dictionaryByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error withFirstKey:(<span class="keywordtype">id</span>)firstKey arguments:(va_list)varArgsList
<a name="l02474"></a>02474 {
<a name="l02475"></a>02475   <span class="keywordflow">return</span>(rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLDictionaryOfCapturesOp, regex, options, 0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, firstKey, varArgsList));
<a name="l02476"></a>02476 }
<a name="l02477"></a>02477 
<a name="l02478"></a>02478 - (NSDictionary *)RKL_METHOD_PREPEND(dictionaryByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error withKeys:(<span class="keywordtype">id</span> *)keys forCaptures:(<span class="keywordtype">int</span> *)captures count:(NSUInteger)count
<a name="l02479"></a>02479 {
<a name="l02480"></a>02480   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLDictionaryOfCapturesOp, regex, options, 0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, count, keys, captures));
<a name="l02481"></a>02481 }
<a name="l02482"></a>02482 
<a name="l02483"></a>02483 <span class="preprocessor">#pragma mark -arrayOfDictionariesByMatchingRegex:</span>
<a name="l02484"></a>02484 <span class="preprocessor"></span>
<a name="l02485"></a>02485 - (NSArray *)RKL_METHOD_PREPEND(arrayOfDictionariesByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withKeysAndCaptures:(<span class="keywordtype">id</span>)firstKey, ...
<a name="l02486"></a>02486 {
<a name="l02487"></a>02487   NSRange searchRange  = NSMaxiumRange;
<a name="l02488"></a>02488   <span class="keywordtype">id</span>      returnObject = NULL;
<a name="l02489"></a>02489   va_list varArgsList;
<a name="l02490"></a>02490   va_start(varArgsList, firstKey);
<a name="l02491"></a>02491   returnObject = rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfDictionariesOfCapturesOp, regex, (RKLRegexOptions)RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, NULL, NULL, NULL, firstKey, varArgsList);
<a name="l02492"></a>02492   va_end(varArgsList);
<a name="l02493"></a>02493   <span class="keywordflow">return</span>(returnObject);
<a name="l02494"></a>02494 }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496 - (NSArray *)RKL_METHOD_PREPEND(arrayOfDictionariesByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex range:(NSRange)range withKeysAndCaptures:(<span class="keywordtype">id</span>)firstKey, ...
<a name="l02497"></a>02497 {
<a name="l02498"></a>02498   <span class="keywordtype">id</span> returnObject = NULL;
<a name="l02499"></a>02499   va_list varArgsList;
<a name="l02500"></a>02500   va_start(varArgsList, firstKey);
<a name="l02501"></a>02501   returnObject = rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfDictionariesOfCapturesOp, regex, (RKLRegexOptions)RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;range, NULL, NULL, NULL, firstKey, varArgsList);
<a name="l02502"></a>02502   va_end(varArgsList);
<a name="l02503"></a>02503   <span class="keywordflow">return</span>(returnObject);
<a name="l02504"></a>02504 }
<a name="l02505"></a>02505 
<a name="l02506"></a>02506 - (NSArray *)RKL_METHOD_PREPEND(arrayOfDictionariesByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error withKeysAndCaptures:(<span class="keywordtype">id</span>)firstKey, ...
<a name="l02507"></a>02507 {
<a name="l02508"></a>02508   <span class="keywordtype">id</span> returnObject = NULL;
<a name="l02509"></a>02509   va_list varArgsList;
<a name="l02510"></a>02510   va_start(varArgsList, firstKey);
<a name="l02511"></a>02511   returnObject = rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfDictionariesOfCapturesOp, regex, options, 0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, firstKey, varArgsList);
<a name="l02512"></a>02512   va_end(varArgsList);
<a name="l02513"></a>02513   <span class="keywordflow">return</span>(returnObject);
<a name="l02514"></a>02514 }
<a name="l02515"></a>02515 
<a name="l02516"></a>02516 - (NSArray *)RKL_METHOD_PREPEND(arrayOfDictionariesByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error withFirstKey:(<span class="keywordtype">id</span>)firstKey arguments:(va_list)varArgsList
<a name="l02517"></a>02517 {
<a name="l02518"></a>02518   <span class="keywordflow">return</span>(rkl_performDictionaryVarArgsOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfDictionariesOfCapturesOp, regex, options, 0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, firstKey, varArgsList));
<a name="l02519"></a>02519 }
<a name="l02520"></a>02520 
<a name="l02521"></a>02521 - (NSArray *)RKL_METHOD_PREPEND(arrayOfDictionariesByMatchingRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options range:(NSRange)range error:(NSError **)error withKeys:(<span class="keywordtype">id</span> *)keys forCaptures:(<span class="keywordtype">int</span> *)captures count:(NSUInteger)count
<a name="l02522"></a>02522 {
<a name="l02523"></a>02523   <span class="keywordflow">return</span>(rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLArrayOfDictionariesOfCapturesOp, regex, options, 0L, <span class="keyword">self</span>, &amp;range, NULL, error, NULL, count, keys, captures));
<a name="l02524"></a>02524 }
<a name="l02525"></a>02525 
<a name="l02526"></a>02526 <span class="preprocessor">#ifdef    _RKL_BLOCKS_ENABLED</span>
<a name="l02527"></a>02527 <span class="preprocessor"></span>
<a name="l02529"></a>02529 <span class="preprocessor">#pragma mark -</span>
<a name="l02530"></a>02530 <span class="preprocessor"></span><span class="preprocessor">#pragma mark ^Blocks Related NSString Methods</span>
<a name="l02531"></a>02531 <span class="preprocessor"></span>
<a name="l02532"></a>02532 <span class="preprocessor">#pragma mark -enumerateStringsMatchedByRegex:usingBlock:</span>
<a name="l02533"></a>02533 <span class="preprocessor"></span>
<a name="l02534"></a>02534 - (BOOL)RKL_METHOD_PREPEND(enumerateStringsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex usingBlock:(<span class="keywordtype">void</span> (^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02535"></a>02535 {
<a name="l02536"></a>02536   NSUInteger errorFree = NO;
<a name="l02537"></a>02537   rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, (RKLRegexOptions)RKLNoOptions, <span class="keyword">self</span>, NSMaxiumRange, (RKLBlockEnumerationOp)RKLBlockEnumerationMatchOp, 0UL,                NULL, &amp;errorFree, NULL,  block, NULL);
<a name="l02538"></a>02538   <span class="keywordflow">return</span>(errorFree == NO ? NO : YES);
<a name="l02539"></a>02539 }
<a name="l02540"></a>02540 
<a name="l02541"></a>02541 - (BOOL)RKL_METHOD_PREPEND(enumerateStringsMatchedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range error:(NSError **)error enumerationOptions:(RKLRegexEnumerationOptions)enumerationOptions usingBlock:(<span class="keywordtype">void</span> (^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02542"></a>02542 {
<a name="l02543"></a>02543   NSUInteger errorFree = NO;
<a name="l02544"></a>02544   rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, options,                       <span class="keyword">self</span>, range,         (RKLBlockEnumerationOp)RKLBlockEnumerationMatchOp, enumerationOptions, NULL, &amp;errorFree, error, block, NULL);
<a name="l02545"></a>02545   <span class="keywordflow">return</span>(errorFree == NO ? NO : YES);
<a name="l02546"></a>02546 }
<a name="l02547"></a>02547 
<a name="l02548"></a>02548 <span class="preprocessor">#pragma mark -enumerateStringsSeparatedByRegex:usingBlock:</span>
<a name="l02549"></a>02549 <span class="preprocessor"></span>
<a name="l02550"></a>02550 - (BOOL)RKL_METHOD_PREPEND(enumerateStringsSeparatedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex usingBlock:(<span class="keywordtype">void</span> (^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02551"></a>02551 {
<a name="l02552"></a>02552   NSUInteger errorFree = NO;
<a name="l02553"></a>02553   rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLSplitOp,         regex, (RKLRegexOptions)RKLNoOptions, <span class="keyword">self</span>, NSMaxiumRange, (RKLBlockEnumerationOp)RKLBlockEnumerationMatchOp, 0UL,                NULL, &amp;errorFree, NULL,  block, NULL);
<a name="l02554"></a>02554   <span class="keywordflow">return</span>(errorFree == NO ? NO : YES);
<a name="l02555"></a>02555 }
<a name="l02556"></a>02556 
<a name="l02557"></a>02557 - (BOOL)RKL_METHOD_PREPEND(enumerateStringsSeparatedByRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range error:(NSError **)error enumerationOptions:(RKLRegexEnumerationOptions)enumerationOptions usingBlock:(<span class="keywordtype">void</span> (^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02558"></a>02558 {
<a name="l02559"></a>02559   NSUInteger errorFree = NO;
<a name="l02560"></a>02560   rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLSplitOp,         regex, options,                       <span class="keyword">self</span>, range,         (RKLBlockEnumerationOp)RKLBlockEnumerationMatchOp, enumerationOptions, NULL, &amp;errorFree, error, block, NULL);
<a name="l02561"></a>02561   <span class="keywordflow">return</span>(errorFree == NO ? NO : YES);  
<a name="l02562"></a>02562 }
<a name="l02563"></a>02563 
<a name="l02564"></a>02564 <span class="preprocessor">#pragma mark -stringByReplacingOccurrencesOfRegex:usingBlock:</span>
<a name="l02565"></a>02565 <span class="preprocessor"></span>
<a name="l02566"></a>02566 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByReplacingOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex usingBlock:(<a class="code" href="a00025.html">NSString</a> *(^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02567"></a>02567 {
<a name="l02568"></a>02568   <span class="keywordflow">return</span>(rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, (RKLRegexOptions)RKLNoOptions, <span class="keyword">self</span>, NSMaxiumRange, (RKLBlockEnumerationOp)RKLBlockEnumerationReplaceOp, 0UL,                NULL, NULL, NULL,  NULL, block));
<a name="l02569"></a>02569 }
<a name="l02570"></a>02570 
<a name="l02571"></a>02571 - (<a class="code" href="a00025.html">NSString</a> *)RKL_METHOD_PREPEND(stringByReplacingOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range error:(NSError **)error enumerationOptions:(RKLRegexEnumerationOptions)enumerationOptions usingBlock:(<a class="code" href="a00025.html">NSString</a> *(^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02572"></a>02572 {
<a name="l02573"></a>02573   <span class="keywordflow">return</span>(rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, options,                       <span class="keyword">self</span>, range,         (RKLBlockEnumerationOp)RKLBlockEnumerationReplaceOp, enumerationOptions, NULL, NULL, error, NULL, block));
<a name="l02574"></a>02574 }
<a name="l02575"></a>02575 
<a name="l02576"></a>02576 <span class="preprocessor">#endif // _RKL_BLOCKS_ENABLED</span>
<a name="l02577"></a>02577 <span class="preprocessor"></span>
<a name="l02578"></a>02578 <span class="keyword">@end</span>
<a name="l02579"></a>02579 
<a name="l02581"></a>02581 <span class="preprocessor">#pragma mark -</span>
<a name="l02582"></a><a class="code" href="a00014.html">02582</a> <span class="preprocessor"></span><span class="keyword">@implementation </span><a class="code" href="a00014.html">NSMutableString</a> (RegexKitLiteAdditions)
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 <span class="preprocessor">#pragma mark -replaceOccurrencesOfRegex:</span>
<a name="l02585"></a>02585 <span class="preprocessor"></span>
<a name="l02586"></a>02586 - (NSInteger)RKL_METHOD_PREPEND(replaceOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withString:(<a class="code" href="a00025.html">NSString</a> *)replacement
<a name="l02587"></a>02587 {
<a name="l02588"></a>02588   NSRange    searchRange   = NSMaxiumRange;
<a name="l02589"></a>02589   NSInteger replacedCount = -1L;
<a name="l02590"></a>02590   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)(RKLReplaceOp | RKLReplaceMutable), regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, replacement, NULL,  (<span class="keywordtype">void</span> **)((<span class="keywordtype">void</span> *)&amp;replacedCount), 0UL, NULL, NULL);
<a name="l02591"></a>02591   <span class="keywordflow">return</span>(replacedCount);
<a name="l02592"></a>02592 }
<a name="l02593"></a>02593 
<a name="l02594"></a>02594 - (NSInteger)RKL_METHOD_PREPEND(replaceOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withString:(<a class="code" href="a00025.html">NSString</a> *)replacement range:(NSRange)searchRange
<a name="l02595"></a>02595 {
<a name="l02596"></a>02596   NSInteger replacedCount = -1L;
<a name="l02597"></a>02597   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)(RKLReplaceOp | RKLReplaceMutable), regex, RKLNoOptions, 0L, <span class="keyword">self</span>, &amp;searchRange, replacement, NULL,  (<span class="keywordtype">void</span> **)((<span class="keywordtype">void</span> *)&amp;replacedCount), 0UL, NULL, NULL);
<a name="l02598"></a>02598   <span class="keywordflow">return</span>(replacedCount);
<a name="l02599"></a>02599 }
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 - (NSInteger)RKL_METHOD_PREPEND(replaceOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex withString:(<a class="code" href="a00025.html">NSString</a> *)replacement options:(RKLRegexOptions)options range:(NSRange)searchRange error:(NSError **)error
<a name="l02602"></a>02602 {
<a name="l02603"></a>02603   NSInteger replacedCount = -1L;
<a name="l02604"></a>02604   rkl_performRegexOp(<span class="keyword">self</span>, _cmd, (RKLRegexOp)(RKLReplaceOp | RKLReplaceMutable), regex, options,      0L, <span class="keyword">self</span>, &amp;searchRange, replacement, error, (<span class="keywordtype">void</span> **)((<span class="keywordtype">void</span> *)&amp;replacedCount), 0UL, NULL, NULL);
<a name="l02605"></a>02605   <span class="keywordflow">return</span>(replacedCount);
<a name="l02606"></a>02606 }
<a name="l02607"></a>02607 
<a name="l02608"></a>02608 <span class="preprocessor">#ifdef    _RKL_BLOCKS_ENABLED</span>
<a name="l02609"></a>02609 <span class="preprocessor"></span>
<a name="l02611"></a>02611 <span class="preprocessor">#pragma mark -</span>
<a name="l02612"></a>02612 <span class="preprocessor"></span><span class="preprocessor">#pragma mark ^Blocks Related NSMutableString Methods</span>
<a name="l02613"></a>02613 <span class="preprocessor"></span>
<a name="l02614"></a>02614 <span class="preprocessor">#pragma mark -replaceOccurrencesOfRegex:usingBlock:</span>
<a name="l02615"></a>02615 <span class="preprocessor"></span>
<a name="l02616"></a>02616 - (NSInteger)RKL_METHOD_PREPEND(replaceOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex usingBlock:(<a class="code" href="a00025.html">NSString</a> *(^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02617"></a>02617 {
<a name="l02618"></a>02618   NSUInteger errorFree     = 0UL;
<a name="l02619"></a>02619   NSInteger replacedCount  = -1L;
<a name="l02620"></a>02620   <a class="code" href="a00025.html">NSString</a> *replacedString = rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, RKLNoOptions, <span class="keyword">self</span>, NSMaxiumRange, (RKLBlockEnumerationOp)RKLBlockEnumerationReplaceOp, 0UL,                &amp;replacedCount, &amp;errorFree, NULL,  NULL, block);
<a name="l02621"></a>02621   <span class="keywordflow">if</span>((errorFree == YES) &amp;&amp; (replacedCount &gt; 0L)) { [<span class="keyword">self</span> replaceCharactersInRange:NSMakeRange(0UL, [<span class="keyword">self</span> length]) withString:replacedString]; }
<a name="l02622"></a>02622   <span class="keywordflow">return</span>(replacedCount);
<a name="l02623"></a>02623 }
<a name="l02624"></a>02624 
<a name="l02625"></a>02625 - (NSInteger)RKL_METHOD_PREPEND(replaceOccurrencesOfRegex):(<a class="code" href="a00025.html">NSString</a> *)regex options:(RKLRegexOptions)options inRange:(NSRange)range error:(NSError **)error enumerationOptions:(RKLRegexEnumerationOptions)enumerationOptions usingBlock:(<a class="code" href="a00025.html">NSString</a> *(^)(NSInteger captureCount, <a class="code" href="a00025.html">NSString</a> * const capturedStrings[captureCount], const NSRange capturedRanges[captureCount], volatile BOOL * const stop))block
<a name="l02626"></a>02626 {
<a name="l02627"></a>02627   NSUInteger errorFree     = 0UL;
<a name="l02628"></a>02628   NSInteger replacedCount  = -1L;
<a name="l02629"></a>02629   <a class="code" href="a00025.html">NSString</a> *replacedString = rkl_performEnumerationUsingBlock(<span class="keyword">self</span>, _cmd, (RKLRegexOp)RKLCapturesArrayOp, regex, options,      <span class="keyword">self</span>, range,         (RKLBlockEnumerationOp)RKLBlockEnumerationReplaceOp, enumerationOptions, &amp;replacedCount, &amp;errorFree, error, NULL, block);
<a name="l02630"></a>02630   <span class="keywordflow">if</span>((errorFree == YES) &amp;&amp; (replacedCount &gt; 0L)) { [<span class="keyword">self</span> replaceCharactersInRange:range withString:replacedString]; }
<a name="l02631"></a>02631   <span class="keywordflow">return</span>(replacedCount);
<a name="l02632"></a>02632 }
<a name="l02633"></a>02633 
<a name="l02634"></a>02634 <span class="preprocessor">#endif // _RKL_BLOCKS_ENABLED</span>
<a name="l02635"></a>02635 <span class="preprocessor"></span>
<a name="l02636"></a>02636 <span class="keyword">@end</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>RegexKitLite.m</b>      </li>

    <li class="footer">Generated on Mon Mar 12 2012 21:33:05 for Wired Foundation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
